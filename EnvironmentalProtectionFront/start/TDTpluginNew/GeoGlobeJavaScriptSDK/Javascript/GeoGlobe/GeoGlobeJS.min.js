window.GeoGlobe = {singleFile: !0};
(function () {
    window.GeoGlobe = window.GeoGlobe || {};
    window.GeoGlobe.LngLatBounds = {};
    window.GeoGlobe.LngLat = {};
    window.GeoGlobe.Point = mapboxgl.Point;
    window.GeoGlobe.BoxHandler = mapboxgl.BoxHandler;
    window.GeoGlobe.Class = {};
    window.GeoGlobe.Layer = {};
    window.GeoGlobe.Source = {};
    window.GeoGlobe.Event = {};
    window.GeoGlobe.Control = {};
    window.GeoGlobe.Marker = {};
    window.GeoGlobe.Popup = {};
    window.GeoGlobe.Filter = {};
    window.GeoGlobe.Format = {};
    window.GeoGlobe.Analysis = {};
    window.GeoGlobe.Protocol = {};
    window.GeoGlobe.Query = {};
    window.GeoGlobe.Statistic = {};
    window.GeoGlobe.HeatMap = {};
    window.GeoGlobe.LayerGroup = {};
    window.GeoGlobe.Protocol = {};
    window.GeoGlobe.Service = {};
    window.GeoGlobe.DynamicFeature = {};
    window.GeoGlobe.DynamicTrace = {};
    GeoGlobe.getScriptArg = function (a) {
        var b = document.getElementsByTagName("script");
        return (b[b.length - 1].src.match(RegExp("(?:\\?|&)" + a + "=(.*?)(?=&|$)")) || ["", null])[1]
    };
    if (!GeoGlobe.singleFile) {
        for (var a = ["View2D/tool/Class.js", "View2D/tool/dom.js", "View2D/tool/Util.js", "View2D/tool/Proj4cn.js", "View2D/tool/ProjAxisOrder.js",
            "View2D/tool/Projection.js", "View2D/BaseTypes/BaseTypes.js", "View2D/BaseTypes/Pixel.js", "View2D/BaseTypes/Size.js", "View2D/BaseTypes/Date.js", "View2D/tool/Console.js", "View2D/tool/Request/Request.js", "View2D/tool/Request/XMLHttpRequest.js", "View2D/map/Map.js", "View2D/geo/Lng_Lat_bounds_geo.js", "View2D/geo/Lng_Lat_geo.js", "View2D/Layer/Layer.js", "View2D/Layer/wmsLayer.js", "View2D/Layer/wmtsLayer.js", "View2D/Layer/WMTS.js", "View2D/Layer/WMS.js", "View2D/Layer/GeoTileLayer.js", "View2D/Layer/GeoWMTSLayer.js",
            "View2D/Layer/vectortileLayer.js", "View2D/Layer/VTS.js", "View2D/Layer/RasterLayer.js", "View2D/Layer/FillLayer.js", "View2D/Layer/CircleLayer.js", "View2D/Layer/SymbolLayer.js", "View2D/Layer/FillExtrusionLayer.js", "View2D/Layer/LineLayer.js", "View2D/Layer/BackgroundLayer.js", "View2D/Layer/ThematicTileLayer.js", "View2D/Layer/CanvasLayer.js", "View2D/Layer/TDTLayer.js", "View2D/Layer/HotArea.js", "View2D/Source/Source.js", "View2D/Source/GeoJSONSource.js", "View2D/Source/RasterSource.js", "View2D/Source/ImageSource.js",
            "View2D/Source/VectorSource.js", "View2D/Source/VideoSource.js", "View2D/Source/CanvasSource.js", "View2D/Marker/Marker.js", "View2D/Popup/Popup.js", "View2D/control/Control.js", "View2D/control/Navigation.js", "View2D/control/Attribution.js", "View2D/control/Scale.js", "View2D/control/Geolocate.js", "View2D/control/MapContextMenu.js", "View2D/event/Event.js", "View2D/event/mapMouseEvent.js", "View2D/event/mapTouchEvent.js", "View2D/event/mapDataEvent.js", "View2D/event/mapBoxZoomEvent.js", "View2D/handler/Handler.js",
            "View2D/handler/BoxZoomHandler.js", "View2D/handler/DoubleClickZoomHandler.js", "View2D/handler/DragPanHandler.js", "View2D/handler/DragRotateHandler.js", "View2D/handler/KeyboardHandler.js", "View2D/handler/ScrollZoomHandler.js", "View2D/handler/TouchZoomRotateHandler.js", "View2D/AutoFeature/DynamicTrace.js", "View2D/AutoFeature/DynamicFeature.js", "View2D/Geometry/Geometry.js", "View2D/Geometry/Collection.js", "View2D/Geometry/Point.js", "View2D/Geometry/MultiPoint.js", "View2D/Geometry/Curve.js", "View2D/Geometry/LineString.js",
            "View2D/Geometry/LinearRing.js", "View2D/Geometry/Polygon.js", "View2D/Geometry/MultiLineString.js", "View2D/Geometry/MultiPolygon.js", "View2D/Feature/Feature.js", "View2D/Filter/Filter.js", "View2D/Filter/FeatureId.js", "View2D/Filter/Logical.js", "View2D/Filter/Comparison.js", "View2D/Filter/Spatial.js", "View2D/Filter/Function.js", "View2D/Protocol/Protocol.js", "View2D/Protocol/HTTP.js", "View2D/Protocol/WFS.js", "View2D/Protocol/WFS/v1.js", "View2D/Protocol/WFS/v1_0_0.js", "View2D/Protocol/WFS/v1_1_0.js", "View2D/Protocol/CSW.js",
            "View2D/Protocol/CSW/v2_0_2.js", "View2D/Protocol/Script.js", "View2D/Format/Format.js", "View2D/Format/XML.js", "View2D/Format/XML/VersionedOGC.js", "View2D/Format/GML.js", "View2D/Format/GML/Base.js", "View2D/Format/GML/v2.js", "View2D/Format/GML/v3.js", "View2D/Format/KML.js", "View2D/Format/OWSCommon.js", "View2D/Format/OWSCommon/v1.js", "View2D/Format/OWSCommon/v1_0_0.js", "View2D/Format/OWSCommon/v1_1_0.js", "View2D/Format/WFSCapabilities.js", "View2D/Format/WFSCapabilities/v1.js", "View2D/Format/WFSCapabilities/v1_0_0.js",
            "View2D/Format/WFSCapabilities/v1_1_0.js", "View2D/Format/WFSDescribeFeatureType.js", "View2D/Format/WKT.js", "View2D/Format/CQL.js", "View2D/Format/Filter.js", "View2D/Format/Filter/v1.js", "View2D/Format/Filter/v1_0_0.js", "View2D/Format/Filter/v1_1_0.js", "View2D/Format/WFST.js", "View2D/Format/WFST/v1.js", "View2D/Format/WFST/v1_0_0.js", "View2D/Format/WFST/v1_1_0.js", "View2D/Format/JSON.js", "View2D/Format/GeoJSON.js", "View2D/Format/Util/WMTS.js", "View2D/Format/Util/WMS.js", "View2D/Format/Util/VTS.js", "View2D/Format/WMSCapabilities.js",
            "View2D/Format/WMSCapabilities/v1.js", "View2D/Format/WMSCapabilities/v1_1.js", "View2D/Format/WMSCapabilities/v1_1_0.js", "View2D/Format/WMSCapabilities/v1_1_1.js", "View2D/Format/WMSCapabilities/v1_1_1_WMSC.js", "View2D/Format/WMSCapabilities/v1_3.js", "View2D/Format/WMSCapabilities/v1_3_0.js", "View2D/Format/WMSUtil.js", "View2D/Format/WMTSCapabilities.js", "View2D/Format/WMTSCapabilities/v1_0_0.js", "View2D/Format/WMTSUtil.js", "View2D/Format/VTSCapabilities.js", "View2D/Format/VTSCapabilities/v1_0_0.js",
            "View2D/Format/WPSCapabilities.js", "View2D/Format/WPSCapabilities/v1_0_0.js", "View2D/Format/WCSGetCoverage.js", "View2D/Format/WPSExecute.js", "View2D/Format/OGCExceptionReport.js", "View2D/Format/QueryStringFilter.js", "View2D/Format/BusCapabilities.js", "View2D/Format/XML2JSON.js", "View2D/Format/CSWGetRecords.js", "View2D/Format/CSWGetRecords/v2_0_2.js", "View2D/Format/QueryStringFilter.js", "View2D/Format/X2JS.js", "View2D/Analysis/BufferAnalysis.js", "View2D/Analysis/GetFeature.js", "View2D/Analysis/SpatialAnalysis.js",
            "View2D/Analysis/CoreBufferAnalysis.js", "View2D/Query/Service.js", "View2D/Query/RouteQuery.js", "View2D/Query/RoutesResult.js", "View2D/Query/RouteInfoResult.js", "View2D/Query/BusQuery.js", "View2D/Query/WFSQuery.js", "View2D/Query/GeoCodingQuery.js", "View2D/Query/GeoCodingQuery/v1.js", "View2D/Query/GeoCodingQuery/v1_0_0.js", "View2D/Query/GeoCodingQuery/v1_1_0.js", "View2D/Heatmap/HeatMap.js", "View2D/BaseLayerGroup/BaseLayerGroup.js", "View2D/Service/Service.js", "View2D/Service/WFST.js", "View2D/Service/CTS.js",
            "View2D/Service/VTS.js", "View2D/Service/WMS.js", "View2D/Service/WMTS.js", "View2D/Service/DTJ.js", "View2D/Service/Fonts.js", "View2D/Statistics/GeoStatisticsService.js", "View2D/ElementContainer/ElementContainer.js", "View2D/ElementContainer/MaptalksEC.js", "View2D/tool/Lang.js", "View2D/tool/Lang/en.js", "View2D/tool/Lang/zh-CN.js"], b = "", c = /(^|(.*?\/))(GeoGlobeJSAPI.js)(\?|$)/, d = document.getElementsByTagName("script"), e = 0, f = d.length; e < f; e++) {
            var g = d[e].getAttribute("src");
            if (g && (g = g.match(c))) {
                b = g[1];
                break
            }
        }
        c =
            Array(a.length);
        e = 0;
        for (f = a.length; e < f; e++)c[e] = "<script src='" + b + a[e] + "'><\/script>";
        c.length > 0 && document.write(c.join(""))
    }
    GeoGlobe.scriptName = !GeoGlobe.singleFile ? "GeoGlobeJSAPI/GeoGlobeJSAPI.js" : "GeoGlobeJS.min.js";
    GeoGlobe.getScriptLocation = function () {
        for (var a = "", b = RegExp("(^|(.*?\\/))(" + GeoGlobe.scriptName + ")(\\?|$)"), c = document.getElementsByTagName("script"), d = 0, e = c.length; d < e; d++) {
            var f = c[d].getAttribute("src");
            if (f && (f = f.match(b))) {
                a = f[1];
                break
            }
        }
        return a
    };
    GeoGlobe.imagesPath = "";
    GeoGlobe.createNS =
        function (a) {
            for (var a = a.split("."), b = window, c = 0; c < a.length; c++)b[a[c]] || (b[a[c]] = {}), b = b[a[c]]
        };
    GeoGlobe.VERSION_NUMBER = "GeoGlobeJSAPI 6.4 -- $Version: 1.32.171211 build-20171230 $"
})();
GeoGlobe.Class = function () {
    var a = arguments.length, b = arguments[0], c = arguments[a - 1],
        d = typeof c.initialize == "function" ? c.initialize : function () {
            b.prototype.initialize.apply(this, arguments)
        };
    a > 1 ? [d, b].concat(Array.prototype.slice.call(arguments).slice(1, a - 1), c) : d.prototype = c;
    return d
};
GeoGlobe.Class4OL = function () {
    var a = arguments.length, b = arguments[0], c = arguments[a - 1],
        d = typeof c.initialize == "function" ? c.initialize : function () {
            b.prototype.initialize.apply(this, arguments)
        };
    a > 1 ? (a = [d, b].concat(Array.prototype.slice.call(arguments).slice(1, a - 1), c), GeoGlobe.inherit.apply(null, a)) : d.prototype = c;
    return d
};
GeoGlobe.inherit = function (a, b) {
    var c = function () {
    };
    c.prototype = b.prototype;
    a.prototype = new c;
    var d, e, c = 2;
    for (d = arguments.length; c < d; c++) {
        e = arguments[c];
        if (typeof e === "function") e = e.prototype;
        GeoGlobe.Util.extend(a.prototype, e)
    }
};
GeoGlobe.Util = GeoGlobe.Util || {};
GeoGlobe.Util.extend = function (a, b) {
    a = a || {};
    if (b) {
        for (var c in b) {
            var d = b[c];
            d !== void 0 && (a[c] = d)
        }
        if (!(typeof window.Event == "function" && b instanceof window.Event) && b.hasOwnProperty && b.hasOwnProperty("toString")) a.toString = b.toString
    }
    return a
};
(function () {
    function a(a) {
        for (var b = 0; b < a.length; b++)if (a[b] in c)return a[b];
        return a[0]
    }

    function b(a) {
        a.preventDefault();
        a.stopPropagation();
        window.removeEventListener("click", b, !0)
    }

    GeoGlobe.DOM = GeoGlobe.DOM || {};
    GeoGlobe.DOM.create = function (a, b, c) {
        a = window.document.createElement(a);
        if (b) a.className = b;
        c && c.appendChild(a);
        return a
    };
    var c = window.document.documentElement.style,
        d = a(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), e;
    GeoGlobe.DOM.disableDrag = function () {
        d && (e = c[d], c[d] =
            "none")
    };
    GeoGlobe.DOM.enableDrag = function () {
        d && (c[d] = e)
    };
    var f = a(["transform", "WebkitTransform"]);
    GeoGlobe.DOM.setTransform = function (a, b) {
        a.style[f] = b
    };
    GeoGlobe.DOM.suppressClick = function () {
        window.addEventListener("click", b, !0);
        window.setTimeout(function () {
            window.removeEventListener("click", b, !0)
        }, 0)
    };
    GeoGlobe.DOM.mousePos = function (a, b) {
        var c = a.getBoundingClientRect(), b = b.touches ? b.touches[0] : b;
        return new Point(b.clientX - c.left - a.clientLeft, b.clientY - c.top - a.clientTop)
    };
    GeoGlobe.DOM.touchPos = function (a,
                                      b) {
        for (var c = a.getBoundingClientRect(), d = [], e = b.type === "touchend" ? b.changedTouches : b.touches, f = 0; f < e.length; f++)d.push(new Point(e[f].clientX - c.left - a.clientLeft, e[f].clientY - c.top - a.clientTop));
        return d
    };
    GeoGlobe.DOM.remove = function (a) {
        a.parentNode && a.parentNode.removeChild(a)
    }
})();
GeoGlobe.Util = GeoGlobe.Util || {};
GeoGlobe.Util.getElement = function () {
    for (var a = [], b = 0, c = arguments.length; b < c; b++) {
        var d = arguments[b];
        typeof d == "string" && (d = document.getElementById(d));
        if (arguments.length == 1)return d;
        a.push(d)
    }
    return a
};
GeoGlobe.Util.isElement = function (a) {
    return !!(a && a.nodeType === 1)
};
GeoGlobe.Util.isArray = function (a) {
    return Object.prototype.toString.call(a) === "[object Array]"
};
GeoGlobe.Util.removeItem = function (a, b) {
    for (var c = a.length - 1; c >= 0; c--)a[c] == b && a.splice(c, 1);
    return a
};
GeoGlobe.Util.indexOf = function (a, b) {
    if (typeof a.indexOf == "function")return a.indexOf(b); else {
        for (var c = 0, d = a.length; c < d; c++)if (a[c] == b)return c;
        return -1
    }
};
GeoGlobe.Util.dotless = /\./g;
GeoGlobe.IMAGE_RELOAD_ATTEMPTS = 0;
GeoGlobe.Util.alphaHackNeeded = null;
GeoGlobe.Util.alphaHack = function () {
    if (GeoGlobe.Util.alphaHackNeeded == null) {
        var a = navigator.appVersion.split("MSIE"), a = parseFloat(a[1]), b = !1;
        try {
            b = !!document.body.filters
        } catch (c) {
        }
        GeoGlobe.Util.alphaHackNeeded = b && a >= 5.5 && a < 7
    }
    return GeoGlobe.Util.alphaHackNeeded
};
GeoGlobe.Util.upperCaseObject = function (a) {
    var b = {}, c;
    for (c in a)b[c.toUpperCase()] = a[c];
    return b
};
GeoGlobe.Util.applyDefaults = function (a, b) {
    var a = a || {}, c = typeof window.Event == "function" && b instanceof window.Event, d;
    for (d in b)if (a[d] === void 0 || !c && b.hasOwnProperty && b.hasOwnProperty(d) && !a.hasOwnProperty(d)) a[d] = b[d];
    if (!c && b && b.hasOwnProperty && b.hasOwnProperty("toString") && !a.hasOwnProperty("toString")) a.toString = b.toString;
    return a
};
GeoGlobe.Util.getParameterString = function (a) {
    var b = [], c;
    for (c in a) {
        var d = a[c];
        if (d != null && typeof d != "function") {
            if (typeof d == "object" && d.constructor == Array) {
                for (var e = [], f, g = 0, h = d.length; g < h; g++)f = d[g], e.push(encodeURIComponent(f === null || f === void 0 ? "" : f));
                d = e.join(",")
            } else d = encodeURIComponent(d);
            b.push(encodeURIComponent(c) + "=" + d)
        }
    }
    return b.join("&")
};
GeoGlobe.Util.urlAppend = function (a, b) {
    var c = a;
    if (b) {
        var d = (a + " ").split(/[?&]/);
        c += d.pop() === " " ? b : d.length ? "&" + b : "?" + b
    }
    return c
};
GeoGlobe.Util.getImagesLocation = function () {
    return GeoGlobe.ImgPath || GeoGlobe._getScriptLocation() + "img/"
};
GeoGlobe.Util.getImageLocation = function (a) {
    return GeoGlobe.Util.getImagesLocation() + a
};
GeoGlobe.Util.Try = function () {
    for (var a = null, b = 0, c = arguments.length; b < c; b++) {
        var d = arguments[b];
        try {
            a = d();
            break
        } catch (e) {
        }
    }
    return a
};
GeoGlobe.Util.getXmlNodeValue = function (a) {
    var b = null;
    GeoGlobe.Util.Try(function () {
        b = a.text;
        if (!b) b = a.textContent;
        if (!b) b = a.firstChild.nodeValue
    }, function () {
        b = a.textContent
    });
    return b
};
GeoGlobe.Util.mouseLeft = function (a, b) {
    for (var c = a.relatedTarget ? a.relatedTarget : a.toElement; c != b && c != null;)c = c.parentNode;
    return c != b
};
GeoGlobe.Util.DEFAULT_PRECISION = 14;
GeoGlobe.Util.toFloat = function (a, b) {
    if (b == null) b = GeoGlobe.Util.DEFAULT_PRECISION;
    typeof a !== "number" && (a = parseFloat(a));
    return b === 0 ? a : parseFloat(a.toPrecision(b))
};
GeoGlobe.Util.rad = function (a) {
    return a * Math.PI / 180
};
GeoGlobe.Util.deg = function (a) {
    return a * 180 / Math.PI
};
GeoGlobe.Util.VincentyConstants = {a: 6378137, b: 6356752.3142, f: 1 / 298.257223563};
GeoGlobe.Util.distVincenty = function (a, b) {
    for (var c = GeoGlobe.Util.VincentyConstants, d = c.a, e = c.b, c = c.f, f = GeoGlobe.Util.rad(b.lng - a.lng), g = Math.atan((1 - c) * Math.tan(GeoGlobe.Util.rad(a.lat))), h = Math.atan((1 - c) * Math.tan(GeoGlobe.Util.rad(b.lat))), j = Math.sin(g), g = Math.cos(g), l = Math.sin(h), h = Math.cos(h), m = f, n = 2 * Math.PI, p = 20; Math.abs(m - n) > 1.0E-12 && --p > 0;) {
        var q = Math.sin(m), o = Math.cos(m), s = Math.sqrt(h * q * h * q + (g * l - j * h * o) * (g * l - j * h * o));
        if (s == 0)return 0;
        var o = j * l + g * h * o, r = Math.atan2(s, o), t = Math.asin(g * h * q / s), u =
                Math.cos(t) * Math.cos(t), q = o - 2 * j * l / u, v = c / 16 * u * (4 + c * (4 - 3 * u)), n = m,
            m = f + (1 - v) * c * Math.sin(t) * (r + v * s * (q + v * o * (-1 + 2 * q * q)))
    }
    if (p == 0)return NaN;
    d = u * (d * d - e * e) / (e * e);
    c = d / 1024 * (256 + d * (-128 + d * (74 - 47 * d)));
    return (e * (1 + d / 16384 * (4096 + d * (-768 + d * (320 - 175 * d)))) * (r - c * s * (q + c / 4 * (o * (-1 + 2 * q * q) - c / 6 * q * (-3 + 4 * s * s) * (-3 + 4 * q * q))))).toFixed(3) / 1E3
};
GeoGlobe.Util.destinationVincenty = function (a, b, c) {
    for (var d = GeoGlobe.Util, e = d.VincentyConstants, f = e.a, g = e.b, e = e.f, h = a.lng, j = a.lat, a = d.rad(b), b = Math.sin(a), a = Math.cos(a), l = (1 - e) * Math.tan(d.rad(j)), j = 1 / Math.sqrt(1 + l * l), m = l * j, n = Math.atan2(l, a), l = j * b, p = 1 - l * l, f = p * (f * f - g * g) / (g * g), q = 1 + f / 16384 * (4096 + f * (-768 + f * (320 - 175 * f))), o = f / 1024 * (256 + f * (-128 + f * (74 - 47 * f))), f = c / (g * q), s = 2 * Math.PI; Math.abs(f - s) > 1.0E-12;)var r = Math.cos(2 * n + f), t = Math.sin(f), u = Math.cos(f), v = o * t * (r + o / 4 * (u * (-1 + 2 * r * r) - o / 6 * r * (-3 + 4 * t * t) * (-3 + 4 * r * r))),
        s = f, f = c / (g * q) + v;
    c = m * t - j * u * a;
    c = Math.atan2(m * u + j * t * a, (1 - e) * Math.sqrt(l * l + c * c));
    g = e / 16 * p * (4 + e * (4 - 3 * p));
    return new GeoGlobe.LngLat(h + d.deg(Math.atan2(t * b, j * u - m * t * a) - (1 - g) * e * l * (f + g * t * (r + g * u * (-1 + 2 * r * r)))), d.deg(c))
};
GeoGlobe.Util.getParameters = function (a, b) {
    var b = b || {}, a = a === null || a === void 0 ? window.location.href : a, c = "";
    if (GeoGlobe.String.contains(a, "?"))var d = a.indexOf("?") + 1,
        c = GeoGlobe.String.contains(a, "#") ? a.indexOf("#") : a.length, c = a.substring(d, c);
    for (var d = {}, c = c.split(/[&;]/), e = 0, f = c.length; e < f; ++e) {
        var g = c[e].split("=");
        if (g[0]) {
            var h = g[0];
            try {
                h = decodeURIComponent(h)
            } catch (j) {
                h = unescape(h)
            }
            g = (g[1] || "").replace(/\+/g, " ");
            try {
                g = decodeURIComponent(g)
            } catch (l) {
                g = unescape(g)
            }
            b.splitArgs !== !1 && (g = g.split(","));
            g.length == 1 && (g = g[0]);
            d[h] = g
        }
    }
    return d
};
GeoGlobe.Util.lastSeqID = 0;
GeoGlobe.Util.createUniqueID = function (a) {
    a = a == null ? "id_" : a.replace(GeoGlobe.Util.dotless, "_");
    GeoGlobe.Util.lastSeqID += 1;
    return a + GeoGlobe.Util.lastSeqID
};
GeoGlobe.INCHES_PER_UNIT = {inches: 1, ft: 12, mi: 63360, m: 1 / 0.0254, km: 39370, dd: 4374754, yd: 36};
GeoGlobe.INCHES_PER_UNIT["in"] = GeoGlobe.INCHES_PER_UNIT.inches;
GeoGlobe.INCHES_PER_UNIT.degrees = GeoGlobe.INCHES_PER_UNIT.dd;
GeoGlobe.INCHES_PER_UNIT.nmi = 1852 * GeoGlobe.INCHES_PER_UNIT.m;
GeoGlobe.METERS_PER_INCH = 0.0254000508001016;
GeoGlobe.Util.extend(GeoGlobe.INCHES_PER_UNIT, {
    Inch: GeoGlobe.INCHES_PER_UNIT.inches,
    Meter: 1 / GeoGlobe.METERS_PER_INCH,
    Foot: 0.3048006096012192 / GeoGlobe.METERS_PER_INCH,
    IFoot: 0.3048 / GeoGlobe.METERS_PER_INCH,
    ClarkeFoot: 0.3047972651151 / GeoGlobe.METERS_PER_INCH,
    SearsFoot: 0.30479947153867626 / GeoGlobe.METERS_PER_INCH,
    GoldCoastFoot: 0.3047997101815088 / GeoGlobe.METERS_PER_INCH,
    IInch: 0.0254 / GeoGlobe.METERS_PER_INCH,
    MicroInch: 2.54E-5 / GeoGlobe.METERS_PER_INCH,
    Mil: 2.54E-8 / GeoGlobe.METERS_PER_INCH,
    Centimeter: 0.01 /
    GeoGlobe.METERS_PER_INCH,
    Kilometer: 1E3 / GeoGlobe.METERS_PER_INCH,
    Yard: 0.9144018288036576 / GeoGlobe.METERS_PER_INCH,
    SearsYard: 0.914398414616029 / GeoGlobe.METERS_PER_INCH,
    IndianYard: 0.9143985307444408 / GeoGlobe.METERS_PER_INCH,
    IndianYd37: 0.91439523 / GeoGlobe.METERS_PER_INCH,
    IndianYd62: 0.9143988 / GeoGlobe.METERS_PER_INCH,
    IndianYd75: 0.9143985 / GeoGlobe.METERS_PER_INCH,
    IndianFoot: 0.30479951 / GeoGlobe.METERS_PER_INCH,
    IndianFt37: 0.30479841 / GeoGlobe.METERS_PER_INCH,
    IndianFt62: 0.3047996 / GeoGlobe.METERS_PER_INCH,
    IndianFt75: 0.3047995 /
    GeoGlobe.METERS_PER_INCH,
    Mile: 1609.3472186944373 / GeoGlobe.METERS_PER_INCH,
    IYard: 0.9144 / GeoGlobe.METERS_PER_INCH,
    IMile: 1609.344 / GeoGlobe.METERS_PER_INCH,
    NautM: 1852 / GeoGlobe.METERS_PER_INCH,
    "Lat-66": 110943.31648893273 / GeoGlobe.METERS_PER_INCH,
    "Lat-83": 110946.25736872235 / GeoGlobe.METERS_PER_INCH,
    Decimeter: 0.1 / GeoGlobe.METERS_PER_INCH,
    Millimeter: 0.0010 / GeoGlobe.METERS_PER_INCH,
    Dekameter: 10 / GeoGlobe.METERS_PER_INCH,
    Decameter: 10 / GeoGlobe.METERS_PER_INCH,
    Hectometer: 100 / GeoGlobe.METERS_PER_INCH,
    GermanMeter: 1.0000135965 /
    GeoGlobe.METERS_PER_INCH,
    CaGrid: 0.999738 / GeoGlobe.METERS_PER_INCH,
    ClarkeChain: 20.1166194976 / GeoGlobe.METERS_PER_INCH,
    GunterChain: 20.11684023368047 / GeoGlobe.METERS_PER_INCH,
    BenoitChain: 20.116782494375872 / GeoGlobe.METERS_PER_INCH,
    SearsChain: 20.11676512155 / GeoGlobe.METERS_PER_INCH,
    ClarkeLink: 0.201166194976 / GeoGlobe.METERS_PER_INCH,
    GunterLink: 0.2011684023368047 / GeoGlobe.METERS_PER_INCH,
    BenoitLink: 0.20116782494375873 / GeoGlobe.METERS_PER_INCH,
    SearsLink: 0.2011676512155 / GeoGlobe.METERS_PER_INCH,
    Rod: 5.02921005842012 /
    GeoGlobe.METERS_PER_INCH,
    IntnlChain: 20.1168 / GeoGlobe.METERS_PER_INCH,
    IntnlLink: 0.201168 / GeoGlobe.METERS_PER_INCH,
    Perch: 5.02921005842012 / GeoGlobe.METERS_PER_INCH,
    Pole: 5.02921005842012 / GeoGlobe.METERS_PER_INCH,
    Furlong: 201.1684023368046 / GeoGlobe.METERS_PER_INCH,
    Rood: 3.778266898 / GeoGlobe.METERS_PER_INCH,
    CapeFoot: 0.3047972615 / GeoGlobe.METERS_PER_INCH,
    Brealey: 375 / GeoGlobe.METERS_PER_INCH,
    ModAmFt: 0.304812252984506 / GeoGlobe.METERS_PER_INCH,
    Fathom: 1.8288 / GeoGlobe.METERS_PER_INCH,
    "NautM-UK": 1853.184 / GeoGlobe.METERS_PER_INCH,
    "50kilometers": 5E4 / GeoGlobe.METERS_PER_INCH,
    "150kilometers": 15E4 / GeoGlobe.METERS_PER_INCH
});
GeoGlobe.Util.extend(GeoGlobe.INCHES_PER_UNIT, {
    mm: GeoGlobe.INCHES_PER_UNIT.Meter / 1E3,
    cm: GeoGlobe.INCHES_PER_UNIT.Meter / 100,
    dm: GeoGlobe.INCHES_PER_UNIT.Meter * 100,
    km: GeoGlobe.INCHES_PER_UNIT.Meter * 1E3,
    kmi: GeoGlobe.INCHES_PER_UNIT.nmi,
    fath: GeoGlobe.INCHES_PER_UNIT.Fathom,
    ch: GeoGlobe.INCHES_PER_UNIT.IntnlChain,
    link: GeoGlobe.INCHES_PER_UNIT.IntnlLink,
    "us-in": GeoGlobe.INCHES_PER_UNIT.inches,
    "us-ft": GeoGlobe.INCHES_PER_UNIT.Foot,
    "us-yd": GeoGlobe.INCHES_PER_UNIT.Yard,
    "us-ch": GeoGlobe.INCHES_PER_UNIT.GunterChain,
    "us-mi": GeoGlobe.INCHES_PER_UNIT.Mile,
    "ind-yd": GeoGlobe.INCHES_PER_UNIT.IndianYd37,
    "ind-ft": GeoGlobe.INCHES_PER_UNIT.IndianFt37,
    "ind-ch": 20.11669506 / GeoGlobe.METERS_PER_INCH
});
GeoGlobe.DOTS_PER_INCH = 96;
GeoGlobe.Util.normalizeScale = function (a) {
    return a > 1 ? 1 / a : a
};
GeoGlobe.Util.getResolutionFromScale = function (a, b) {
    var c;
    a && (b == null && (b = "degrees"), c = 1 / (GeoGlobe.Util.normalizeScale(a) * GeoGlobe.INCHES_PER_UNIT[b] * GeoGlobe.DOTS_PER_INCH));
    return c
};
GeoGlobe.Util.getScaleFromResolution = function (a, b) {
    b == null && (b = "degrees");
    return a * GeoGlobe.INCHES_PER_UNIT[b] * GeoGlobe.DOTS_PER_INCH
};
GeoGlobe.Util.pagePosition = function (a) {
    var b = [0, 0], c = GeoGlobe.Util.getViewportElement();
    if (!a || a == window || a == c)return b;
    var d = GeoGlobe.IS_GECKO && document.getBoxObjectFor && GeoGlobe.Element.getStyle(a, "position") == "absolute" && (a.style.top == "" || a.style.left == ""),
        e = null;
    if (a.getBoundingClientRect) a = a.getBoundingClientRect(), e = window.pageYOffset || c.scrollTop, b[0] = a.left + (window.pageXOffset || c.scrollLeft), b[1] = a.top + e; else if (document.getBoxObjectFor && !d) a = document.getBoxObjectFor(a), c = document.getBoxObjectFor(c),
        b[0] = a.screenX - c.screenX, b[1] = a.screenY - c.screenY; else {
        b[0] = a.offsetLeft;
        b[1] = a.offsetTop;
        e = a.offsetParent;
        if (e != a)for (; e;)b[0] += e.offsetLeft, b[1] += e.offsetTop, e = e.offsetParent;
        c = GeoGlobe.BROWSER_NAME;
        if (c == "opera" || c == "safari" && GeoGlobe.Element.getStyle(a, "position") == "absolute") b[1] -= document.body.offsetTop;
        for (e = a.offsetParent; e && e != document.body;) {
            b[0] -= e.scrollLeft;
            if (c != "opera" || e.tagName != "TR") b[1] -= e.scrollTop;
            e = e.offsetParent
        }
    }
    return b
};
GeoGlobe.Util.getViewportElement = function () {
    var a = arguments.callee.viewportElement;
    if (a == void 0) a = GeoGlobe.BROWSER_NAME == "msie" && document.compatMode != "CSS1Compat" ? document.body : document.documentElement, arguments.callee.viewportElement = a;
    return a
};
GeoGlobe.Util.isEquivalentUrl = function (a, b, c) {
    c = c || {};
    GeoGlobe.Util.applyDefaults(c, {ignoreCase: !0, ignorePort80: !0, ignoreHash: !0, splitArgs: !1});
    var a = GeoGlobe.Util.createUrlObject(a, c), b = GeoGlobe.Util.createUrlObject(b, c), d;
    for (d in a)if (d !== "args" && a[d] != b[d])return !1;
    for (d in a.args) {
        if (a.args[d] != b.args[d])return !1;
        delete b.args[d]
    }
    for (d in b.args)return !1;
    return !0
};
GeoGlobe.Util.createUrlObject = function (a, b) {
    b = b || {};
    if (!/^\w+:\/\//.test(a)) {
        var c = window.location, d = c.port ? ":" + c.port : "", d = c.protocol + "//" + c.host.split(":").shift() + d;
        a.indexOf("/") === 0 ? a = d + a : (c = c.pathname.split("/"), c.pop(), a = d + c.join("/") + "/" + a)
    }
    b.ignoreCase && (a = a.toLowerCase());
    c = document.createElement("a");
    c.href = a;
    d = {};
    d.host = c.host.split(":").shift();
    d.protocol = c.protocol;
    d.port = b.ignorePort80 ? c.port == "80" || c.port == "0" ? "" : c.port : c.port == "" || c.port == "0" ? "80" : c.port;
    d.hash = b.ignoreHash || c.hash ===
    "#" ? "" : c.hash;
    var e = c.search;
    e || (e = a.indexOf("?"), e = e != -1 ? a.substr(e) : "");
    d.args = GeoGlobe.Util.getParameters(e, {splitArgs: b.splitArgs});
    d.pathname = c.pathname.charAt(0) == "/" ? c.pathname : "/" + c.pathname;
    return d
};
GeoGlobe.Util.removeTail = function (a) {
    var b = null, b = a.indexOf("?"), c = a.indexOf("#");
    return b = b == -1 ? c != -1 ? a.substr(0, c) : a : c != -1 ? a.substr(0, Math.min(b, c)) : a.substr(0, b)
};
GeoGlobe.IS_GECKO = function () {
    var a = navigator.userAgent.toLowerCase();
    return a.indexOf("webkit") == -1 && a.indexOf("gecko") != -1
}();
GeoGlobe.CANVAS_SUPPORTED = function () {
    var a = document.createElement("canvas");
    return !(!a.getContext || !a.getContext("2d"))
}();
GeoGlobe.BROWSER_NAME = function () {
    var a = "", b = navigator.userAgent.toLowerCase();
    b.indexOf("opera") != -1 ? a = "opera" : b.indexOf("msie") != -1 ? a = "msie" : b.indexOf("safari") != -1 ? a = "safari" : b.indexOf("mozilla") != -1 && (a = b.indexOf("firefox") != -1 ? "firefox" : "mozilla");
    return a
}();
GeoGlobe.Util.getBrowserName = function () {
    return GeoGlobe.BROWSER_NAME
};
GeoGlobe.Util.getRenderedDimensions = function (a, b, c) {
    var d, e, f = document.createElement("div");
    f.style.visibility = "hidden";
    for (var g = c && c.containerElement ? c.containerElement : document.body, h = !1, j = null, l = g; l && l.tagName.toLowerCase() != "body";) {
        var m = GeoGlobe.Element.getStyle(l, "position");
        if (m == "absolute") {
            h = !0;
            break
        } else if (m && m != "static")break;
        l = l.parentNode
    }
    if (h && (g.clientHeight === 0 || g.clientWidth === 0)) j = document.createElement("div"), j.style.visibility = "hidden", j.style.position = "absolute", j.style.overflow =
        "visible", j.style.width = document.body.clientWidth + "px", j.style.height = document.body.clientHeight + "px", j.appendChild(f);
    f.style.position = "absolute";
    if (b)if (b.w) d = b.w, f.style.width = d + "px"; else if (b.h) e = b.h, f.style.height = e + "px";
    if (c && c.displayClass) f.className = c.displayClass;
    b = document.createElement("div");
    b.innerHTML = a;
    b.style.overflow = "visible";
    if (b.childNodes) {
        a = 0;
        for (c = b.childNodes.length; a < c; a++)if (b.childNodes[a].style) b.childNodes[a].style.overflow = "visible"
    }
    f.appendChild(b);
    j ? g.appendChild(j) :
        g.appendChild(f);
    if (!d) d = parseInt(b.scrollWidth), f.style.width = d + "px";
    e || (e = parseInt(b.scrollHeight));
    f.removeChild(b);
    j ? (j.removeChild(f), g.removeChild(j)) : g.removeChild(f);
    return new GeoGlobe.Size(d, e)
};
GeoGlobe.Util.getScrollbarWidth = function () {
    var a = GeoGlobe.Util._scrollbarWidth;
    if (a == null) {
        var b = null, c = null, b = a = 0, b = document.createElement("div");
        b.style.position = "absolute";
        b.style.top = "-1000px";
        b.style.left = "-1000px";
        b.style.width = "100px";
        b.style.height = "50px";
        b.style.overflow = "hidden";
        c = document.createElement("div");
        c.style.width = "100%";
        c.style.height = "200px";
        b.appendChild(c);
        document.body.appendChild(b);
        a = c.offsetWidth;
        b.style.overflow = "scroll";
        b = c.offsetWidth;
        document.body.removeChild(document.body.lastChild);
        GeoGlobe.Util._scrollbarWidth = a - b;
        a = GeoGlobe.Util._scrollbarWidth
    }
    return a
};
GeoGlobe.Util.randomStr = function (a) {
    for (var b = "", c = [], d = 0; d < a; d++)c.push(String.fromCharCode(97 + Math.ceil(Math.random() * 25)));
    for (d = 0; d < a; d++)b += c[d];
    return b
};
GeoGlobe.Util.globalEval = function (a) {
    a && GeoGlobe.String.trim(a) && (window.execScript || function (a) {
        window.eval.call(window, a)
    })(a)
};
GeoGlobe.Util.getResolutionFromScale_DPI = function (a, b, c) {
    var d;
    a && (b == null && (b = "degrees"), d = 1 / (GeoGlobe.Util.normalizeScale(a) * GeoGlobe.INCHES_PER_UNIT[b] * c));
    return d
};
GeoGlobe.Util.getScaleFromResolution_DPI = function (a, b, c) {
    b == null && (b = "degrees");
    return a * GeoGlobe.INCHES_PER_UNIT[b] * c
};
GeoGlobe.Util.getMapLevelFormResolution = function (a, b) {
    if (!b)return 0;
    var c, d, e = Number.POSITIVE_INFINITY, f = a.getResolutions();
    c = 0;
    for (len = f.length; c < len; c++) {
        d = Math.abs(f[c] - b);
        if (d > e)break;
        e = d
    }
    return Math.max(0, c - 1)
};
GeoGlobe.Util.getMapLevelFormScale = function (a, b, c, d) {
    b = GeoGlobe.Util.getResolutionFromScale_DPI(b, c ? c : "degrees", d ? d : 96);
    return GeoGlobe.Util.getMapLevelFormResolution(a, b)
};
GeoGlobe.Util.delayFun = function (a, b, c) {
    var d;
    return function () {
        var e = this, f = arguments, g = c && !d;
        clearTimeout(d);
        d = setTimeout(function () {
            d = null;
            c || a.apply(e, f)
        }, b);
        g && a.apply(e, f)
    }
};
(function (a) {
    typeof exports === "object" && typeof module !== "undefined" ? module.exports = a() : typeof define === "function" && define.amd ? define([], a) : (typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : this).proj4cn = a()
})(function () {
    return function b(c, d, e) {
        function f(h, l) {
            if (!d[h]) {
                if (!c[h]) {
                    var m = typeof require == "function" && require;
                    if (!l && m)return m(h, !0);
                    if (g)return g(h, !0);
                    m = Error("Cannot find module '" + h + "'");
                    throw m.code = "MODULE_NOT_FOUND", m;
                }
                m = d[h] = {exports: {}};
                c[h][0].call(m.exports, function (b) {
                    var d = c[h][1][b];
                    return f(d ? d : b)
                }, m, m.exports, b, c, d, e)
            }
            return d[h].exports
        }

        for (var g = typeof require == "function" && require, h = 0; h < e.length; h++)f(e[h]);
        return f
    }({
        1: [function (b, c, d) {
            var c = b("../util").forEachPoint, e = b("./gcj-02"), f = Math.PI * 3E3 / 180,
                g = d.toGCJ02 = c(function (b, c, d) {
                    var e = b[d] - 0.0065, g = b[d + 1] - 0.0060,
                        b = Math.sqrt(e * e + g * g) - 2.0E-5 * Math.sin(g * f),
                        e = Math.atan2(g, e) - 3.0E-6 * Math.cos(e * f);
                    c[d] = b * Math.cos(e);
                    c[d + 1] = b * Math.sin(e);
                    return c
                }), h = d.fromGCJ02 = c(function (b,
                                                  c, d) {
                    var e = b[d], g = b[d + 1], b = Math.sqrt(e * e + g * g) + 2.0E-5 * Math.sin(g * f),
                        e = Math.atan2(g, e) + 3.0E-6 * Math.cos(e * f);
                    c[d] = b * Math.cos(e) + 0.0065;
                    c[d + 1] = b * Math.sin(e) + 0.0060;
                    return c
                });
            d.toWGS84 = function (b, c, d) {
                b = g(b, c, d);
                return e.toWGS84(b, b, d)
            };
            d.fromWGS84 = function (b, c, d) {
                b = e.fromWGS84(b, c, d);
                return h(b, b, d)
            }
        }, {"../util": 8, "./gcj-02": 2}], 2: [function (b, c, d) {
            function e(b, c) {
                var d, e = b - 105, f = c - 35;
                d = -100 + 2 * e + 3 * f + 0.2 * f * f + 0.1 * e * f + 0.2 * Math.sqrt(Math.abs(e));
                d += (20 * Math.sin(6 * e * g) + 20 * Math.sin(2 * e * g)) * 2 / 3;
                d += (20 * Math.sin(f *
                        g) + 40 * Math.sin(f / 3 * g)) * 2 / 3;
                d += (160 * Math.sin(f / 12 * g) + 320 * Math.sin(f * g / 30)) * 2 / 3;
                f = b - 105;
                e = c - 35;
                e = 300 + f + 2 * e + 0.1 * f * f + 0.1 * f * e + 0.1 * Math.sqrt(Math.abs(f));
                e += (20 * Math.sin(6 * f * g) + 20 * Math.sin(2 * f * g)) * 2 / 3;
                e += (20 * Math.sin(f * g) + 40 * Math.sin(f / 3 * g)) * 2 / 3;
                e += (150 * Math.sin(f / 12 * g) + 300 * Math.sin(f / 30 * g)) * 2 / 3;
                var f = c / 180 * g, o = Math.sin(f), o = 1 - j * o * o, s = Math.sqrt(o);
                d = d * 180 / (h * (1 - j) / (o * s) * g);
                e = e * 180 / (h / s * Math.cos(f) * g);
                return [e, d]
            }

            function f(b, c) {
                if (b < 72.004 || b > 137.8347)return !0;
                if (c < 0.8293 || c > 55.8271)return !0;
                return !1
            }

            var b =
                b("../util").forEachPoint, g = Math.PI, h = 6378245, j = 0.006693421622965943;
            d.toWGS84 = b(function (b, c, d) {
                var g = b[d], b = b[d + 1];
                if (!f(g, b)) {
                    var h = e(g, b);
                    g -= h[0];
                    b -= h[1]
                }
                c[d] = g;
                c[d + 1] = b
            });
            d.fromWGS84 = b(function (b, c, d) {
                var g = b[d], b = b[d + 1];
                if (!f(g, b)) {
                    var h = e(g, b);
                    g += h[0];
                    b += h[1]
                }
                c[d] = g;
                c[d + 1] = b
            })
        }, {"../util": 8}], 3: [function (b, c, d) {
            d.bd09 = b("./bd-09");
            d.gcj02 = b("./gcj-02")
        }, {"./bd-09": 1, "./gcj-02": 2}], 4: [function (b, c, d) {
            var e = b("./projection/index"), f = b("./datum/index");
            d.smerc2bmerc = function (b, c, d) {
                b = e.sphericalMercator.inverse(b,
                    c, d);
                b = f.bd09.fromWGS84(b, b, d);
                return e.baiduMercator.forward(b, b, d)
            };
            d.bmerc2smerc = function (b, c, d) {
                b = e.baiduMercator.inverse(b, c, d);
                b = f.bd09.toWGS84(b, b, d);
                return e.sphericalMercator.forward(b, b, d)
            };
            d.bmerc2ll = function (b, c, d) {
                b = e.baiduMercator.inverse(b, c, d);
                return f.bd09.toWGS84(b, b, d)
            };
            d.ll2bmerc = function (b, c, d) {
                b = f.bd09.fromWGS84(b, c, d);
                return e.baiduMercator.forward(b, b, d)
            };
            d.ll2smerc = e.sphericalMercator.forward;
            d.smerc2ll = e.sphericalMercator.inverse;
            d.datum = f;
            d.projection = e;
            d.gcj02towgs84 = function (b,
                                       c, d) {
                return f.gcj02.toWGS84(b, c, d)
            };
            d.wgs84togcj02 = function (b, c, d) {
                return f.gcj02.fromWGS84(b, c, d)
            }
        }, {"./datum/index": 3, "./projection/index": 6}], 5: [function (b, c, d) {
            function e(b, c, d, e) {
                var f = b[d], b = b[d + 1], g = Math.abs(b) / e[9],
                    g = e[2] + e[3] * g + e[4] * g * g + e[5] * g * g * g + e[6] * g * g * g * g + e[7] * g * g * g * g * g + e[8] * g * g * g * g * g * g;
                c[d] = (e[0] + e[1] * Math.abs(f)) * (f < 0 ? -1 : 1);
                c[d + 1] = g * (b < 0 ? -1 : 1)
            }

            var b = b("../util").forEachPoint, f = [1.289059486E7, 8362377.87, 5591021, 3481989.83, 1678043.12, 0],
                g = [75, 60, 45, 30, 15, 0], h = [[1.410526172116255E-8,
                    8.98305509648872E-6, -1.9939833816331, 200.9824383106796, -187.2403703815547, 91.6087516669843, -23.38765649603339, 2.57121317296198, -0.03801003308653, 1.73379812E7], [-7.435856389565537E-9, 8.983055097726239E-6, -0.78625201886289, 96.32687599759846, -1.85204757529826, -59.36935905485877, 47.40033549296737, -16.50741931063887, 2.28786674699375, 1.026014486E7], [-3.030883460898826E-8, 8.98305509983578E-6, 0.30071316287616, 59.74293618442277, 7.357984074871, -25.38371002664745, 13.45380521110908, -3.29883767235584, 0.32710905363475,
                    6856817.37], [-1.981981304930552E-8, 8.983055099779535E-6, 0.03278182852591, 40.31678527705744, 0.65659298677277, -4.44255534477492, 0.85341911805263, 0.12923347998204, -0.04625736007561, 4482777.06], [3.09191371068437E-9, 8.983055096812155E-6, 6.995724062E-5, 23.10934304144901, -2.3663490511E-4, -0.6321817810242, -0.00663494467273, 0.03430082397953, -0.00466043876332, 2555164.4], [2.890871144776878E-9, 8.983055095805407E-6, -3.068298E-8, 7.47137025468032, -3.53937994E-6, -0.02145144861037, -1.234426596E-5, 1.0322952773E-4,
                    -3.23890364E-6, 826088.5]],
                j = [[-0.0015702102444, 111320.7020616939, 1704480524535203, -10338987376042340, 26112667856603880, -35149669176653700, 26595700718403920, -10725012454188240, 1800819912950474, 82.5], [8.277824516172526E-4, 111320.7020463578, 6.477955746671607E8, -4.082003173641316E9, 1.077490566351142E10, -1.517187553151559E10, 1.205306533862167E10, -5.124939663577472E9, 9.133119359512032E8, 67.5], [0.00337398766765, 111320.7020202162, 4481351.045890365, -2.339375119931662E7, 7.968221547186455E7, -1.159649932797253E8,
                    9.723671115602145E7, -4.366194633752821E7, 8477230.501135234, 52.5], [0.00220636496208, 111320.7020209128, 51751.86112841131, 3796837.749470245, 992013.7397791013, -1221952.21711287, 1340652.697009075, -620943.6990984312, 144416.9293806241, 37.5], [-3.441963504368392E-4, 111320.7020576856, 278.2353980772752, 2485758.690035394, 6070.750963243378, 54821.18345352118, 9540.606633304236, -2710.55326746645, 1405.483844121726, 22.5], [-3.218135878613132E-4, 111320.7020701615, 0.00369383431289, 823725.6402795718, 0.46104986909093, 2351.343141331292,
                    1.58060784298199, 8.77738589078284, 0.37238884252424, 7.45]];
            d.forward = b(function (b, c, d) {
                for (var f = b[d]; f > 180;)f -= 360;
                for (; f < -180;)f += 360;
                var b = b[d + 1], b = Math.max(b, -74), b = Math.min(b, 74), h = null, o;
                for (o = 0; o < g.length; ++o)if (b >= g[o]) {
                    h = j[o];
                    break
                }
                if (h === null)for (o = g.length - 1; o >= 0; --o)if (b <= -g[o]) {
                    h = j[o];
                    break
                }
                c[d] = f;
                c[d + 1] = b;
                e(c, c, d, h)
            });
            d.inverse = b(function (b, c, d) {
                for (var g = Math.abs(b[d + 1]), j = null, o = 0; o < f.length; o++)if (g >= f[o]) {
                    j = h[o];
                    break
                }
                e(b, c, d, j)
            })
        }, {"../util": 8}], 6: [function (b, c, d) {
            d.baiduMercator =
                b("./baidu-mercator");
            d.sphericalMercator = b("./spherical-mercator")
        }, {"./baidu-mercator": 5, "./spherical-mercator": 7}], 7: [function (b, c, d) {
            var b = b("../util").forEachPoint, e = Math.PI / 180;
            d.forward = b(function (b, c, d) {
                var j = Math.sin(Math.max(Math.min(85.0511287798, b[d + 1]), -85.0511287798) * e);
                c[d] = 6378137 * b[d] * e;
                c[d + 1] = 6378137 * Math.log((1 + j) / (1 - j)) / 2
            });
            d.inverse = b(function (b, c, d) {
                c[d] = b[d] / 6378137 / e;
                c[d + 1] = (2 * Math.atan(Math.exp(b[d + 1] / 6378137)) - Math.PI / 2) / e
            })
        }, {"../util": 8}], 8: [function (b, c, d) {
            d.forEachPoint =
                function (b) {
                    return function (c, d, h) {
                        for (var j = c.length, h = h ? h : 2, d = d ? d : h !== 2 ? c.slice() : Array(j), l = 0; l < j; l += h)b(c, d, l);
                        return d
                    }
                }
        }, {}]
    }, {}, [4])(4)
});
if (GeoGlobe) GeoGlobe.Proj4cn = proj4cn;
GeoGlobe.ProjAxisOrder = {AXIS_ORDER_EN: !0, AXIS_ORDER_NE: !1};
GeoGlobe.ProjAxisOrder.AxisOrder = {
    "EPSG:900913": GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
    WGS84: GeoGlobe.ProjAxisOrder.AXIS_ORDER_NE,
    "IGNF:WGS84G": GeoGlobe.ProjAxisOrder.AXIS_ORDER_NE,
    "EPSG:4326": GeoGlobe.ProjAxisOrder.AXIS_ORDER_NE,
    "EPSG:4490": GeoGlobe.ProjAxisOrder.AXIS_ORDER_NE,
    "EPSG:4269": GeoGlobe.ProjAxisOrder.AXIS_ORDER_NE,
    "EPSG:2361": GeoGlobe.ProjAxisOrder.AXIS_ORDER_NE,
    "EPSG:27700": GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
    "EPSG:904490": GeoGlobe.ProjAxisOrder.AXIS_ORDER_NE,
    "EPSG:4171": GeoGlobe.ProjAxisOrder.AXIS_ORDER_NE,
    "EPSG:32637": GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
    "EPSG:32638": GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
    "EPSG:32639": GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
    "EPSG:32640": GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
    "EPSG:32641": GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
    "EPSG:28991": GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
    "EPSG:28992": GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
    "EPSG:31300": GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
    "EPSG:31370": GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
    "EPSG:2176": GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
    "EPSG:2177": GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
    "EPSG:2178": GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
    "EPSG:2179": GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
    "EPSG:2180": GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
    "EPSG:2154": GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
    "EPSG:3346": GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
    "EPSG:3857": GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN,
    "EPSG:2065": GeoGlobe.ProjAxisOrder.AXIS_ORDER_EN
};
GeoGlobe.SpatialReference = GeoGlobe.Class({
    proj: null, projCode: null, titleRegEx: /\+title=[^\+]*/, initialize: function (a, b) {
        GeoGlobe.Util.extend(this, b);
        this.projCode = a;
        if (typeof Proj4js == "object") this.proj = new Proj4js.Proj(a)
    }, getCode: function () {
        return this.proj ? this.proj.srsCode : this.projCode
    }, getUnits: function () {
        return this.proj ? this.proj.units : null
    }, toString: function () {
        return this.getCode()
    }, equals: function (a) {
        var b = !1;
        a && (a instanceof GeoGlobe.SpatialReference || (a = new GeoGlobe.SpatialReference(a)),
            typeof Proj4js == "object" && this.proj.defData && a.proj.defData ? b = this.proj.defData.replace(this.titleRegEx, "") == a.proj.defData.replace(this.titleRegEx, "") : a.getCode && (b = this.getCode(), a = a.getCode(), b = b == a || !!GeoGlobe.SpatialReference.transforms[b] && GeoGlobe.SpatialReference.transforms[b][a] === GeoGlobe.SpatialReference.nullTransform));
        return b
    }, destroy: function () {
        delete this.proj;
        delete this.projCode
    }, CLASS_NAME: "GeoGlobe.SpatialReference"
});
GeoGlobe.SpatialReference.transforms = {};
GeoGlobe.SpatialReference.defaults = {
    "EPSG:4326": {units: "degrees", maxExtent: [-180, -90, 180, 90], yx: !0},
    "CRS:84": {units: "degrees", maxExtent: [-180, -90, 180, 90]},
    "EPSG:900913": {units: "m", maxExtent: [-2.003750834E7, -2.003750834E7, 2.003750834E7, 2.003750834E7]}
};
GeoGlobe.SpatialReference.addTransform = function (a, b, c) {
    if (c === GeoGlobe.SpatialReference.nullTransform) {
        var d = GeoGlobe.SpatialReference.defaults[a];
        d && !GeoGlobe.SpatialReference.defaults[b] && (GeoGlobe.SpatialReference.defaults[b] = d)
    }
    GeoGlobe.SpatialReference.transforms[a] || (GeoGlobe.SpatialReference.transforms[a] = {});
    GeoGlobe.SpatialReference.transforms[a][b] = c
};
GeoGlobe.SpatialReference.transform = function (a, b, c) {
    if (b && c)if (b instanceof GeoGlobe.SpatialReference || (b = new GeoGlobe.SpatialReference(b)), c instanceof GeoGlobe.SpatialReference || (c = new GeoGlobe.SpatialReference(c)), b.proj && c.proj) a = Proj4js.transform(b.proj, c.proj, a); else {
        var b = b.getCode(), c = c.getCode(), d = GeoGlobe.SpatialReference.transforms;
        if (d[b] && d[b][c]) d[b][c](a)
    }
    return a
};
GeoGlobe.SpatialReference.nullTransform = function (a) {
    return a
};
(function () {
    function a(a) {
        a.x = 180 * a.x / d;
        a.y = 180 / Math.PI * (2 * Math.atan(Math.exp(a.y / d * Math.PI)) - Math.PI / 2);
        return a
    }

    function b(a) {
        a.x = a.x * d / 180;
        a.y = Math.max(-2.003750834E7, Math.min(Math.log(Math.tan((90 + a.y) * Math.PI / 360)) / Math.PI * d, 2.003750834E7));
        return a
    }

    function c(c, d) {
        var e = GeoGlobe.SpatialReference.addTransform, f = GeoGlobe.SpatialReference.nullTransform, g, p, q, o, s;
        g = 0;
        for (p = d.length; g < p; ++g) {
            q = d[g];
            e(c, q, b);
            e(q, c, a);
            for (s = g + 1; s < p; ++s)o = d[s], e(q, o, f), e(o, q, f)
        }
    }

    var d = 2.003750834E7, e = ["EPSG:900913",
        "EPSG:3857", "EPSG:102113", "EPSG:102100"], f = ["CRS:84", "urn:ogc:def:crs:EPSG:6.6:4326", "EPSG:4326"], g;
    for (g = e.length - 1; g >= 0; --g)c(e[g], f);
    for (g = f.length - 1; g >= 0; --g)c(f[g], e)
})();
GeoGlobe.String = {
    startsWith: function (a, b) {
        return a.indexOf(b) == 0
    },
    contains: function (a, b) {
        return a.indexOf(b) != -1
    },
    trim: function (a) {
        return a.replace(/^\s\s*/, "").replace(/\s\s*$/, "")
    },
    camelize: function (a) {
        for (var a = a.split("-"), b = a[0], c = 1, d = a.length; c < d; c++) {
            var e = a[c];
            b += e.charAt(0).toUpperCase() + e.substring(1)
        }
        return b
    },
    format: function (a, b, c) {
        b || (b = window);
        return a.replace(GeoGlobe.String.tokenRegEx, function (a, e) {
            for (var f, g = e.split(/\.+/), h = 0; h < g.length; h++) {
                h == 0 && (f = b);
                if (f === void 0)break;
                f = f[g[h]]
            }
            typeof f ==
            "function" && (f = c ? f.apply(null, c) : f());
            return typeof f == "undefined" ? "undefined" : f
        })
    },
    tokenRegEx: /\$\{([\w.]+?)\}/g,
    numberRegEx: /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/,
    isNumeric: function (a) {
        return GeoGlobe.String.numberRegEx.test(a)
    },
    numericIf: function (a, b) {
        var c = a;
        b === !0 && a != null && a.replace && (a = a.replace(/^\s*|\s*$/g, ""));
        return GeoGlobe.String.isNumeric(a) ? parseFloat(a) : c
    }
};
GeoGlobe.Number = {
    decimalSeparator: ".", thousandsSeparator: ",", limitSigDigs: function (a, b) {
        var c = 0;
        b > 0 && (c = parseFloat(a.toPrecision(b)));
        return c
    }, format: function (a, b, c, d) {
        b = typeof b != "undefined" ? b : 0;
        c = typeof c != "undefined" ? c : GeoGlobe.Number.thousandsSeparator;
        d = typeof d != "undefined" ? d : GeoGlobe.Number.decimalSeparator;
        b != null && (a = parseFloat(a.toFixed(b)));
        var e = a.toString().split(".");
        e.length == 1 && b == null && (b = 0);
        a = e[0];
        if (c)for (var f = /(-?[0-9]+)([0-9]{3})/; f.test(a);)a = a.replace(f, "$1" + c + "$2");
        b == 0 ?
            b = a : (c = e.length > 1 ? e[1] : "0", b != null && (c += Array(b - c.length + 1).join("0")), b = a + d + c);
        return b
    }, zeroPad: function (a, b, c) {
        for (a = a.toString(c || 10); a.length < b;)a = "0" + a;
        return a
    }
};
GeoGlobe.Function = {
    bind: function (a, b) {
        var c = Array.prototype.slice.apply(arguments, [2]);
        return function () {
            var d = c.concat(Array.prototype.slice.apply(arguments, [0]));
            return a.apply(b, d)
        }
    }, bindAsEventListener: function (a, b) {
        return function (c) {
            return a.call(b, c || window.event)
        }
    }, False: function () {
        return !1
    }, True: function () {
        return !0
    }, Void: function () {
    }
};
GeoGlobe.Array = {
    filter: function (a, b, c) {
        var d = [];
        if (Array.prototype.filter) d = a.filter(b, c); else {
            var e = a.length;
            if (typeof b != "function")throw new TypeError;
            for (var f = 0; f < e; f++)if (f in a) {
                var g = a[f];
                b.call(c, g, f, a) && d.push(g)
            }
        }
        return d
    }
};
if (!String.prototype.endsWith) String.prototype.endsWith = function (a, b) {
    var c = this.toString();
    if (typeof b !== "number" || !isFinite(b) || Math.floor(b) !== b || b > c.length) b = c.length;
    b -= a.length;
    c = c.lastIndexOf(a, b);
    return c !== -1 && c === b
};
GeoGlobe.Pixel = GeoGlobe.Class4OL({
    x: 0, y: 0, initialize: function (a, b) {
        this.x = parseFloat(a);
        this.y = parseFloat(b)
    }, toString: function () {
        return "x=" + this.x + ",y=" + this.y
    }, clone: function () {
        return new GeoGlobe.Pixel(this.x, this.y)
    }, equals: function (a) {
        var b = !1;
        a != null && (b = this.x == a.x && this.y == a.y || isNaN(this.x) && isNaN(this.y) && isNaN(a.x) && isNaN(a.y));
        return b
    }, distanceTo: function (a) {
        return Math.sqrt(Math.pow(this.x - a.x, 2) + Math.pow(this.y - a.y, 2))
    }, add: function (a, b) {
        if (a == null || b == null)throw new TypeError("Pixel.add cannot receive null values");
        return new GeoGlobe.Pixel(this.x + a, this.y + b)
    }, offset: function (a) {
        var b = this.clone();
        a && (b = this.add(a.x, a.y));
        return b
    }, CLASS_NAME: "GeoGlobe.Pixel"
});
GeoGlobe.Size = GeoGlobe.Class4OL({
    w: 0, h: 0, initialize: function (a, b) {
        this.w = parseFloat(a);
        this.h = parseFloat(b)
    }, toString: function () {
        return "w=" + this.w + ",h=" + this.h
    }, clone: function () {
        return new GeoGlobe.Size(this.w, this.h)
    }, equals: function (a) {
        var b = !1;
        a != null && (b = this.w == a.w && this.h == a.h || isNaN(this.w) && isNaN(this.h) && isNaN(a.w) && isNaN(a.h));
        return b
    }, CLASS_NAME: "GeoGlobe.Size"
});
GeoGlobe.Date = {
    dateRegEx: /^(?:(\d{4})(?:-(\d{2})(?:-(\d{2}))?)?)?(?:(?:T(\d{1,2}):(\d{2}):(\d{2}(?:\.\d+)?)(Z|(?:[+-]\d{1,2}(?::(\d{2}))?)))|Z)?$/,
    toISOString: function () {
        return "toISOString" in Date.prototype ? function (a) {
            return a.toISOString()
        } : function (a) {
            return isNaN(a.getTime()) ? "Invalid Date" : a.getUTCFullYear() + "-" + GeoGlobe.Number.zeroPad(a.getUTCMonth() + 1, 2) + "-" + GeoGlobe.Number.zeroPad(a.getUTCDate(), 2) + "T" + GeoGlobe.Number.zeroPad(a.getUTCHours(), 2) + ":" + GeoGlobe.Number.zeroPad(a.getUTCMinutes(),
                    2) + ":" + GeoGlobe.Number.zeroPad(a.getUTCSeconds(), 2) + "." + GeoGlobe.Number.zeroPad(a.getUTCMilliseconds(), 3) + "Z"
        }
    }(),
    parse: function (a) {
        var b;
        if ((a = a.match(this.dateRegEx)) && (a[1] || a[7])) {
            b = parseInt(a[1], 10) || 0;
            var c = parseInt(a[2], 10) - 1 || 0, d = parseInt(a[3], 10) || 1;
            b = new Date(Date.UTC(b, c, d));
            if (c = a[7]) {
                var d = parseInt(a[4], 10), e = parseInt(a[5], 10), f = parseFloat(a[6]), g = f | 0;
                b.setUTCHours(d, e, g, Math.round(1E3 * (f - g)));
                c !== "Z" && (c = parseInt(c, 10), a = parseInt(a[8], 10) || 0, b = new Date(b.getTime() + -1E3 * (60 * c * 60 + a * 60)))
            }
        } else b =
            new Date("invalid");
        return b
    }
};
GeoGlobe.Console = {
    log: function () {
    }, debug: function () {
    }, info: function () {
    }, warn: function () {
    }, error: function () {
    }, userError: function (a) {
        alert(a)
    }, assert: function () {
    }, dir: function () {
    }, dirxml: function () {
    }, trace: function () {
    }, group: function () {
    }, groupEnd: function () {
    }, time: function () {
    }, timeEnd: function () {
    }, profile: function () {
    }, profileEnd: function () {
    }, count: function () {
    }, CLASS_NAME: "GeoGlobe.Console"
};
(function () {
    for (var a = document.getElementsByTagName("script"), b = 0, c = a.length; b < c; ++b)if (a[b].src.indexOf("firebug.js") != -1 && console) {
        GeoGlobe.Util.extend(GeoGlobe.Console, console);
        break
    }
})();
GeoGlobe.ProxyHost = "";
if (!GeoGlobe.Request) GeoGlobe.Request = {};
GeoGlobe.Util.extend(GeoGlobe.Request, {
    DEFAULT_CONFIG: {
        method: "GET",
        url: window.location.href,
        async: !0,
        user: void 0,
        password: void 0,
        params: null,
        proxy: GeoGlobe.ProxyHost,
        headers: {},
        data: null,
        callback: function () {
        },
        success: null,
        failure: null,
        scope: null
    }, URL_SPLIT_REGEX: /([^:]*:)\/\/([^:]*:?[^@]*@)?([^:\/\?]*):?([^\/\?]*)/, makeSameOrigin: function (a, b) {
        var c = a.indexOf("http") !== 0, d = !c && a.match(this.URL_SPLIT_REGEX);
        if (d) {
            var e = window.location, c = d[1] == e.protocol && d[3] == e.hostname, d = d[4], e = e.port;
            if (d != 80 &&
                d != "" || e != "80" && e != "") c = c && d == e
        }
        c || b && (a = typeof b == "function" ? b(a) : a.indexOf("cts?") >= 0 ? b + a : b + encodeURIComponent(a));
        return a
    }, issue: function (a) {
        var b = GeoGlobe.Util.extend(this.DEFAULT_CONFIG, {proxy: GeoGlobe.ProxyHost}), a = a || {};
        a.headers = a.headers || {};
        a = GeoGlobe.Util.applyDefaults(a, b);
        a.headers = GeoGlobe.Util.applyDefaults(a.headers, b.headers);
        var b = !1, c;
        for (c in a.headers)a.headers.hasOwnProperty(c) && c.toLowerCase() === "x-requested-with" && (b = !0);
        b === !1 && (a.headers["X-Requested-With"] = "XMLHttpRequest");
        var d = new GeoGlobe.Request.XMLHttpRequest;
        a.url = encodeURI(a.url);
        var e = GeoGlobe.Util.urlAppend(a.url, GeoGlobe.Util.getParameterString(a.params || {})),
            e = GeoGlobe.Request.makeSameOrigin(e, a.proxy);
        d.open(a.method, e, a.async, a.user, a.password);
        for (var f in a.headers)d.setRequestHeader(f, a.headers[f]);
        var g = this;
        d.onreadystatechange = function () {
            d.readyState == GeoGlobe.Request.XMLHttpRequest.DONE && null !== !1 && g.runCallbacks({
                request: d,
                config: a,
                requestUrl: e
            })
        };
        a.async === !1 ? d.send(a.data) : window.setTimeout(function () {
            d.readyState !==
            0 && d.send(a.data)
        }, 0);
        return d
    }, runCallbacks: function (a) {
        var b = a.request, a = a.config, c = a.scope ? GeoGlobe.Function.bind(a.callback, a.scope) : a.callback, d;
        a.success && (d = a.scope ? GeoGlobe.Function.bind(a.success, a.scope) : a.success);
        var e;
        a.failure && (e = a.scope ? GeoGlobe.Function.bind(a.failure, a.scope) : a.failure);
        if (GeoGlobe.Util.createUrlObject(a.url).protocol == "file:" && b.responseText) b.status = 200;
        c(b);
        (!b.status || b.status >= 200 && b.status < 300) && d && d(b);
        b.status && (b.status < 200 || b.status >= 300) && e && e(b)
    }, GET: function (a) {
        a =
            GeoGlobe.Util.extend(a, {method: "GET"});
        return GeoGlobe.Request.issue(a)
    }, POST: function (a) {
        a = GeoGlobe.Util.extend(a, {method: "POST"});
        a.headers = a.headers ? a.headers : {};
        "CONTENT-TYPE" in GeoGlobe.Util.upperCaseObject(a.headers) || (a.headers["Content-Type"] = "application/xml");
        return GeoGlobe.Request.issue(a)
    }, PUT: function (a) {
        a = GeoGlobe.Util.extend(a, {method: "PUT"});
        a.headers = a.headers ? a.headers : {};
        "CONTENT-TYPE" in GeoGlobe.Util.upperCaseObject(a.headers) || (a.headers["Content-Type"] = "application/xml");
        return GeoGlobe.Request.issue(a)
    },
    DELETE: function (a) {
        a = GeoGlobe.Util.extend(a, {method: "DELETE"});
        return GeoGlobe.Request.issue(a)
    }, HEAD: function (a) {
        a = GeoGlobe.Util.extend(a, {method: "HEAD"});
        return GeoGlobe.Request.issue(a)
    }, OPTIONS: function (a) {
        a = GeoGlobe.Util.extend(a, {method: "OPTIONS"});
        return GeoGlobe.Request.issue(a)
    }
});
GeoGlobe.nullHandler = function (a) {
    GeoGlobe.Console.userError(GeoGlobe.i18n("unhandledRequest", {statusText: a.statusText}))
};
GeoGlobe.loadURL = function (a, b, c, d, e) {
    typeof b == "string" && (b = GeoGlobe.Util.getParameters(b));
    return GeoGlobe.Request.GET({
        url: a,
        params: b,
        success: d ? d : GeoGlobe.nullHandler,
        failure: e ? e : GeoGlobe.nullHandler,
        scope: c
    })
};
GeoGlobe.Request.setProxyHost = function (a) {
    GeoGlobe.ProxyHost = a
};
GeoGlobe.Request.getProxyHost = function () {
    return GeoGlobe.ProxyHost
};
GeoGlobe.appendToProxy = function (a) {
    var a = a.split("?"), b = GeoGlobe.ProxyHost + encodeURI(encodeURI(a[0]));
    a.length === 2 && (b += "?" + a[1]);
    return b
};
GeoGlobe.loadScript = function (a) {
    GeoGlobe.Request.GET({
        url: a,
        async: !1,
        headers: {Accept: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript, */*; q=0.01"},
        success: function (a) {
            GeoGlobe.Util.globalEval(a.responseText)
        },
        failure: function () {
            alert("\u52a0\u8f7d:" + a + " \u5931\u8d25\u3002")
        }
    })
};
(function () {
    function a() {
        this._object = f && !j ? new f : new window.ActiveXObject("Microsoft.XMLHTTP");
        this._listeners = []
    }

    function b() {
        return new a
    }

    function c(a) {
        b.onreadystatechange && b.onreadystatechange.apply(a);
        a.dispatchEvent({type: "readystatechange", bubbles: !1, cancelable: !1, timeStamp: new Date + 0})
    }

    function d(a) {
        try {
            a.responseText = a._object.responseText
        } catch (b) {
        }
        try {
            var c;
            var d = a._object, e = d.responseXML, f = d.responseText;
            if (h && f && e && !e.documentElement && d.getResponseHeader("Content-Type").match(/[^\/]+\/[^\+]+\+xml/)) e =
                new window.ActiveXObject("Microsoft.XMLDOM"), e.async = !1, e.validateOnParse = !1, e.loadXML(f);
            c = e && (h && e.parseError != 0 || !e.documentElement || e.documentElement && e.documentElement.tagName == "parsererror") ? null : e;
            a.responseXML = c
        } catch (g) {
        }
        try {
            a.status = a._object.status
        } catch (j) {
        }
        try {
            a.statusText = a._object.statusText
        } catch (t) {
        }
    }

    function e(a) {
        a._object.onreadystatechange = new window.Function
    }

    var f = window.XMLHttpRequest, g = !!window.controllers, h = window.document.all && !window.opera,
        j = h && window.navigator.userAgent.match(/MSIE 7.0/);
    b.prototype = a.prototype;
    if (g && f.wrapped) b.wrapped = f.wrapped;
    b.UNSENT = 0;
    b.OPENED = 1;
    b.HEADERS_RECEIVED = 2;
    b.LOADING = 3;
    b.DONE = 4;
    b.prototype.readyState = b.UNSENT;
    b.prototype.responseText = "";
    b.prototype.responseXML = null;
    b.prototype.status = 0;
    b.prototype.statusText = "";
    b.prototype.priority = "NORMAL";
    b.prototype.onreadystatechange = null;
    b.onreadystatechange = null;
    b.onopen = null;
    b.onsend = null;
    b.onabort = null;
    b.prototype.open = function (a, f, j, p, q) {
        delete this._headers;
        arguments.length < 3 && (j = !0);
        this._async = j;
        var o = this,
            s = this.readyState, r;
        h && j && (r = function () {
            s != b.DONE && (e(o), o.abort())
        }, window.attachEvent("onunload", r));
        b.onopen && b.onopen.apply(this, arguments);
        arguments.length > 4 ? this._object.open(a, f, j, p, q) : arguments.length > 3 ? this._object.open(a, f, j, p) : this._object.open(a, f, j);
        try {
            this._object.responseType = "msxml-document"
        } catch (t) {
        }
        this.readyState = b.OPENED;
        c(this);
        this._object.onreadystatechange = function () {
            if (!g || j) o.readyState = o._object.readyState, d(o), o._aborted ? o.readyState = b.UNSENT : (o.readyState == b.DONE && (delete o._data,
                e(o), h && j && window.detachEvent("onunload", r)), s != o.readyState && c(o), s = o.readyState)
        }
    };
    b.prototype.send = function (a) {
        b.onsend && b.onsend.apply(this, arguments);
        arguments.length || (a = null);
        a && a.nodeType && (a = window.XMLSerializer ? (new window.XMLSerializer).serializeToString(a) : a.xml, this._headers["Content-Type"] || this._object.setRequestHeader("Content-Type", "application/xml"));
        this._data = a;
        this._object.send(this._data);
        if (g && !this._async) {
            this.readyState = b.OPENED;
            for (d(this); this.readyState < b.DONE;)if (this.readyState++,
                    c(this), this._aborted)break
        }
    };
    b.prototype.abort = function () {
        b.onabort && b.onabort.apply(this, arguments);
        if (this.readyState > b.UNSENT) this._aborted = !0;
        this._object.abort();
        e(this);
        this.readyState = b.UNSENT;
        delete this._data
    };
    b.prototype.getAllResponseHeaders = function () {
        return this._object.getAllResponseHeaders()
    };
    b.prototype.getResponseHeader = function (a) {
        return this._object.getResponseHeader(a)
    };
    b.prototype.setRequestHeader = function (a, b) {
        if (!this._headers) this._headers = {};
        this._headers[a] = b;
        return this._object.setRequestHeader(a,
            b)
    };
    b.prototype.addEventListener = function (a, b, c) {
        for (var d = 0, e; e = this._listeners[d]; d++)if (e[0] == a && e[1] == b && e[2] == c)return;
        this._listeners.push([a, b, c])
    };
    b.prototype.removeEventListener = function (a, b, c) {
        for (var d = 0, e; e = this._listeners[d]; d++)if (e[0] == a && e[1] == b && e[2] == c)break;
        e && this._listeners.splice(d, 1)
    };
    b.prototype.dispatchEvent = function (a) {
        a = {
            type: a.type,
            target: this,
            currentTarget: this,
            eventPhase: 2,
            bubbles: a.bubbles,
            cancelable: a.cancelable,
            timeStamp: a.timeStamp,
            stopPropagation: function () {
            },
            preventDefault: function () {
            },
            initEvent: function () {
            }
        };
        a.type == "readystatechange" && this.onreadystatechange && (this.onreadystatechange.handleEvent || this.onreadystatechange).apply(this, [a]);
        for (var b = 0, c; c = this._listeners[b]; b++)c[0] == a.type && !c[2] && (c[1].handleEvent || c[1]).apply(this, [a])
    };
    b.prototype.toString = function () {
        return "[object XMLHttpRequest]"
    };
    b.toString = function () {
        return "[XMLHttpRequest]"
    };
    if (!window.Function.prototype.apply) window.Function.prototype.apply = function (a, b) {
        b || (b = []);
        a.__func = this;
        a.__func(b[0], b[1], b[2],
            b[3], b[4]);
        delete a.__func
    };
    if (!GeoGlobe.Request) GeoGlobe.Request = {};
    GeoGlobe.Request.XMLHttpRequest = b
})();
GeoGlobe.Map = GeoGlobe.Class(mapboxgl.FreeCRSMap, {
    container: null,
    hash: !1,
    interactive: !0,
    preserveDrawingBuffer: !1,
    zoom: 0,
    center: [0, 0],
    minzoom: 0,
    maxzoom: 20,
    pitch3Dzoom: 16,
    is3Dpitching: !0,
    isAttributionControl: !0,
    maxBounds: null,
    isScrollZoom: !0,
    isBooxZoom: !0,
    isDragRotate: !0,
    isDragPan: !0,
    isKeyboard: !0,
    isDoubleClickZoom: !0,
    isTouchZoomRotate: !0,
    isTrackResize: !0,
    logoPosition: !0,
    bearingSnap: 0,
    bearing: 0,
    pitch: 0,
    showTileBoundaries: !1,
    showCollisionBoxes: !1,
    repaint: !0,
    epsg: "EPSG:3857",
    units: null,
    initialize: function (a) {
        this.options =
            a;
        if (a.isAttributionControl == !1) a.attributionControl = a.isAttributionControl;
        if (a.isScrollZoom == !1) a.scrollZoom = a.isScrollZoom;
        if (a.isBooxZoom == !1) a.boxZoom = a.isBooxZoom;
        if (a.isDragRotate == !1) a.dragRotate = a.isDragRotate;
        if (a.isDragPan == !1) a.dragPan = a.isDragPan;
        if (a.isKeyboard == !1) a.keyboard = a.isKeyboard;
        if (a.isDoubleClickZoom == !1) a.doubleClickZoom = a.isDoubleClickZoom;
        if (a.isTouchZoomRotate == !1) a.touchZoomRotate = a.isTouchZoomRotate;
        if (a.isTrackResize == !1) a.trackResize = a.isTrackResize;
        if (!a.epsg) a.epsg =
            "EPSG:3857";
        if (!a.units) a.units = "degrees";
        if (!a.isConstrain) a.isConstrain = !1;
        this.map = new mapboxgl.FreeCRSMap(a);
        this.map.epsg = a.epsg;
        this.map.units = a.units;
        this.map.setIsConstrain(a.isConstrain);
        this.map.pitch3Dzoom = this.options.pitch3Dzoom ? this.options.pitch3Dzoom : 16;
        this.map.setIs3DPZoom(this.options.is3Dpitching);
        return this.map
    },
    setStyle: function (a) {
        this.map.setStyle(a)
    },
    getStyle: function () {
        return this.map.getStyle()
    },
    addControl: function (a) {
        this.map.addControl(a)
    },
    removeControl: function (a) {
        this.map.removeControl(a)
    },
    getBounds: function () {
        return this.map.getBounds()
    },
    setMaxBounds: function (a) {
        this.map.setMaxBounds(a)
    },
    setMaxZoom: function (a) {
        this.map.setMaxZoom(a)
    },
    getMaxZoom: function () {
        return this.map.getMaxZoom()
    },
    setMinZoom: function (a) {
        this.map.setMinZoom(a)
    },
    getMinZoom: function () {
        return this.map.getMinZoom()
    },
    project: function (a) {
        return this.map.project(a)
    },
    unproject: function (a) {
        return this.map.unproject(a)
    },
    addSource: function (a, b) {
        this.map.addSource(a, b)
    },
    isSourceLoaded: function (a) {
        this.map.isSourceLoaded(a)
    },
    getSource: function (a) {
        return this.map.getSource(a)
    },
    removeSource: function (a) {
        this.map.removeSource(a)
    },
    addLayer: function (a, b) {
        this.map.addLayer(a, b)
    },
    removeLayer: function (a) {
        this.map.removeLayer(a)
    },
    getLayer: function (a) {
        return this.map.getLayer(a)
    },
    moveLayer: function (a) {
        this.map.moveLayer(a)
    },
    setFilter: function (a, b) {
        this.map.setFilter(a, b)
    },
    setLayerZoomRange: function (a, b, c) {
        this.map.setLayerZoomRange(a, b, c)
    },
    getFilter: function (a) {
        return this.map.getFilter(a)
    },
    setPaintProperty: function (a, b, c, d) {
        this.map.setPaintProperty(a,
            b, c, d)
    },
    getPaintProperty: function (a, b, c) {
        return this.map.getPaintProperty(a, b, c)
    },
    setLayoutProperty: function (a, b, c) {
        this.map.setLayoutProperty(a, b, c)
    },
    getLayoutProperty: function (a, b) {
        return this.map.getLayoutProperty(a, b)
    },
    queryRenderedFeatures: function (a, b) {
        return this.map.queryRenderedFeatures(a, b)
    },
    querySourceFeatures: function () {
        return this.map.getPaintProperty(layer, name, klass)
    },
    addClass: function (a, b) {
        this.map.addClass(a, b)
    },
    removeClass: function (a, b) {
        this.map.removeClass(a, b)
    },
    setClasses: function (a,
                          b) {
        this.map.setClasses(a, b)
    },
    hasClasses: function (a) {
        return this.map.hasClasses(a)
    },
    getClasses: function () {
        return this.map.getClasses()
    },
    resize: function () {
        this.map.resize()
    },
    isloaded: function () {
        return this.map.loaded()
    },
    getCenter: function () {
        return this.map.getCenter()
    },
    setCenter: function (a, b) {
        this.map.setCenter(a, b)
    },
    getLight: function () {
        return this.map.getLight()
    },
    setLight: function (a) {
        this.map.setLight(a)
    },
    remove: function () {
        this.map.remove()
    },
    panBy: function (a, b, c) {
        this.map.panBy(a, b, c)
    },
    panTo: function (a,
                     b, c) {
        this.map.panTo(a, b, c)
    },
    getZoom: function () {
        return this.map.getZoom()
    },
    setZoom: function (a, b) {
        this.map.setZoom(a, b)
    },
    zoomTo: function (a, b, c) {
        this.map.zoomTo(a, b, c)
    },
    ZoomIn: function (a, b) {
        this.map.zoomIn(a, b)
    },
    ZoomOut: function (a, b) {
        this.map.zoomOut(a, b)
    },
    getBearing: function () {
        return this.map.getBearing()
    },
    setBearing: function (a, b) {
        this.map.setBearing(a, b)
    },
    rotateTo: function (a, b, c) {
        this.map.rotateTo(a, b, c)
    },
    getPitch: function () {
        return this.map.getPitch()
    },
    setPitch: function (a, b) {
        this.map.setPitch(a, b)
    },
    fitBounds: function (a, b, c) {
        this.map.fitBounds(a, b, c)
    },
    resetNorth: function (a, b) {
        this.map.resetNorth(a, b)
    },
    snapToNorth: function (a, b) {
        this.map.snapToNorth(a, b)
    },
    getContainer: function () {
        return this.map.getContainer()
    },
    getCanvasContainer: function () {
        return this.map.getCanvasContainer()
    },
    getCanvas: function () {
        return this.map.getCanvas()
    },
    jumpTo: function (a, b) {
        this.map.jumpTo(a, b)
    },
    easeTo: function (a, b) {
        this.map.easeTo(a, b)
    },
    flyTo: function (a, b) {
        this.map.flyTo(a, b)
    },
    isMoving: function () {
        this.map.stop()
    },
    stop: function () {
        this.map.stop()
    },
    SpatialReference: function () {
        var a = null;
        if (this.baseLayer != null) a = this.SpatialReference;
        return a ? a.getCode() : null
    },
    CLASS_NAME: "GeoGlobe.Map"
});
mapboxgl.FreeCRSMap.prototype.addCanvasLayer = function (a) {
    a.addTo(this)
};
mapboxgl.FreeCRSMap.prototype.removeCanvasLayer = function (a) {
    a.remove()
};
mapboxgl.FreeCRSMap.prototype.setIs3DPZoom = function (a) {
    if (a) this.on("zoom", this.setZoompitch); else this.off("zoom", this.setZoompitch)
};
mapboxgl.FreeCRSMap.prototype.set3Dzoom = function (a) {
    if (a) this.pitch3Dzoom = a
};
mapboxgl.FreeCRSMap.prototype.setZoompitch = function () {
    var a = this.getZoom(), b = this.pitch3Dzoom, c = this.getPitch();
    parseInt(a) >= b ? c == 0 && this.setPitch(60) : c == 60 && this.setPitch(0)
};
mapboxgl.FreeCRSMap.prototype.addLayers = function (a) {
    if (a.length > 0)for (var b = 0; b < a.length; b++)this.addLayer(a[b])
};
mapboxgl.FreeCRSMap.prototype.getResolutions = function () {
    for (var a = [], b = 0; b <= 20; b++)a.push(this.getResolutionForLevel(b));
    return a
};
mapboxgl.FreeCRSMap.prototype.getResolutionForLevel = function (a, b) {
    var c = Math.abs(this._tileExtent[2] - this._tileExtent[0]);
    return c / (b ? b : 256) / Math.pow(2, a)
};
mapboxgl.FreeCRSMap.prototype.setIsConstrain = function (a) {
    this.isConstrain = a;
    this.transform._constraining = !this.isConstrain
};
mapboxgl.FreeCRSMap.prototype.addLayer = function (a, b) {
    if (a.CLASS_NAME === "GeoGlobe.Layer.VTS" || a.layerType === "VTS") {
        var c = a.layers;
        this.addSource(a.source_id, a.source);
        if (c.length > 0)for (var d = 0; d < c.length; d++)this.addLayer(c[d]);
        return this
    }
    if (a.layerOption && a.layerOption.metadata.type === "wms" && a.layerOption.metadata.isTile === !1)return a.addTo(this), this.style.addLayer(a.layerOption, b), this._update(!0), this;
    if (a.layerOption && a.layerOption.metadata.type === "hotarea")return a.addTo(this), this;
    if (typeof a.source ===
        "object" && this._mapCRS && a.source && a.source.type == "geojson" && a.source.data && !a.source.data.customprj) a.source.data.customprj = this._geojson_customprj;
    this.style.addLayer(a, b);
    this._update(!0);
    return this
};
mapboxgl.FreeCRSMap.prototype.removeLayerAndSource = function (a) {
    if (this.getLayer(a)) this.removeLayer(a), this.removeSource(a); else throw Error("Layer not found");
};
mapboxgl.FreeCRSMap.prototype.loadSprite = function (a, b) {
    this.style._loadSprite(a, b)
};
mapboxgl.FreeCRSMap.prototype.removeAllImages = function () {
    var a = this.style.imageManager, b;
    for (b in a.images)a.removeImage(b)
};
mapboxgl.FreeCRSMap.prototype.removeAllLayers = function () {
    var a = this.style._layers, b;
    for (b in a)this.removeLayer(b)
};
mapboxgl.FreeCRSMap.prototype.removeAllSources = function () {
    var a = this.style.sourceCaches, b;
    for (b in a)this.removeSource(b)
};
GeoGlobe.LngLatBounds = GeoGlobe.Class(mapboxgl.LngLatBounds, {
    sw: null, ne: null, initialize: function (a, b) {
        return this.LngLatBounds = new mapboxgl.LngLatBounds(a, b)
    }, convert: function (a) {
        return this.LngLatBounds.convert(a)
    }, setNorthEast: function (a) {
        this.LngLatBounds.setNorthEast(a)
    }, setSouthWest: function (a) {
        this.LngLatBounds.setSouthWest(a)
    }, extend: function (a) {
        this.LngLatBounds.extend(a)
    }, getCenter: function () {
        return this.LngLatBounds.getCenter()
    }, getSouthWest: function () {
        return this.LngLatBounds.getSouthWest()
    },
    getNorthEast: function () {
        return this.LngLatBounds.getNorthEast()
    }, getNorthWest: function () {
        return this.LngLatBounds.getNorthWest()
    }, getSouthEast: function () {
        return this.LngLatBounds.getSouthEast()
    }, getWest: function () {
        return this.LngLat.getWest()
    }, getEast: function () {
        return this.LngLatBounds.getEast()
    }, getSouth: function () {
        return this.LngLatBounds.getSouth()
    }, getNorth: function () {
        return this.LngLatBounds.getNorth()
    }, toArray: function () {
        return this.LngLatBounds.toArray()
    }, toString: function () {
        return this.LngLat.toString()
    },
    equals: function () {
    }, getWidth: function () {
    }, containsLonLat: function () {
    }, contains: function () {
    }, clone: function () {
    }, toBBOX: function () {
    }, toGeometry: function () {
    }, getCenterLonLat: function () {
    }, CLASS_NAME: "GeoGlobe.LngLatBounds"
});
mapboxgl.LngLatBounds.prototype.clone = function () {
    return new mapboxgl.LngLatBounds(this._sw, this._ne)
};
mapboxgl.LngLatBounds.prototype.contains = function (a, b, c) {
    c == null && (c = !0);
    if (a == null || b == null)return !1;
    var a = GeoGlobe.Util.toFloat(a), b = GeoGlobe.Util.toFloat(b), d = !1;
    return d = c ? a >= this._sw.lng && a <= this._ne.lng && b >= this._sw.lat && b <= this._ne.lat : a > this._sw.lng && a < this._ne.lng && b > this._sw.lat && b < this._ne.lat
};
mapboxgl.LngLatBounds.prototype.getWidth = function () {
    return this._ne.lng - this._sw.lng
};
mapboxgl.LngLatBounds.prototype.containsLonLat = function (a, b) {
    typeof b === "boolean" && (b = {inclusive: b});
    var b = b || {}, c = this.contains(a.lng, a.lat, b.inclusive), d = b.worldBounds;
    d && !c && (c = d.getWidth(), c = this.containsLonLat({
        lng: a.lng - Math.round((a.lng - (d._sw.lng + d._ne.lng) / 2) / c) * c,
        lat: a.lat
    }, {inclusive: b.inclusive}));
    return c
};
mapboxgl.LngLatBounds.prototype.equals = function (a) {
    var b = !1;
    a != null && (b = this._sw.lng == a._sw.lng && this._ne.lng == a._ne.lng && this._ne.lat == a._ne.lat && this._sw.lat == a._sw.lat);
    return b
};
mapboxgl.LngLatBounds.prototype.toBBOX = function (a, b) {
    a == null && (a = 6);
    var c = Math.pow(10, a), d = Math.round(this._sw.lng * c) / c, e = Math.round(this._sw.lat * c) / c,
        f = Math.round(this._ne.lng * c) / c, c = Math.round(this._ne.lat * c) / c;
    return b === !0 ? e + "," + d + "," + c + "," + f : d + "," + e + "," + f + "," + c
};
mapboxgl.LngLatBounds.prototype.toGeometry = function () {
    return new GeoGlobe.Geometry.Polygon([new GeoGlobe.Geometry.LinearRing([new GeoGlobe.Geometry.Point(this._sw.lng, this._sw.lat), new GeoGlobe.Geometry.Point(this._ne.lng, this._sw.lat), new GeoGlobe.Geometry.Point(this._ne.lng, this._ne.lat), new GeoGlobe.Geometry.Point(this._sw.lng, this._ne.lat)])])
};
mapboxgl.LngLatBounds.prototype.getCenterLonLat = function () {
    if (!this.centerLonLat) this.centerLonLat = new GeoGlobe.LngLat((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
    return this.centerLonLat
};
mapboxgl.LngLatBounds.prototype.CLASS_NAME = "GeoGlobe.LngLatBounds";
GeoGlobe.LngLatBounds.fromString = function (a, b) {
    var c = a.split(",");
    return GeoGlobe.LngLatBounds.fromArray(c, b)
};
GeoGlobe.LngLatBounds.fromArray = function (a, b) {
    return b === !0 ? new GeoGlobe.LngLatBounds(new GeoGlobe.LngLat(a[1], a[0]), new GeoGlobe.LngLat(a[3], a[2])) : new GeoGlobe.LngLatBounds(new GeoGlobe.LngLat(a[0], a[1]), new GeoGlobe.LngLat(a[2], a[3]))
};
GeoGlobe.LngLatBounds.toGeometryByTwoPixel = function (a, b, c) {
    for (var a = [mapboxgl.Point.convert(a), mapboxgl.Point.convert(b)], a = [a[0], new mapboxgl.Point(a[1].x, a[0].y), a[1], new mapboxgl.Point(a[0].x, a[1].y)], b = [], d = 0; d < a.length; d++) {
        var e = c.unproject(a[d]), e = new GeoGlobe.Geometry.Point(e.lng, e.lat);
        b.push(e)
    }
    return new GeoGlobe.Geometry.Polygon([new GeoGlobe.Geometry.LinearRing(b)])
};
GeoGlobe.LngLat = GeoGlobe.Class(mapboxgl.LngLat, {
    lon: null, lat: null, initialize: function (a, b) {
        return this.LngLat = new mapboxgl.LngLat(a, b)
    }, convert: function (a) {
        return this.LngLat.convert(a)
    }, wrap: function () {
        return this.LngLat.wrap()
    }, toArray: function () {
        return this.LngLat.toArray()
    }, toString: function () {
        return this.LngLat.toString()
    }, CLASS_NAME: "GeoGlobe.LngLat"
});
GeoGlobe.Layer = GeoGlobe.Class(mapboxgl.FreeCRSMap, {
    visibility: null,
    id: null,
    name: null,
    alias: null,
    ref: null,
    sourceId: null,
    sourceLayerId: null,
    metadata: null,
    filter: null,
    maxZoom: 20,
    minZoom: 0,
    initialize: function () {
        return this
    },
    CLASS_NAME: "GeoGlobe.Layer"
});
GeoGlobe.Layer.WMTS = GeoGlobe.Class4OL({
    url: null,
    layer: null,
    format: null,
    matrixSet: null,
    style: null,
    name: null,
    resolutions: null,
    zoomOffset: null,
    matrixIds: null,
    tileOrigin: null,
    tileFullExtent: null,
    initialize: function (a) {
        return this._getWMTSLayer(a)
    },
    _getWMTSLayer: function (a) {
        var b = {};
        if (a.layer) b.LAYER = a.layer;
        if (a.format) b.FORMAT = a.format;
        if (a.matrixSet) b.TILEMATRIXSET = a.matrixSet;
        if (a.version) b.VERSION = a.version;
        if (!a.zoomOffset) a.zoomOffset = 0;
        if (a.style) b.STYLE = a.style;
        b.TILEMATRIX = "{z}";
        b.TILEROW = "{y}";
        b.TILECOL = "{x}";
        GeoGlobe.Util.applyDefaults(b, {service: "WMTS", request: "GetTile"});
        b = this.urlAppend(a.url, this.getParameterString(b || {}));
        b = GeoGlobe.appendToProxy(b);
        return {
            id: "wmts_" + a.layer + "_" + GeoGlobe.Util.randomStr(8),
            type: "raster",
            source: {type: "raster", tiles: [b], zoomOffset: a.zoomOffset, tileSize: 256}
        }
    },
    getParameterString: function (a) {
        var b = [], c;
        for (c in a) {
            var d = a[c];
            if (d != null && typeof d != "function") {
                if (typeof d == "object" && d.constructor == Array) {
                    for (var e = [], f, g = 0, h = d.length; g < h; g++)f = d[g], e.push(encodeURIComponent(f ===
                    null || f === void 0 ? "" : f));
                    d = e.join(",")
                }
                b.push(encodeURIComponent(c) + "=" + d)
            }
        }
        return b.join("&")
    },
    urlAppend: function (a, b) {
        var c = a;
        if (b) {
            var d = (a + " ").split(/[?&]/);
            c += d.pop() === " " ? b : d.length ? "&" + b : "?" + b
        }
        return c
    },
    clone: function (a) {
        a == null && (a = new GeoGlobe.Layer.WMTS(this.id, this.tileSize, this.filter, this.opacity, this.visible, this.name, this.url));
        return a
    },
    getMatrix: function () {
        var a;
        if (!this.matrixIds || this.matrixIds.length === 0) a = {identifier: this.getIdentifier()}; else if ("scaleDenominator" in this.matrixIds[0])for (var b =
            GeoGlobe.METERS_PER_INCH * GeoGlobe.INCHES_PER_UNIT[this.units] * this.getServerResolution() / 2.8E-4, c = Number.POSITIVE_INFINITY, d, e = 0, f = this.matrixIds.length; e < f; ++e)d = Math.abs(1 - this.matrixIds[e].scaleDenominator / b), d < c && (c = d, a = this.matrixIds[e]); else a = this.matrixIds[this.getIdentifier()];
        return a
    },
    CLASS_NAME: "GeoGlobe.Layer.WMTS"
});
GeoGlobe.Layer.WMS = GeoGlobe.Class4OL({
    url: null, layer: null, format: null, version: null, width: 256, height: 256, SRS: null, initialize: function (a) {
        if (a.isTile != void 0 && a.isTile === !1) this.layerOption = this._getWMSLayer(a); else return this._getWMSTileLayer(a)
    }, addTo: function (a) {
        this.map = a;
        this.move = GeoGlobe.Function.bind(GeoGlobe.Util.delayFun(this.moveend, 300), this);
        this.map.on("moveend", this.move);
        this.width = a.getCanvas().width;
        this.height = a.getCanvas().height;
        var b = a.getBounds(), a = b._ne.lng, c = b._ne.lat, d = b._sw.lng,
            b = b._sw.lat;
        this.layerOption.source.url = this.layerOption.source.url.replace("{bbox}", d + "," + b + "," + a + "," + c).replace("{width}", this.width).replace("{height}", this.height);
        this.layerOption.source.coordinates = [[d, c], [a, c], [a, b], [d, b]]
    }, _getWMSLayer: function (a) {
        a.transparent || a.transparent === !1 ? this.options.transparent = a.transparent : a.transparent = !0;
        this.options = a;
        this.url = a.url;
        var b = this.getParamString({
                SERVICE: "WMS",
                REQUEST: "GetMap",
                VERSION: a.version,
                LAYERS: a.layer,
                styles: a.styles,
                FORMAT: a.format,
                TRANSPARENT: a.transparent,
                BBOX: "{bbox}",
                WIDTH: "{width}",
                HEIGHT: "{height}",
                SRS: a.SRS
            }), c = "", c = this.url.endsWith("?") ? this.url + b : this.url + "?" + b, c = GeoGlobe.appendToProxy(c),
            b = GeoGlobe.Util.randomStr(10),
            d = {name: a.layer, srs: a.SRS, type: "wms", isTile: a.isTile, format: a.formats};
        this.id = "layer_" + a.layer + "_" + b;
        return {id: this.id, source: {type: "image", url: c, coordinates: []}, metadata: d, type: "raster"}
    }, _getWMSTileLayer: function (a) {
        var b = {};
        if (a.layer) b.LAYERS = a.layer;
        if (a.format) b.FORMAT = a.format;
        b.TRANSPARENT = a.transparent || a.transparent ===
        !1 ? a.transparent : !0;
        if (a.styles) b.styles = a.styles;
        if (a.tileSize) b.HEIGHT = a.tileSize, b.WIDTH = a.tileSize;
        if (a.version) b.VERSION = a.version;
        if (a.SRS) b.SRS = a.SRS;
        b.BBOX = "{bbox-epsg-3857}";
        GeoGlobe.Util.applyDefaults(b, {service: "WMS", request: "GetMap"});
        var c = {name: a.layer, srs: a.SRS, bbox: a.bbox, format: a.format},
            d = "wms_" + a.layer + "_" + GeoGlobe.Util.randomStr(8),
            b = this.urlAppend(a.url, this.getParameterString(b || {})), b = GeoGlobe.appendToProxy(b);
        return {
            id: d, type: "raster", source: {type: "raster", tiles: [b], tileSize: a.tileSize},
            metadata: c
        }
    }, moveend: function () {
        if (this.map.style._layers[this.id] && this.map.style._layers[this.id].layout.visibility != "none") {
            var a = this.map.getBounds(), b = a._ne.lng, c = a._ne.lat, d = a._sw.lng, e = a._sw.lat, a,
                f = this.getParameterString({
                    SERVICE: "WMS",
                    REQUEST: "GetMap",
                    VERSION: this.options.version,
                    LAYERS: this.options.layer,
                    styles: this.options.styles,
                    FORMAT: this.options.format,
                    TRANSPARENT: this.options.transparent,
                    BBOX: d + "," + e + "," + b + "," + c,
                    WIDTH: this.width,
                    HEIGHT: this.height,
                    SRS: this.options.SRS
                });
            a = "";
            a = this.url.endsWith("?") ?
                this.url + f : this.url + "?" + f;
            a = GeoGlobe.appendToProxy(a);
            b = [[d, c], [b, c], [b, e], [d, e]];
            c = this.map.getSource(this.id);
            c.url = a;
            c.options.url = a;
            c.coordinates = b;
            c.options.coordinates = b;
            c.load()
        }
    }, getParameterString: function (a) {
        var b = [], c;
        for (c in a) {
            var d = a[c];
            if (d != null && typeof d != "function") {
                if (typeof d == "object" && d.constructor == Array) {
                    for (var e = [], f, g = 0, h = d.length; g < h; g++)f = d[g], e.push(encodeURIComponent(f === null || f === void 0 ? "" : f));
                    d = e.join(",")
                }
                b.push(encodeURIComponent(c) + "=" + d)
            }
        }
        return b.join("&")
    },
    urlAppend: function (a, b) {
        var c = a;
        if (b) {
            var d = (a + " ").split(/[?&]/);
            c += d.pop() === " " ? b : d.length ? "&" + b : "?" + b
        }
        return c
    }, clone: function (a) {
        a == null && (a = new GeoGlobe.Layer.WMS(this.id, this.tileSize, this.filter, this.opacity, this.visible, this.name, this.url));
        return a
    }, getParamString: function (a) {
        var b = [], c;
        for (c in a) {
            var d = a[c];
            d != null && typeof d != "function" && b.push(c + "=" + d)
        }
        return b.join("&")
    }, CLASS_NAME: "GeoGlobe.Layer.WMS"
});
GeoGlobe.Layer.VTS = GeoGlobe.Class4OL({
    url: null,
    layer: null,
    format: null,
    matrixSet: null,
    style: null,
    name: null,
    resolutions: null,
    zoomOffset: null,
    matrixIds: null,
    tileOrigin: null,
    tileFullExtent: null,
    initialize: function (a) {
        this.source_id = "source_vts_" + GeoGlobe.Util.randomStr(6);
        this.layers = this._getVTSLayer(a);
        this.source = {type: "vector", tiles: [this.url_tmpl]}
    },
    _getVTSLayer: function (a) {
        this.url = a.url;
        var b = {};
        if (a.layer) b.LAYER = a.layer;
        if (a.format) b.FORMAT = a.format;
        if (a.matrixSet) b.TILEMATRIXSET = a.matrixSet;
        if (a.version) b.VERSION = a.version;
        if (a.tileSize) b.WIDTH = a.tileSize, b.HEIGHT = a.tileSize;
        b.TILEMATRIX = "{z}";
        b.TILEROW = "{y}";
        b.TILECOL = "{x}";
        GeoGlobe.Util.applyDefaults(b, {service: "WMTS", request: "GetTile"});
        var c = GeoGlobe.ProxyHost + this.urlAppend(a.url, this.getParameterString(b || {}));
        this.url_tmpl = c;
        var d = "source_vts_" + GeoGlobe.Util.randomStr(6);
        this.source_id = d;
        var e = [];
        this.GetStyle(a.styleName, function (c) {
            var g = {
                sprite: c.sprite ? GeoGlobe.ProxyHost + c.sprite : "",
                glyphs: c.glyphs ? GeoGlobe.ProxyHost + c.glyphs :
                    "",
                styleName: c.name,
                layerIdentifier: b.LAYER,
                matrixSet: b.TILEMATRIXSET,
                format: b.FORMAT,
                bbox: a.tileBBox ? a.tileBBox : "",
                minZoom: a.minZoom ? a.minZoom : "",
                maxZoom: a.maxZoom ? a.maxZoom : ""
            };
            if (c.styleData)for (var h = 0; h < c.styleData.layers.length; h++)c.styleData.layers[h].metadata = g, c.styleData.layers[h].source = d, e[h] = c.styleData.layers[h]; else for (h = 0; h < c.layers.length; h++)c.layers[h].source = d, c.layers[h].metadata = g, e[h] = c.layers[h]
        }, function () {
            alert("WMTS\u670d\u52a1\u8bf7\u6c42\u5931\u8d25\uff0c\u8bf7\u68c0\u67e5\u670d\u52a1\u662f\u5426\u6b63\u5e38\u8fd0\u884c\u6216\u8bf7\u6c42\u5730\u5740\u662f\u5426\u6b63\u786e\u3002\n\u8bf7\u6c42\u5730\u5740\uff1a" +
                c + "\n\u64cd\u4f5c\u7c7b\u578b\uff1aGetCapabilities")
        });
        return e
    },
    getParameterString: function (a) {
        var b = [], c;
        for (c in a) {
            var d = a[c];
            if (d != null && typeof d != "function") {
                if (typeof d == "object" && d.constructor == Array) {
                    for (var e = [], f, g = 0, h = d.length; g < h; g++)f = d[g], e.push(encodeURIComponent(f === null || f === void 0 ? "" : f));
                    d = e.join(",")
                }
                b.push(encodeURIComponent(c) + "=" + d)
            }
        }
        return b.join("&")
    },
    urlAppend: function (a, b) {
        var c = a;
        if (b) {
            var d = (a + " ").split(/[?&]/);
            c += d.pop() === " " ? b : d.length ? "&" + b : "?" + b
        }
        return c
    },
    GetStyle: function (a,
                        b, c) {
        var d = this.url;
        if (a == "" || a == void 0) alert("\u8bf7\u67e5\u770b\u6837\u5f0f\u540d\u79f0\u662f\u5426\u5b58\u5728"); else {
            var e = {REQUEST: "GetStyle", SERVICE: "WMTS", VERSION: "1.0.0", STYLENAME: a};
            c || (c = function () {
                this.failFn(e.REQUEST)
            });
            GeoGlobe.Request.GET({
                url: d, params: e, scope: this, async: !1, success: function (a) {
                    a = a.responseText;
                    if (!a)return c(), !1;
                    a = (new GeoGlobe.Format.JSON).read(a);
                    b(a)
                }, failure: c
            })
        }
    },
    clone: function (a) {
        a == null && (a = new GeoGlobe.Layer.VTS(this.id, this.tileSize, this.filter, this.opacity,
            this.visible, this.name, this.url));
        return a
    },
    getMatrix: function () {
        var a;
        if (!this.matrixIds || this.matrixIds.length === 0) a = {identifier: this.getIdentifier()}; else if ("scaleDenominator" in this.matrixIds[0])for (var b = GeoGlobe.METERS_PER_INCH * GeoGlobe.INCHES_PER_UNIT[this.units] * this.getServerResolution() / 2.8E-4, c = Number.POSITIVE_INFINITY, d, e = 0, f = this.matrixIds.length; e < f; ++e)d = Math.abs(1 - this.matrixIds[e].scaleDenominator / b), d < c && (c = d, a = this.matrixIds[e]); else a = this.matrixIds[this.getIdentifier()];
        return a
    },
    CLASS_NAME: "GeoGlobe.Layer.VTS"
});
GeoGlobe.Layer.WMS_ = GeoGlobe.Class(GeoGlobe.Layer, {
    id: null,
    name: null,
    tileSize: 256,
    url: null,
    filter: null,
    opacity: 0,
    visible: !0,
    maxZoom: 20,
    minZoom: 0,
    initialize: function (a) {
        return {
            id: a.id,
            layer: {id: a.id, type: "raster", source: a.id},
            source: {type: "raster", tiles: a.url, tileSize: 256}
        }
    },
    getTileUrl: function () {
        return this.url
    },
    clone: function (a) {
        a == null && (a = new GeoGlobe.Layer.WMS_(this.id, this.tileSize, this.filter, this.opacity, this.visible, this.maxZoom, this.minZoom, this.name, this.url));
        return a
    },
    CLASS_NAME: "GeoGlobe.Layer.WMS_"
});
GeoGlobe.Layer.WMTS_ = GeoGlobe.Class(GeoGlobe.Layer, {
    id: null,
    name: null,
    matrixSet: null,
    matrixIds: null,
    tileFullExtent: null,
    tileSize: 256,
    url: null,
    filter: null,
    opacity: 0,
    visible: !0,
    initialize: function (a) {
        a = {
            id: a.id,
            layer: {id: a.id, type: "raster", source: a.id},
            source: {type: "raster", tiles: a.url, tileSize: 256}
        };
        if (this.matrixIds) {
            var b = this.matrixIds.length;
            if (b && typeof this.matrixIds[0] === "string") {
                var c = this.matrixIds;
                this.matrixIds = Array(b);
                for (var d = 0; d < b; ++d)this.matrixIds[d] = {identifier: c[d]}
            }
        }
        return a
    },
    getTileUrl: function () {
        return this.url
    },
    clone: function (a) {
        a == null && (a = new GeoGlobe.Layer.WMTS_(this.id, this.tileSize, this.filter, this.opacity, this.visible, this.name, this.url));
        return a
    },
    getMatrix: function () {
        var a;
        if (!this.matrixIds || this.matrixIds.length === 0) a = {identifier: this.getIdentifier()}; else if ("scaleDenominator" in this.matrixIds[0])for (var b = OpenLayers.METERS_PER_INCH * OpenLayers.INCHES_PER_UNIT[this.units] * this.getServerResolution() / 2.8E-4, c = Number.POSITIVE_INFINITY, d, e = 0, f = this.matrixIds.length; e <
        f; ++e)d = Math.abs(1 - this.matrixIds[e].scaleDenominator / b), d < c && (c = d, a = this.matrixIds[e]); else a = this.matrixIds[this.getIdentifier()];
        return a
    },
    CLASS_NAME: "GeoGlobe.Layer.WMTS_"
});
GeoGlobe.Layer.GeoTileLayer = GeoGlobe.Class(GeoGlobe.Layer, {
    id: null,
    tileSize: 256,
    url: null,
    minzoom: null,
    maxzoom: null,
    serviceName: null,
    accessUrl: null,
    initialize: function (a) {
        this.url = a.url;
        var b = [], c;
        this.extent = a.maxextent;
        (function (a) {
            var c = a.split("/services/");
            c[0] && c[1] ? (b.push(c[0] + "/DataServer"), b.push(c[1])) : alert("\u89e3\u6790\u670d\u52a1\u5730\u5740\u9519\u8bef:" + a)
        })(this.url);
        (function (a) {
            c = a.split(",");
            for (a = 0; a < c.length; a++)c[a] = parseInt(c[a])
        })(this.extent);
        return {
            id: a.id,
            name: a.name,
            type: a.type,
            source: {type: a.type, tiles: [b[0] + "?T=" + b[1] + "&X={x}&Y={y}&L={z}"], tileSize: a.tileSize},
            maxzoom: parseInt(a.maxzoom),
            minzoom: parseInt(a.minzoom),
            paint: {"raster-opacity": a.opacity == null ? 1 : a.opacity},
            layout: {visibility: a.visibility == null ? "visible" : a.visibility}
        }
    },
    convertUrl: function (a) {
        var b = a.split("/services/");
        b[0] && b[1] ? (this.accessUrl = b[0] + "/DataServer", this.serviceName = b[1]) : OpenLayers.Console.error("\u89e3\u6790\u670d\u52a1\u5730\u5740\u9519\u8bef:" + a)
    },
    selectUrl: function (a, b) {
        return b[a % b.length]
    },
    getDataExtent: function () {
        if (this.maxExtent)return this.maxExtent.clone()
    },
    clone: function (a) {
        return a = new GeoGlobe.Layer.GeoTileLayer(this.name, this.url, this.options)
    },
    CLASS_NAME: "GeoGlobe.Layer.GeoTileLayer"
});
GeoGlobe.Layer.GeoWMTSLayer = GeoGlobe.Class(GeoGlobe.Layer.WMTS, {
    id: null,
    name: null,
    matrixSet: null,
    matrixIds: null,
    tileFullExtent: null,
    tileSize: 256,
    url: null,
    filter: null,
    opacity: 0,
    visible: !0,
    time: "9999-01-01 00:00:00",
    userecent: !0,
    initialize: function (a) {
        return {
            id: a.id,
            type: a.type,
            source: {type: a.type, tiles: [a.url], tileSize: a.tileSize},
            maxzoom: parseInt(a.maxzoom),
            minzoom: parseInt(a.minzoom)
        }
    },
    setVerstionTime: function (a) {
        if (a) this.time = this.params.time = a, this.redraw()
    },
    setParams: function (a) {
        if (a.time) this.time =
            this.params.time = a.time, a = typeof a.userecent == "boolean" ? a.userecent : !0, this.userecent = this.params.USERECENT = a, this.redraw()
    },
    clone: function (a) {
        a == null && (a = new GeoGlobe.Layer.GeoWMTSLayer(this.options));
        new GeoGlobe.Layer.GeoWMTSLayer(this.options);
        return a
    },
    CLASS_NAME: "GeoGlobe.Layer.GeoWMTSLayer"
});
GeoGlobe.Layer.VectorTile = GeoGlobe.Class(GeoGlobe.Layer, {
    id: null,
    name: null,
    url: null,
    filter: null,
    opacity: 0,
    visible: !0,
    maxZoom: 20,
    minZoom: 0,
    initialize: function (a) {
        return a
    },
    getTileUrl: function () {
        return this.url
    },
    clone: function (a) {
        a == null && (a = new GeoGlobe.Layer.VectorTile(this.id, this.tileSize, this.filter, this.opacity, this.visible, this.maxZoom, this.minZoom, this.name, this.url));
        return a
    },
    CLASS_NAME: "GeoGlobe.Layer.VectorTile"
});
GeoGlobe.Layer.RasterLayer = GeoGlobe.Class(GeoGlobe.Layer, {
    "raster-opacity": null,
    "raster-hue-rotate": null,
    "raster-brightness-min": null,
    "raster-brightness-max": null,
    "raster-saturation": null,
    "raster-contrast": null,
    "raster-fade-duration": null,
    initialize: function (a) {
        return a
    },
    CLASS_NAME: "GeoGlobe.Layer.RasterLayer"
});
GeoGlobe.Layer.FillLayer = GeoGlobe.Class(GeoGlobe.Layer, {
    "fill-color": null,
    "fill-pattern": null,
    "fill-opacity": null,
    "fill-antialias": null,
    "fill-outline-color": null,
    "fill-translate": null,
    "fill-translate-anchor": null,
    initialize: function (a) {
        return a
    },
    CLASS_NAME: "GeoGlobe.Layer.FillLayer"
});
GeoGlobe.Layer.CircleLayer = GeoGlobe.Class(GeoGlobe.Layer, {
    "circle-radius": null,
    "circle-color": null,
    "circle-blur": null,
    "circle-opacity": null,
    "circle-pitch-scale": null,
    "circle-translate": null,
    "circle-translate-anchor": null,
    initialize: function (a) {
        return a
    },
    CLASS_NAME: "GeoGlobe.Layer.CircleLayer"
});
GeoGlobe.Layer.SymbolLayer = GeoGlobe.Class(GeoGlobe.Layer, {
    visibility: null,
    "symbol-placement": null,
    "symbol-spacing": null,
    "symbol-avoid-edges": null,
    "icon-allow-overlap ": null,
    "icon-ignore-placement": null,
    "icon-optional": null,
    "icon-rotation-alignment": null,
    "icon-size": null,
    "icon-text-fit": null,
    "icon-text-fit-padding": null,
    "icon-image": null,
    "icon-rotate": null,
    "icon-padding": null,
    "icon-offset": null,
    "icon-keep-upright": null,
    "text-pitch-alignment": null,
    "text-rotate-alignment": null,
    "text-field": null,
    "text-font": null,
    "text-size": null,
    "text-max-width": null,
    "text-line-height": null,
    "text-letter-spacing": null,
    "text-justify": null,
    "text-anchor": null,
    "text-max-angle": null,
    "text-rotate": null,
    "text-padding": null,
    "text-keep-upright": null,
    "text-offset": null,
    "text-transform": null,
    "text-allow-overlap ": null,
    "text-ignore-placement": null,
    "text-optional": null,
    "icon-color": null,
    "icon-halo-color": null,
    "icon-opacity": null,
    "icon-halo-width": null,
    "icon-halo-blur": null,
    "icon-translate ": null,
    "icon-translate-anchor": null,
    "text-color": null,
    "text-halo-color": null,
    "text-opacity": null,
    "text-halo-width": null,
    "text-halo-blur": null,
    "text-translate ": null,
    "text-translate-anchor": null,
    initialize: function (a) {
        return a
    },
    CLASS_NAME: "GeoGlobe.Layer.SymbolLayer"
});
GeoGlobe.Layer.FillExtrusionLayer = GeoGlobe.Class(GeoGlobe.Layer, {
    "fill-extrusion-height": null,
    "fill-extrusion-pattern": null,
    "fill-extrusion-color": null,
    "fill-extrusion-base": null,
    "fill-extrusion-opacity": null,
    "fill-extrusion-translate": null,
    "fill-extrusion-translate-anchor": null,
    initialize: function (a) {
        return a
    },
    CLASS_NAME: "GeoGlobe.Layer.FillExtrusionLayer"
});
GeoGlobe.Layer.LineLayer = GeoGlobe.Class(GeoGlobe.Layer, {
    "line-color": null,
    "line-pattern": null,
    "line-opacity": null,
    "line-translate": null,
    "line-translate-anchor": null,
    "line-cap": null,
    "line-join": null,
    "line-miter-limit": null,
    "line-round-limit": null,
    "line-width": null,
    "line-gap-width": null,
    "line-offset": null,
    "line-blur": null,
    "line-dasharray": null,
    initialize: function (a) {
        return a
    },
    CLASS_NAME: "GeoGlobe.Layer.LineLayer"
});
GeoGlobe.Layer.BackgroundLayer = GeoGlobe.Class(GeoGlobe.Layer, {
    "background-color": null,
    "background-pattern": null,
    "background-opacity": null,
    initialize: function (a) {
        return a
    },
    CLASS_NAME: "GeoGlobe.Layer.BackgroundLayer"
});
GeoGlobe.Layer.ThematicTileLayer = GeoGlobe.Class4OL(GeoGlobe.Layer, {
    map: null,
    version: "1.0.0",
    id: null,
    layerID: null,
    chartID: null,
    maxExtent: null,
    format: "png",
    colorSchemeID: null,
    hasLegend: !1,
    legendType: 0,
    legendPosition: "br",
    hasEdge: !1,
    hasLabel: !1,
    hasBaseMap: !1,
    hasBaseMapLegend: !1,
    baseMapExampleColumnNums: 2,
    initialize: function (a, b) {
        var c = b.box, d = c._ne.lng, e = c._ne.lat, f = c._sw.lng, c = c._sw.lat, g = b.params;
        this.map = a;
        this.options = b;
        GeoGlobe.Function.bind(this.seturl, this);
        g = this.seturl(g);
        this.layer = {
            id: this.options.id,
            source: {
                type: "image",
                url: this.options.url + "/map/" + this.options.layerID + "/" + this.options.chartID + "/" + f + "/" + c + "/" + d + "/" + e + "/" + this.options.width + "/" + this.options.height + ".png?" + g,
                coordinates: [[f, e], [d, e], [d, c], [f, c]]
            }, type: "raster"
        };
        this.zoome = $.proxy(this.zoomend, this);
        this.drage = $.proxy(this.dragend, this);
        this.map.on("zoomend", this.zoome);
        this.map.on("dragend", this.drage);
        GeoGlobe.Function.bind(this.remove, this);
        return this
    },
    zoomend: function () {
        if (this.map.style._layers[this.options.id] && this.map.style._layers[this.options.id].layout.visibility !=
            "none") {
            var a = this.map.style._layers[this.options.id].metadata, b = this.map.style._layers[this.options.id].paint,
                c = this.map.style._layers[this.options.id].layout;
            this.map.removeLayer(this.options.id);
            this.map.removeSource(this.options.id);
            box = this.map.getBounds();
            var d = this.options.params;
            maxx = box._ne.lng;
            maxy = box._ne.lat;
            minx = box._sw.lng;
            miny = box._sw.lat;
            d = this.seturl(d);
            url = this.options.url + "/map/" + this.options.layerID + "/" + this.options.chartID + "/" + minx + "/" + miny + "/" + maxx + "/" + maxy + "/" + this.options.width +
                "/" + this.options.height + ".png?" + d;
            layer = {
                id: this.options.id,
                name: this.options.name,
                source: {
                    type: "image",
                    url: url,
                    coordinates: [[minx, maxy], [maxx, maxy], [maxx, miny], [minx, miny]]
                },
                type: "raster"
            };
            layer.paint = b;
            layer.layout = c;
            layer.metadata = a;
            this.map.addLayer(layer)
        }
    },
    dragend: function () {
        if (this.map.style._layers[this.options.id] && this.map.style._layers[this.options.id].layout.visibility != "none") {
            var a = this.map.style._layers[this.options.id].metadata, b = this.map.style._layers[this.options.id].paint,
                c = this.map.style._layers[this.options.id].layout;
            this.map.removeLayer(this.options.id);
            this.map.removeSource(this.options.id);
            box = this.map.getBounds();
            var d = this.options.params;
            maxx = box._ne.lng;
            maxy = box._ne.lat;
            minx = box._sw.lng;
            miny = box._sw.lat;
            d = this.seturl(d);
            url = this.options.url + "/map/" + this.options.layerID + "/" + this.options.chartID + "/" + minx + "/" + miny + "/" + maxx + "/" + maxy + "/" + this.options.width + "/" + this.options.height + ".png?" + d;
            layer = {
                id: this.options.id, name: this.options.name, source: {
                    type: "image", url: url, coordinates: [[minx, maxy], [maxx, maxy], [maxx,
                        miny], [minx, miny]]
                }, type: "raster"
            };
            layer.paint = b;
            layer.layout = c;
            layer.metadata = a;
            this.map.addLayer(layer)
        }
    },
    seturl: function (a) {
        var b = "", c;
        for (c in a)a[c] != -1 && (b += c + "=" + a[c] + "&");
        return b = b.substring(0, b.length - 1)
    },
    getCapabilities: function (a, b, c) {
        typeof c != "function" && (c = function () {
            alert("\u4e13\u9898\u56fe\u670d\u52a1\u8bf7\u6c42\u5931\u8d25\uff0c\u8bf7\u68c0\u67e5\u670d\u52a1\u662f\u5426\u6b63\u5e38\u8fd0\u884c\u6216\u8bf7\u6c42\u5730\u5740\u662f\u5426\u6b63\u786e\u3002\n\u8bf7\u6c42\u5730\u5740\uff1a" +
                a + "\n\u64cd\u4f5c\u7c7b\u578b\uff1aGetCapabilities")
        });
        $.ajax({
            url: a, dataType: "json", cache: !1, async: !1, success: function (a) {
                typeof b == "function" && b(a)
            }, failure: c
        })
    },
    remove: function (a) {
        this.map.off("zoomend", this.zoome);
        this.map.off("dragend", this.drage);
        this.map.removeLayer(a);
        this.map.removeSource(a)
    },
    showLegend: function () {
        var a = this.getLegend({
            layerID: this.layerID,
            chartID: this.chartID,
            colorSchemeID: this.colorSchemeID,
            drawLegend: "ThematicMap",
            legendType: this.legendType
        });
        this.imageLegend || (new GeoGlobe.Marker(a)).setLngLat([lnglat.lng,
            lnglat.lat]).addTo(this.map)
    },
    getLegend: function (a) {
        if (this.url.indexOf("/", this.url.length - 1) != -1) this.url = this.url.substr(0, this.url.length - 1);
        var b;
        b = Geo.String.format("${url}/legend/${layerID}/${chartID}.${format}?drawLegend=${drawLegend}&legendType=${legendType}", {
            url: this.url,
            layerID: a.layerID,
            chartID: a.chartID,
            format: a.format || "png",
            drawLegend: a.drawLegend,
            legendType: a.legendType
        });
        typeof a.colorSchemeID === "string" && (b += "&ColorSchemeID=" + a.colorSchemeID);
        return b
    },
    setLegendLocation: function (a) {
        var b =
            this.map.getSize();
        switch (this.legendPosition) {
            case "br":
                var c = b.w - this.legendSize.w, b = b.h - this.legendSize.h;
                a.style.left = c + "px";
                a.style.top = b + "px";
                break;
            case "bl":
                b = b.h - this.legendSize.h;
                a.style.left = "0px";
                a.style.top = b + "px";
                break;
            case "tl":
                a.style.left = "0px";
                a.style.top = "0px";
                break;
            case "tr":
                c = b.w - this.legendSize.w, a.style.left = c + "px", a.style.top = "0px"
        }
    },
    showBaseMapLegend: function () {
        var a = this.getBaseMapLegend({
            layerID: this.layerID,
            chartID: this.chartID,
            drawLegend: "BaseMap",
            baseMapExampleColumnNums: this.baseMapExampleColumnNums
        });
        this.imageBaseMapLegend || (new GeoGlobe.Marker(a)).setLngLat([lnglat.lng, lnglat.lat]).addTo(this.map)
    },
    getBaseMapLegend: function (a) {
        if (this.url.indexOf("/", this.url.length - 1) != -1) this.url = this.url.substr(0, this.url.length - 1);
        return a = Geo.String.format("${url}/legend/${layerID}/${chartID}.${format}?drawLegend=${drawLegend}&baseMapExampleColumnNums=${baseMapExampleColumnNums}", {
            url: this.url,
            layerID: a.layerID,
            chartID: a.chartID,
            format: a.format || "png",
            drawLegend: a.drawLegend,
            baseMapExampleColumnNums: a.baseMapExampleColumnNums
        })
    },
    setBaseMapLegendLocation: function (a) {
        var b = this.map.getSize();
        switch (this.baseMapLegendPosition) {
            case "br":
                var c = b.w - this.baseMapLegendSize.w, b = b.h - this.baseMapLegendSize.h;
                a.style.left = c + "px";
                a.style.top = b + "px";
                break;
            case "bl":
                b = b.h - this.baseMapLegendSize.h;
                a.style.left = "0px";
                a.style.top = b + "px";
                break;
            case "tl":
                a.style.left = "50px";
                a.style.top = "0px";
                break;
            case "tr":
                c = b.w - this.baseMapLegendSize.w, a.style.left = c + "px", a.style.top = "0px"
        }
    },
    updateHotArea: function (a) {
        a.zoomChanged ? this.vectorLayer.removeAllFeatures() :
            this.vectorLayer.redraw()
    },
    clone: function (a) {
        a == null && (a = new GeoGlobe.Layer.ThematicTileLayer(this.id, this.url, this.params, this.getOptions()));
        return a
    },
    getURL: function (a) {
        var a = this.adjustBounds(a), b = this.getImageSize(),
            a = GeoGlobe.String.format("${url}/map/${layerID}/${chartID}/${left}/${bottom}/${right}/${top}/${width}/${height}.${format}?hasLegend=${hasLegend}&legendType=${legendType}&hasEdge=${hasEdge}&hasLabel=${hasLabel}&hasBaseMap=${hasBaseMap}&hasBaseMapLegend=${hasBaseMapLegend}&baseMapExampleColumnNums=${baseMapExampleColumnNums}",
                {
                    url: this.url,
                    layerID: this.layerID,
                    chartID: this.chartID,
                    left: a.left,
                    bottom: a.bottom,
                    right: a.right,
                    top: a.top,
                    width: b.w,
                    height: b.h,
                    format: this.format,
                    hasLegend: this.hasLegend,
                    legendType: this.legendType,
                    hasEdge: this.hasEdge,
                    hasLabel: this.hasLabel,
                    hasBaseMap: this.hasBaseMap,
                    hasBaseMapLegend: this.hasBaseMapLegend,
                    baseMapExampleColumnNums: this.baseMapExampleColumnNums
                });
        typeof this.colorSchemeID === "string" && (a += "&ColorSchemeID=" + this.colorSchemeID);
        return a
    },
    CLASS_NAME: "GeoGlobe.Layer.ThematicTileLayer"
});
GeoGlobe.CanvasLayer = GeoGlobe.Class4OL({
    map: null, context: null, initialize: function (a) {
        this.id = GeoGlobe.Util.createUniqueID(this.CLASS_NAME + "_");
        this.options = a
    }, drawOnMove: null, _drawLayer: function () {
        this.clear();
        var a = this._prepareDrawParams();
        a && this.draw.apply(this, a)
    }, _prepareDrawParams: function () {
        var a = [];
        if (!this._drawContext) this._drawContext = this.prepareToDraw.apply(this, [this.context].concat(a));
        a = [this.context];
        a.push.apply(a, this._drawContext);
        return a
    }, prepareToDraw: function () {
    }, draw: function () {
    },
    addTo: function (a) {
        this.map = a;
        var b = a.getCanvasContainer();
        this.canvas = document.createElement("canvas");
        this.canvas.id = this.id;
        this.canvas.style.width = a.getCanvas().style.width;
        this.canvas.style.height = a.getCanvas().style.height;
        this.canvas.style.position = "absolute";
        this.canvas.style.display = "none";
        this.canvas.width = a.getCanvas().width;
        this.canvas.height = a.getCanvas().height;
        b.appendChild(this.canvas);
        this.context = this.canvas.getContext("2d");
        this._bindEvent();
        var c = {
            type: "canvas", canvas: this.canvas.id,
            contextType: "2d", animate: !0, coordinates: this._boundsToCoordinates(a.getBounds())
        }, d = {id: this.id + "_layer", source: this.id, type: "raster", paint: {"raster-opacity": 1}};
        a.addSource(this.id, c);
        a.addLayer(d);
        this.source = a.getSource(this.id);
        this.layer = a.getLayer(this.id + "_layer");
        b.removeChild(this.canvas);
        this._drawLayer()
    }, _bindEvent: function () {
        var a = this.map;
        this._move = GeoGlobe.Function.bind(function (a) {
            typeof this.drawOnMove === "function" && this.drawOnMove(a)
        }, this);
        this._moveend = GeoGlobe.Function.bind(function (a) {
            this.source.setCoordinates(this._boundsToCoordinates(a.target.getBounds()));
            this._drawLayer()
        }, this);
        a.on("move", this._move);
        a.on("moveend", this._moveend)
    }, pause: function () {
        this.source.pause()
    }, play: function () {
        this.source.play()
    }, setOpacity: function (a) {
        this.map.setPaintProperty(this.layer.id, "raster-opacity", parseFloat(a))
    }, clear: function () {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height)
    }, remove: function () {
        this.clear();
        var a = this.map;
        a.off("move", this._move);
        a.off("moveend", this._moveend);
        a.removeSource(this.source.id);
        a.removeLayer(this.layer.id);
        this.map =
            this.canvas = null
    }, _boundsToCoordinates: function (a) {
        var b = a.toArray(), a = b[0][0], c = b[0][1], d = b[1][0], b = b[1][1];
        return [[a, b], [d, b], [d, c], [a, c]]
    }, CLASS_NAME: "GeoGlobe.CanvasLayer"
});
GeoGlobe.TDTLayer = GeoGlobe.Class4OL({
    initialize: function (a) {
        return this._getLayer(a)
    }, _getLayer: function (a) {
        var b = "tdt_" + a + "_" + GeoGlobe.Util.randomStr(8), a = GeoGlobe.ProxyHost + this._getUrlTemplateByName(a);
        return {id: b, type: "raster", source: {type: "raster", tiles: [a], tileSize: 256}}
    }, _getUrlTemplateByName: function (a) {
        return "http://t0.tianditu.com/" + a + "/wmts?" + this._getParameterString(this.tdtParams[a])
    }, tdtParams: {
        vec_w: {
            SERVICE: "WMTS", REQUEST: "GetTile", LAYER: "vec", TILEMATRIXSET: "w", FORMAT: "tiles", VERSION: "1.0.0",
            STYLE: "default", TILEMATRIX: "{z}", TILEROW: "{y}", TILECOL: "{x}"
        },
        cva_w: {
            SERVICE: "WMTS",
            REQUEST: "GetTile",
            LAYER: "cva",
            TILEMATRIXSET: "w",
            FORMAT: "tiles",
            VERSION: "1.0.0",
            STYLE: "default",
            TILEMATRIX: "{z}",
            TILEROW: "{y}",
            TILECOL: "{x}"
        },
        vec_c: {
            SERVICE: "WMTS",
            REQUEST: "GetTile",
            LAYER: "vec",
            TILEMATRIXSET: "c",
            FORMAT: "tiles",
            VERSION: "1.0.0",
            STYLE: "default",
            TILEMATRIX: "{z}",
            TILEROW: "{y}",
            TILECOL: "{x}"
        },
        cva_c: {
            SERVICE: "WMTS",
            REQUEST: "GetTile",
            LAYER: "cva",
            TILEMATRIXSET: "c",
            FORMAT: "tiles",
            VERSION: "1.0.0",
            STYLE: "default",
            TILEMATRIX: "{z}",
            TILEROW: "{y}",
            TILECOL: "{x}"
        },
        img_w: {
            SERVICE: "WMTS",
            REQUEST: "GetTile",
            LAYER: "img",
            TILEMATRIXSET: "w",
            FORMAT: "tiles",
            VERSION: "1.0.0",
            STYLE: "default",
            TILEMATRIX: "{z}",
            TILEROW: "{y}",
            TILECOL: "{x}"
        },
        cia_w: {
            SERVICE: "WMTS",
            REQUEST: "GetTile",
            LAYER: "cia",
            TILEMATRIXSET: "w",
            FORMAT: "tiles",
            VERSION: "1.0.0",
            STYLE: "default",
            TILEMATRIX: "{z}",
            TILEROW: "{y}",
            TILECOL: "{x}"
        },
        img_c: {
            SERVICE: "WMTS",
            REQUEST: "GetTile",
            LAYER: "img",
            TILEMATRIXSET: "c",
            FORMAT: "tiles",
            VERSION: "1.0.0",
            STYLE: "default",
            TILEMATRIX: "{z}",
            TILEROW: "{y}",
            TILECOL: "{x}"
        },
        cia_c: {
            SERVICE: "WMTS",
            REQUEST: "GetTile",
            LAYER: "cia",
            TILEMATRIXSET: "c",
            FORMAT: "tiles",
            VERSION: "1.0.0",
            STYLE: "default",
            TILEMATRIX: "{z}",
            TILEROW: "{y}",
            TILECOL: "{x}"
        }
    }, _getParameterString: function (a) {
        var b = [], c;
        for (c in a) {
            var d = a[c];
            d != null && typeof d != "function" && b.push(c.toUpperCase() + "=" + d)
        }
        return b.join("&")
    }, CLASS_NAME: "GeoGlobe.TDTLayer"
});
GeoGlobe.Layer.HotArea = GeoGlobe.Class4OL({
    url: null,
    layer: null,
    format: null,
    matrixSet: null,
    style: null,
    version: "1.0.0",
    name: null,
    layerid: null,
    hotareaLayers: null,
    hotareaHighlightedLayers: null,
    tileUrls: null,
    initialize: function (a) {
        this.name = a.name ? a.name : null;
        this.url = a.url;
        this.layer = a.layer;
        this.format = a.format;
        this.matrixSet = a.matrixSet;
        this.style = a.style;
        this.layerid = "geoglobe_layer_hotarea_" + GeoGlobe.Util.randomStr(8);
        this.layerOption = {
            id: this.layerid, type: "raster", source: {
                type: "raster",
                rasterType: "hotarea",
                tiles: [GeoGlobe.appendToProxy(a.url + "?SERVICE=WMTS&REQUEST=GetTile&LAYER=" + this.layer + "&TILEMATRIXSET=" + this.matrixSet + "&FORMAT=" + this.format + "&VERSION=" + this.version + "&STYLE=" + this.style + "&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}")],
                tileSize: 256
            }, paint: {"raster-opacity": 1}, metadata: {type: "hotarea"}
        };
        this.hotareaLayers = [];
        this.hotareaHighlightedLayers = [];
        this.tileUrls = [];
        this.onclick = typeof a.onclick === "function" ? a.onclick : this.onclick
    },
    addTo: function (a) {
        this.map = a;
        a.addLayer(this.layerOption);
        this._bindEvent()
    },
    _bindEvent: function () {
        var a = this.map;
        GeoGlobe.Layer.HotArea["callback_tileJSON_" + this.layerid] = GeoGlobe.Function.bind(this.callback_tile, this);
        var b = GeoGlobe.Function.bind(function (b) {
            for (var d = [[b.point.x - 2, b.point.y - 2], [b.point.x + 2, b.point.y + 2]], e = [], f = 0; f < this.hotareaLayers.length; f++)e.push(this.hotareaLayers[f].id);
            d = a.queryRenderedFeatures(d, {layers: e});
            d.length > 0 ? (d = [d[0]], this.map.getCanvas().style.cursor = "pointer") : this.map.getCanvas().style.cursor = "";
            e = d.reduce(function (a, b) {
                a.push(b.properties.displayname);
                return a
            }, ["==", "displayname"]);
            e = e.length === 2 ? ["==", "displayname", ""] : e;
            for (f = 0; f < this.hotareaHighlightedLayers.length; f++)a.setFilter(this.hotareaHighlightedLayers[f].id, e);
            if (b.type === "click") b.features = d, this.onclick(b)
        }, this);
        a.on("click", b);
        a.on("mousemove", b);
        b = GeoGlobe.Function.bind(function () {
            for (var b = 0; b < this.hotareaHighlightedLayers.length; b++)a.removeLayer(this.hotareaHighlightedLayers[b].id);
            this.hotareaHighlightedLayers = [];
            for (b = 0; b < this.hotareaLayers.length; b++)a.removeLayer(this.hotareaLayers[b].id),
                a.removeSource(this.hotareaLayers[b].id);
            this.hotareaLayers = [];
            this.tileUrls = []
        }, this);
        a.on("zoomstart", b)
    },
    callback_tile: function (a) {
        for (var b = a.tileUrl, c = !1, d = 0; d < this.tileUrls.length; d++)this.tileUrls[d] === b && (c = !0);
        if (!c) {
            this.tileUrls.push(b);
            b = a.data;
            c = b.features;
            for (d = 0; d < c.length; d++) {
                var e = c[d].properties.picsymid;
                c[d].properties.overPicUrl = this.getPicURL(e, !0);
                c[d].properties.outPicUrl = this.getPicURL(e, !1)
            }
            a = a.map;
            d = GeoGlobe.Util.randomStr(8);
            b = {
                id: "hotarea_id_" + d, type: "fill", source: {
                    type: "geojson",
                    data: b
                }, paint: {"fill-color": "#088", "fill-opacity": 0}
            };
            a.addLayer(b);
            this.hotareaLayers.push(b);
            d = {
                id: "hotarea_highlighted_id_" + d,
                type: "fill",
                source: b.id,
                paint: {"fill-outline-color": "#484896", "fill-color": "#6e599f", "fill-opacity": 0},
                filter: ["==", "displayname", ""]
            };
            a.addLayer(d);
            this.hotareaHighlightedLayers.push(d)
        }
    },
    getPicURL: function (a, b) {
        return this.url + "?" + this._getParameterString({
                SERVICE: "WMTS",
                REQUEST: "GetIcon",
                VERSION: this.version,
                LAYER: this.layer,
                PICID: a,
                ISANTI: b
            })
    },
    _getParameterString: function (a) {
        var b =
            [], c;
        for (c in a) {
            var d = a[c];
            d != null && typeof d != "function" && b.push(c.toUpperCase() + "=" + d)
        }
        return b.join("&")
    },
    onclick: function () {
    },
    CLASS_NAME: "GeoGlobe.Layer.HotArea"
});
GeoGlobe.Source = GeoGlobe.Class(mapboxgl.FreeCRSMap, {
    SourceId: null, initialize: function () {
        return this
    }, CLASS_NAME: "GeoGlobe.Source"
});
GeoGlobe.Source.GeoJSONSource = GeoGlobe.Class(mapboxgl.FreeCRSMap, {
    minzoom: null,
    maxzoom: null,
    data: null,
    buffer: null,
    tolerance: null,
    cluster: null,
    clusterRadius: null,
    clusterMaxZoom: null,
    initialize: function (a, b) {
        var c = {};
        c.id = a;
        c.source = b;
        return c
    },
    CLASS_NAME: "GeoGlobe.Source.GeoJSONSource"
});
GeoGlobe.Source.RasterSource = GeoGlobe.Class(mapboxgl.FreeCRSMap, {
    minzoom: null,
    maxzoom: null,
    tilesUrl: null,
    url: null,
    tileSize: null,
    initialize: function (a) {
        return {id: a.id, type: "raster", tiles: a.url, tileSize: 256}
    },
    CLASS_NAME: "GeoGlobe.Source.RasterSource"
});
GeoGlobe.Source.ImageSource = GeoGlobe.Class(mapboxgl.FreeCRSMap, {
    coordinates: null,
    url: null,
    initialize: function (a, b) {
        var c = {};
        c.id = a;
        c.source = b;
        return c
    },
    CLASS_NAME: "GeoGlobe.Source.ImageSource"
});
GeoGlobe.Source.VectorSource = GeoGlobe.Class(mapboxgl.FreeCRSMap, {
    minzoom: null,
    maxzoom: null,
    tilesUrl: null,
    url: null,
    initialize: function (a) {
        return {id: a.id, type: a.type, tiles: a.url}
    },
    CLASS_NAME: "GeoGlobe.Source.VectorSource"
});
GeoGlobe.Source.VideoSource = GeoGlobe.Class(mapboxgl.FreeCRSMap, {
    coordinates: null,
    url: null,
    initialize: function (a, b) {
        var c = {};
        c.id = a;
        c.video = b;
        return c
    },
    CLASS_NAME: "GeoGlobe.Source.VideoSource"
});
GeoGlobe.Marker = GeoGlobe.Class(mapboxgl.Marker, {
    offset: null, initialize: function (a, b) {
        return this.Marker = new mapboxgl.Marker(a, b)
    }, addTo: function (a) {
        this.Marker.addTo(a)
    }, remove: function () {
        this.Marker.remove()
    }, getLngLat: function () {
        return this.Marker.getLngLat()
    }, setLngLat: function (a) {
        this.Marker.setLngLat(a)
    }, setPopup: function (a) {
        this.Marker.setPopup([a])
    }, getPopup: function () {
        this.Marker.getPopup()
    }, togglePopup: function () {
        this.Marker.togglePopup()
    }, CLASS_NAME: "GeoGlobe.Marker"
});
GeoGlobe.Popup = GeoGlobe.Class(mapboxgl.Popup, {
    closeButton: !0, closeOnClick: !0, anchor: null, offset: null, showArrow: !0, initialize: function (a) {
        return this.Popup = new mapboxgl.Popup(a)
    }, addTo: function (a) {
        this.Popup.addTo(a)
    }, isOpen: function () {
        return this.Popup.isOpen()
    }, remove: function () {
        this.Popup.remove()
    }, getLngLat: function () {
        return this.Popup.getLngLat()
    }, setLngLat: function (a) {
        this.Popup.setLngLat(a)
    }, setText: function (a) {
        this.Popup.setText(a)
    }, setHTML: function (a) {
        this.Popup.setHTML(a)
    }, setDOMContent: function (a) {
        this.Popup.setDOMContent(a)
    },
    CLASS_NAME: "GeoGlobe.Popup"
});
GeoGlobe.Control = GeoGlobe.Class(mapboxgl.Control, {
    position: null, initialize: function (a) {
        return this.control = new mapboxgl.Control(a)
    }, addTo: function (a) {
        this.control.addTo(a)
    }, remove: function () {
        this.control.remove()
    }, CLASS_NAME: "GeoGlobe.Control"
});
GeoGlobe.Control.Navigation = GeoGlobe.Class(GeoGlobe.Control, {
    position: null, initialize: function () {
        return this.control = new mapboxgl.NavigationControl
    }, CLASS_NAME: "GeoGlobe.Control.Navigation"
});
GeoGlobe.Control.Attribution = GeoGlobe.Class(GeoGlobe.Control, {
    position: null, initialize: function (a) {
        return this.control = new mapboxgl.AttributionControl({position: a.position, map_attr: a.map_attr})
    }, CLASS_NAME: "GeoGlobe.Control.Attribution"
});
GeoGlobe.Control.Scale = GeoGlobe.Class4OL({
    initialize: function (a) {
        this.options = a;
        mapboxgl.util.bindAll(["_onMove"], this)
    }, getDefaultPosition: function () {
        return "bottom-left"
    }, _onMove: function () {
        this._updateScale(this._map, this._container, this.options)
    }, onAdd: function (a) {
        this._map = a;
        this._container = GeoGlobe.DOM.create("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", a.getContainer());
        this._map.on("move", this._onMove);
        this._onMove();
        return this._container
    }, onRemove: function () {
        this._container.parentNode.removeChild(this._container);
        this._map.off("move", this._onMove);
        this._map = void 0
    }, _updateScale: function (a, b, c) {
        var d = c && c.maxWidth || 100, e = a._container.clientHeight / 2,
            a = this._getDistance(a.unproject([0, e]), a.unproject([d, e]));
        c && c.unit === "imperial" ? (c = 3.2808 * a, c > 5280 ? this._setScale(b, d, c / 5280, "mi") : this._setScale(b, d, c, "ft")) : this._setScale(b, d, a, "m")
    }, _setScale: function (a, b, c, d) {
        var e = this._getRoundNum(c), c = e / c;
        d === "m" && e >= 1E3 && (e /= 1E3, d = "km");
        a.style.width = b * c + "px";
        a.innerHTML = e + d
    }, _getDistance: function (a, b) {
        var c = null;
        if (this._map.units ===
            "m") c = b.lng - a.lng; else var c = Math.PI / 180, d = a.lat * c, e = b.lat * c,
            c = 6371E3 * Math.acos(Math.min(Math.sin(d) * Math.sin(e) + Math.cos(d) * Math.cos(e) * Math.cos((b.lng - a.lng) * c), 1));
        return c
    }, _getRoundNum: function (a) {
        var b = Math.pow(10, ("" + Math.floor(a)).length - 1);
        a /= b;
        return b * (a >= 10 ? 10 : a >= 5 ? 5 : a >= 3 ? 3 : a >= 2 ? 2 : 1)
    }, CLASS_NAME: "GeoGlobe.Control.Scale"
});
GeoGlobe.Control.Geolocate = GeoGlobe.Class(GeoGlobe.Control, {
    position: null, initialize: function (a) {
        return this.control = new mapboxgl.GeolocateControl({position: a.position, point: a.point})
    }, CLASS_NAME: "GeoGlobe.Control.Geolocate"
});
GeoGlobe.Control.MapContextMenu = GeoGlobe.Class4OL({
    menuDiv: null, className: null, contentHTML: null, lngLat: null, point: null, initialize: function (a) {
        GeoGlobe.Util.extend(this, a)
    }, getDefaultPosition: function () {
        return "top-left"
    }, onAdd: function (a) {
        this._map = a;
        this._onContextMenu = GeoGlobe.Function.bind(this._showContextMenu, this);
        this._map.on("contextmenu", this._onContextMenu);
        this._onMouseDown = GeoGlobe.Function.bind(this.hide, this);
        this._map.on("mousedown", this._onMouseDown);
        return this._container = this._createContainer()
    },
    _createContainer: function () {
        var a = window.document.createElement("div");
        a.className = "mapboxgl-ctrl";
        this.className && a.classList.add(this.className);
        a.style.position = "absolute";
        a.style.background = "white";
        a.style.border = "1px solid #adbfe4";
        a.style.zIndex = 2;
        a.innerHTML = this.contentHTML ? this.contentHTML : "";
        this.menuDiv = a;
        this.menuDiv.onmousedown = GeoGlobe.Function.bind(function (a) {
            (a || event).preventDefault();
            event.stopPropagation && event.stopPropagation()
        }, this);
        this.hide();
        return a
    }, _showContextMenu: function (a) {
        this.lngLat =
            a.lngLat;
        this.point = a.point;
        this.menuDiv.style.left = a.point.x + "px";
        this.menuDiv.style.top = a.point.y + "px";
        this.show()
    }, onRemove: function () {
        this._container.parentNode.removeChild(this._container);
        this._map.off("contextmenu", this._onContextMenu);
        this._map.off("mousedown", this._onMouseDown);
        this.contentHTML = this._container = this.menuDiv = null;
        this._map = void 0
    }, show: function () {
        if (this.menuDiv && this.menuDiv.style.display == "none") this.menuDiv.style.display = ""
    }, hide: function () {
        if (this.menuDiv && this.menuDiv.style.display !=
            "none") this.menuDiv.style.display = "none"
    }, setContentHTML: function (a) {
        if (a != null) this.contentHTML = a;
        if (this.menuDiv != null && this.contentHTML != null && this.contentHTML != this.menuDiv.innerHTML) this.menuDiv.innerHTML = this.contentHTML
    }, addItem: function (a) {
        var b = document.createElement("div");
        b.id = a.id;
        b.style.cssText = "padding-bottom: 2px; line-height: 17px; margin: 0px 2px; padding-left: 6px; width:" + a.width + "px; padding-right: 6px; color: #000; font-size: 12px; cursor: pointer; padding-top: 2px;";
        b.innerHTML =
            "<span>" + a.text + "</span>";
        b.onclick = GeoGlobe.Function.bind(function () {
            a.callback({target: a, control: this, map: this._map, lngLat: this.lngLat, point: this.point});
            this.hide()
        }, this);
        b.onmouseover = function () {
            b.style.color = "#6688cc"
        };
        b.onmouseout = function () {
            b.style.color = "#000"
        };
        this.menuDiv.appendChild(b);
        this.setContentHTML(this.menuDiv.innerHTML)
    }, addSeparator: function () {
        var a = document.createElement("div");
        a.style.cssText = "border-bottom:#adbfe4 1px solid;margin:0px 6px;font-size:0px;padding:1px";
        this.menuDiv.appendChild(a);
        this.setContentHTML(this.menuDiv.innerHTML)
    }, mousePos: function (a, b) {
        var c = a.getBoundingClientRect();
        return new GeoGlobe.Point(b.clientX - c.left - a.clientLeft, b.clientY - c.top - a.clientTop)
    }, CLASS_NAME: "GeoGlobe.View2D.Control.MapContextMenu"
});
GeoGlobe.MenuItem = GeoGlobe.Class4OL({
    id: null, text: null, callback: null, width: 100, initialize: function (a) {
        this.id = GeoGlobe.Util.createUniqueID(this.CLASS_NAME + "_");
        GeoGlobe.Util.extend(this, a)
    }, setText: function (a) {
        this.text = a
    }, CLASS_NAME: "GeoGlobe.MenuItem"
});
GeoGlobe.Event = GeoGlobe.Class(mapboxgl.Evented, {
    initialize: function () {
        return this.Event = mapboxgl.Evented
    }, CLASS_NAME: "GeoGlobe.Event"
});
GeoGlobe.Event.MapMouseEvent = GeoGlobe.Class(GeoGlobe.Event, {
    target: null, initialize: function (a) {
        this.el = a.getCanvasContainer();
        this.map = a;
        var b = new GeoGlobe.Popup({closeButton: !1, closeOnClick: !1});
        this.el.addEventListener("mouseout", this.onMouseOut, !1);
        this.el.addEventListener("mousedown", this.onMouseDown, !1);
        this.el.addEventListener("mouseup", this.onMouseUp, !1);
        this.el.addEventListener("mousemove", this.onMouseMove, !1);
        this.el.addEventListener("click", this.sigleClick, !1);
        this.el.addEventListener("dblclick",
            this.doubleClick, !1);
        this.el.addEventListener("contextmenu", this.onContextMenu, !1);
        this.onMouseOut = function () {
            a.on("mouseout", function () {
                alert("out")
            })
        };
        this.onMouseDown = function () {
            a.stop();
            a.on("mousedown", function () {
                alert("down")
            })
        };
        this.onMouseUp = function () {
            a.dragRotate && a.dragRotate.isActive();
            a.on("mouseup", function () {
                alert("up")
            })
        };
        this.onMouseMove = function () {
            if (!a.dragPan || !a.dragPan.isActive())if (!a.dragRotate || !a.dragRotate.isActive()) a.on("mousemove", function (c) {
                var d = JSON.stringify(c.point) +
                    "<br />" + JSON.stringify(c.lngLat);
                b.setLngLat([c.lngLat.lng, c.lngLat.lat]).setHTML(d).addTo(a)
            })
        };
        this.sigleClick = function () {
            a.on("click", function () {
                alert("sigle")
            })
        };
        this.doubleClick = function () {
            a.on("dblclick", function () {
                alert("double")
            })
        };
        this.onContextMenu = function (a) {
            a.preventDefault()
        };
        this.remove = function (a) {
            switch (a) {
                case "mouseout":
                    this.el.removeEventListener("mouseout", this.onMouseMove);
                    this.map._listeners.mouseout.splice(0, 1);
                    break;
                case "mousemove":
                    this.el.removeEventListener("mousemove",
                        this.onMouseMove);
                    b.remove();
                    this.map._listeners.mousemove.splice(0, 1);
                    break;
                case "mousedown":
                    this.el.removeEventListener("mousedown", this.onMouseDown);
                    this.map._listeners.mousedown.splice(0, 1);
                    break;
                case "mouseup":
                    this.el.removeEventListener("mouseup", this.onMouseUp);
                    this.map._listeners.mouseup.splice(0, 1);
                    break;
                case "dblclick":
                    this.el.removeEventListener("dblclick", this.doubleClick);
                    this.map._listeners.dblclick.splice(0, 1);
                    break;
                case "click":
                    this.el.removeEventListener("click", this.sigleClick),
                        this.map._listeners.click.splice(0, 1)
            }
        };
        return this
    }, onMouseOut: function () {
    }, onMouseDown: function () {
    }, onMouseUp: function () {
    }, onMouseMove: function () {
    }, sigleClick: function () {
    }, doubleClick: function () {
        map.on("dblclick", function () {
            alert("double")
        })
    }, onContextMenu: function (a) {
        contextMenuEvent = a;
        a.preventDefault()
    }, remove: function (a) {
        switch (a) {
            case "mouseout":
                this.el.removeEventListener("mouseout", this.onMouseMove);
                this.map._listeners.mouseout.splice(0, 1);
                break;
            case "mousemove":
                this.el.removeEventListener("mousemove",
                    this.onMouseMove);
                popup.remove();
                this.map._listeners.mousemove.splice(0, 1);
                break;
            case "mousedown":
                this.el.removeEventListener("mousedown", this.onMouseDown);
                this.map._listeners.mousedown.splice(0, 1);
                break;
            case "mouseup":
                this.el.removeEventListener("mouseup", this.onMouseUp);
                this.map._listeners.mouseup.splice(0, 1);
                break;
            case "dblclick":
                this.el.removeEventListener("dblclick", this.doubleClick);
                this.map._listeners.dblclick.splice(0, 1);
                break;
            case "click":
                this.el.removeEventListener("click", this.sigleClick),
                    this.map._listeners.click.splice(0, 1)
        }
    }, CLASS_NAME: "GeoGlobe.Event.MapMouseEvent"
});
GeoGlobe.Event.MapTouchEvent = GeoGlobe.Class(GeoGlobe.Event, {
    target: null, initialize: function (a) {
        this.el = a.getCanvasContainer();
        this.map = a;
        var b = null;
        this.el.addEventListener("touchstart", this.onTouchStart, !1);
        this.el.addEventListener("touchend", this.onTouchEnd, !1);
        this.el.addEventListener("touchmove", this.onTouchMove, !1);
        this.el.addEventListener("touchcancel", this.onTouchCancel, !1);
        this.el.addEventListener("dblclick", this.doubleClick, !1);
        this.onTouchStart = function () {
            a.stop();
            alert("xxfds");
            a.on("touchstart",
                function () {
                    alert("double1")
                });
            b ? (clearTimeout(b), b = null, a.on("dblclick", function () {
                alert("double2")
            })) : b = setTimeout(this.onTouchTimeout, 300)
        };
        this.onTouchMove = function () {
            alert("xcsx");
            a.on("touchmove", function () {
                alert("double3")
            })
        };
        this.onTouchEnd = function () {
            alert("xfx");
            a.on("touchend", function () {
                alert("double4")
            })
        };
        this.onTouchCancel = function () {
            alert("xx");
            a.on("touchcancel", function () {
                alert("double5")
            })
        };
        this.onTouchTimeout = function () {
            b = null
        };
        this.doubleClick = function (b) {
            a.on(b, function () {
                alert("double")
            })
        };
        this.remove = function (a) {
            switch (a) {
                case "touchstart":
                    this.el.removeEventListener("touchstart", this.onMouseMove);
                    this.map._listeners.touchstart.splice(0, 1);
                    break;
                case "touchmove":
                    this.el.removeEventListener("touchmove", this.onMouseMove);
                    popup.remove();
                    this.map._listeners.touchmove.splice(0, 1);
                    break;
                case "touchend":
                    this.el.removeEventListener("touchend", this.onMouseDown);
                    this.map._listeners.touchend.splice(0, 1);
                    break;
                case "touchcancel":
                    this.el.removeEventListener("touchcancel", this.onMouseUp);
                    this.map._listeners.touchcancel.splice(0,
                        1);
                    break;
                case "dblclick":
                    this.el.removeEventListener("dblclick", this.touchcancel), this.map._listeners.dblclick.splice(0, 1)
            }
        };
        return this
    }, onTouchStart: function () {
        map.stop();
        alert("xxfds");
        map.on("touchstart", function () {
            alert("double1")
        });
        tapped ? (clearTimeout(tapped), tapped = null, map.on("dblclick", function () {
            alert("double2")
        })) : tapped = setTimeout(this.onTouchTimeout, 300)
    }, onTouchMove: function () {
        alert("xcsx");
        map.on("touchmove", function () {
            alert("double3")
        })
    }, onTouchEnd: function () {
        alert("xfx");
        map.on("touchend",
            function () {
                alert("double4")
            })
    }, onTouchCancel: function () {
        alert("xx");
        map.on("touchcancel", function () {
            alert("double5")
        })
    }, onTouchTimeout: function () {
        tapped = null
    }, remove: function (a) {
        switch (a) {
            case "touchstart":
                this.el.removeEventListener("touchstart", this.onMouseMove);
                this.map._listeners.touchstart.splice(0, 1);
                break;
            case "touchmove":
                this.el.removeEventListener("touchmove", this.onMouseMove);
                popup.remove();
                this.map._listeners.touchmove.splice(0, 1);
                break;
            case "touchend":
                this.el.removeEventListener("touchend",
                    this.onMouseDown);
                this.map._listeners.touchend.splice(0, 1);
                break;
            case "touchcancel":
                this.el.removeEventListener("touchcancel", this.onMouseUp);
                this.map._listeners.touchcancel.splice(0, 1);
                break;
            case "dblclick":
                this.el.removeEventListener("dblclick", this.touchcancel), this.map._listeners.dblclick.splice(0, 1)
        }
    }, CLASS_NAME: "GeoGlobe.Event.MapTouchEvent"
});
GeoGlobe.Event.mapDataEvent = GeoGlobe.Class(GeoGlobe.Event, {
    type: null, datatype: null, initialize: function () {
        return this
    }, CLASS_NAME: "GeoGlobe.Event.mapDataEvent"
});
GeoGlobe.Event.mapBoxZoomEvent = GeoGlobe.Class(GeoGlobe.Event, {
    target: null, boxZoomBounds: null, initialize: function (a) {
        this.el = a.getCanvasContainer();
        this.map = a;
        var b = new GeoGlobe.Popup({closeButton: !1, closeOnClick: !1});
        this.el.addEventListener("keydown", this.onKeyDown, !1);
        this.el.addEventListener("mousedown", this.onMouseDown, !1);
        this.el.addEventListener("mouseup", this.onMouseUp, !1);
        this.el.addEventListener("mousemove", this.onMouseMove, !1);
        this.onKeyDown = function () {
            a.on("keydown", function () {
                alert("keydown")
            })
        };
        this.onMouseDown = function () {
            a.stop();
            a.on("mousedown", function (a) {
                alert("down");
                GeoGlobe.DOM.mousePos(this.el, a)
            })
        };
        this.onMouseUp = function () {
            a.dragRotate && a.dragRotate.isActive();
            a.on("mouseup", function () {
                alert("up")
            })
        };
        this.onMouseMove = function () {
            if (!a.dragPan || !a.dragPan.isActive())if (!a.dragRotate || !a.dragRotate.isActive()) a.on("mousemove", function (c) {
                var d = JSON.stringify(c.point) + "<br />" + JSON.stringify(c.lngLat);
                b.setLngLat([c.lngLat.lng, c.lngLat.lat]).setHTML(d).addTo(a)
            })
        };
        this.remove = function (a) {
            switch (a) {
                case "mouseout":
                    this.el.removeEventListener("mouseout",
                        this.onMouseMove);
                    this.map._listeners.mouseout.splice(0, 1);
                    break;
                case "mousemove":
                    this.el.removeEventListener("mousemove", this.onMouseMove);
                    b.remove();
                    this.map._listeners.mousemove.splice(0, 1);
                    break;
                case "mousedown":
                    this.el.removeEventListener("mousedown", this.onMouseDown);
                    this.map._listeners.mousedown.splice(0, 1);
                    break;
                case "mouseup":
                    this.el.removeEventListener("mouseup", this.onMouseUp);
                    this.map._listeners.mouseup.splice(0, 1);
                    break;
                case "dblclick":
                    this.el.removeEventListener("dblclick", this.doubleClick);
                    this.map._listeners.dblclick.splice(0, 1);
                    break;
                case "click":
                    this.el.removeEventListener("click", this.sigleClick), this.map._listeners.click.splice(0, 1)
            }
        };
        return this
    }, onKeyDown: function () {
        map.on("keydown", function () {
            alert("keydown")
        })
    }, onMouseDown: function () {
        map.stop();
        map.on("mousedown", function (a) {
            alert("down");
            startPos = GeoGlobe.DOM.mousePos(this.el, a)
        })
    }, onMouseUp: function () {
        map.dragRotate && map.dragRotate.isActive();
        map.on("mouseup", function () {
            alert("up")
        })
    }, onMouseMove: function () {
        if (!map.dragPan ||
            !map.dragPan.isActive())if (!map.dragRotate || !map.dragRotate.isActive()) map.on("mousemove", function (a) {
            var b = JSON.stringify(a.point) + "<br />" + JSON.stringify(a.lngLat);
            popup.setLngLat([a.lngLat.lng, a.lngLat.lat]).setHTML(b).addTo(map)
        })
    }, remove: function (a) {
        switch (a) {
            case "keydown":
                this.el.removeEventListener("keydown", this.onKeyDown);
                this.map._listeners.keydown.splice(0, 1);
                break;
            case "mousemove":
                this.el.removeEventListener("mousemove", this.onMouseMove);
                popup.remove();
                this.map._listeners.mousemove.splice(0,
                    1);
                break;
            case "mousedown":
                this.el.removeEventListener("mousedown", this.onMouseDown);
                this.map._listeners.mousedown.splice(0, 1);
                break;
            case "mouseup":
                this.el.removeEventListener("mouseup", this.onMouseUp), this.map._listeners.mouseup.splice(0, 1)
        }
    }, CLASS_NAME: "GeoGlobe.Event.mapBoxZoomEvent"
});
GeoGlobe.Handler = GeoGlobe.Class({
    initialize: function () {
        return this
    }, CLASS_NAME: "GeoGlobe.Handler"
});
GeoGlobe.Handler.BoxZoomHandler = GeoGlobe.Class(GeoGlobe.Handler, {
    map: null, initialize: function (a) {
        return this.handler = a.boxZoom
    }, isActivate: function () {
        return this.handler.isActive()
    }, isEnabled: function () {
        return this.handler.isEnabled()
    }, enable: function () {
        this.handler.enable()
    }, disable: function () {
        this.handler.disable()
    }, CLASS_NAME: "GeoGlobe.Handler.BoxZoomHandler"
});
GeoGlobe.Handler.DoubleClickZoomHandler = GeoGlobe.Class(GeoGlobe.Handler, {
    map: null, initialize: function (a) {
        return this.handler = a.doubleClickZoom
    }, isEnabled: function () {
        return this.handler.isEnabled()
    }, enable: function () {
        this.handler.enable()
    }, disable: function () {
        this.handler.disable()
    }, CLASS_NAME: "GeoGlobe.Handler.DoubleClickZoomHandler"
});
GeoGlobe.Handler.DragPanHandler = GeoGlobe.Class(GeoGlobe.Handler, {
    map: null, initialize: function (a) {
        return this.handler = a.dragPan
    }, isActivate: function () {
        return this.handler.isActive()
    }, isEnabled: function () {
        return this.handler.isEnabled()
    }, enable: function () {
        this.handler.enable()
    }, disable: function () {
        this.handler.disable()
    }, CLASS_NAME: "GeoGlobe.Handler.DragPanHandler"
});
GeoGlobe.Handler.DragRotateHandler = GeoGlobe.Class(GeoGlobe.Handler, {
    map: null, initialize: function (a) {
        return this.handler = a.dragRotate
    }, isActivate: function () {
        return this.handler.isActive()
    }, isEnabled: function () {
        return this.handler.isEnabled()
    }, enable: function () {
        this.handler.enable()
    }, disable: function () {
        this.handler.disable()
    }, CLASS_NAME: "GeoGlobe.Handler.DragRotateHandler"
});
GeoGlobe.Handler.KeyboardHandler = GeoGlobe.Class(GeoGlobe.Handler, {
    map: null, initialize: function (a) {
        return this.handler = a.keyboard
    }, isEnabled: function () {
        return this.handler.isEnabled()
    }, enable: function () {
        this.handler.enable()
    }, disable: function () {
        this.handler.disable()
    }, CLASS_NAME: "GeoGlobe.Handler.KeyboardHandler"
});
GeoGlobe.Handler.ScrollZoomHandler = GeoGlobe.Class(GeoGlobe.Handler, {
    map: null, initialize: function (a) {
        return this.handler = a.scrollZoom
    }, isEnabled: function () {
        return this.handler.isEnabled()
    }, enable: function () {
        this.handler.enable()
    }, disable: function () {
        this.handler.disable()
    }, CLASS_NAME: "GeoGlobe.Handler.ScrollZoomHandler"
});
GeoGlobe.Handler.TouchZoomRotateHandler = GeoGlobe.Class(GeoGlobe.Handler, {
    map: null, initialize: function (a) {
        return this.handler = a.touchZoomRotate
    }, isEnabled: function () {
        return this.handler.isEnabled()
    }, enable: function () {
        this.handler.enable()
    }, disable: function () {
        this.handler.disable()
    }, disableRotation: function () {
        this.handler.disable()
    }, enableRotation: function () {
        this.handler.disable()
    }, CLASS_NAME: "GeoGlobe.Handler.TouchZoomRotateHandler"
});
GeoGlobe.DynamicTrace = GeoGlobe.Class({
    frame_num: 0, origons: [0, 0], destinations: [0, 0], map: null, id: null, initialize: function (a) {
        this.options = a;
        frame_num = a.frame_num;
        map = a.map;
        id = a.id;
        origins = a.origons;
        destinations = a.destinations;
        num = destinations.length;
        pointid = id + "point";
        routeid1 = id + "route1";
        routeid2 = id + "route2";
        point = {};
        route = {};
        route1 = {};
        route2 = {};
        counter = 0;
        request = null
    }, autotrace: function (a, b) {
        frame_num || (frame_num = 1E3);
        a && (frame_num = a);
        route = {
            type: "FeatureCollection", features: [{
                type: "Feature", geometry: {
                    type: "LineString",
                    coordinates: [origins[0], destinations[0]]
                }
            }]
        };
        for (var c = 1; c < num; c++) {
            var d = {type: "Feature", geometry: {type: "LineString", coordinates: [origins[c], destinations[c]]}};
            route.features.push(d)
        }
        point = {
            type: "FeatureCollection",
            features: [{type: "Feature", geometry: {type: "Point", coordinates: origins[0]}}]
        };
        for (c = 1; c < num; c++)d = {
            type: "Feature",
            geometry: {type: "Point", coordinates: origins[c]}
        }, point.features.push(d);
        d = [];
        d.push(turf.lineDistance(route.features[0], "kilometers"));
        for (c = 1; c < num; c++)d.push(turf.lineDistance(route.features[c],
            "kilometers"));
        for (var e = 0; e < num; e++) {
            for (var f = [], c = 0; c < d[e]; c++) {
                var g = turf.along(route.features[e], c / frame_num * d[e], "kilometers");
                f.push(g.geometry.coordinates)
            }
            route.features[e].geometry.coordinates = f
        }
        route1 = {type: "FeatureCollection", features: []};
        for (e = 0; e < num; e++)d = {
            type: "Feature",
            geometry: {type: "LineString", coordinates: [origins[e], origins[e]]}
        }, route1.features.push(d);
        route2 = {type: "FeatureCollection", features: []};
        for (e = 0; e < num; e++)d = {
            type: "Feature", geometry: {
                type: "LineString", coordinates: [origins[e],
                    origins[e]]
            }
        }, route2.features.push(d);
        counter = 0;
        map.addSource(routeid1, {type: "geojson", data: route1});
        map.addSource(routeid2, {type: "geojson", data: route2});
        map.addSource(pointid, {type: "geojson", data: point});
        b ? (map.addLayer({
            id: routeid1,
            source: routeid1,
            type: b.line.type,
            paint: b.line.paint
        }), map.addLayer({
            id: routeid2,
            source: routeid2,
            type: b.line.type,
            paint: b.line.paint
        }), map.addLayer({id: pointid, source: pointid, type: b.point.type, paint: b.point.paint})) : (map.addLayer({
            id: routeid1, source: routeid1, type: "line",
            paint: {"line-width": {base: 2, stops: [[12, 2], [22, 180]]}, "line-color": "red"}
        }), map.addLayer({
            id: routeid2,
            source: routeid2,
            type: "line",
            paint: {"line-width": {base: 2, stops: [[12, 2], [22, 180]]}, "line-color": "red"}
        }), map.addLayer({
            id: pointid,
            source: pointid,
            type: "circle",
            paint: {
                "circle-radius": {base: 2, stops: [[12, 2], [22, 180]]},
                "circle-color": "yellow",
                "circle-opacity": 1
            }
        }))
    }, run: function () {
        for (var a = 0; a < num; a++)point.features[a].geometry.coordinates = route.features[a].geometry.coordinates[counter], route1.features[a].geometry.coordinates.push(route.features[a].geometry.coordinates[counter]),
            route2.features[a].geometry.coordinates.push(route.features[a].geometry.coordinates[counter]), route1.features[a].geometry.coordinates.length > 11 && route1.features[a].geometry.coordinates.shift();
        map.getSource(pointid).setData(point);
        map.getSource(routeid1).setData(route1);
        counter % 10 == 0 && map.getSource(routeid2).setData(route2);
        point.features[0].geometry.coordinates[0] !== destinations[0][0] && (request = requestAnimationFrame(run));
        counter += 1
    }, reset: function () {
        for (var a = 0; a < num; a++)point.features[a].geometry.coordinates =
            origins[a], route1.features[a].geometry.coordinates = [], route2.features[a].geometry.coordinates = [], route1.features[a].geometry.coordinates.push(origins[a]), route2.features[a].geometry.coordinates.push(origins[a]);
        map.getSource(pointid).setData(point);
        map.getSource(routeid1).setData(route1);
        map.getSource(routeid2).setData(route2);
        counter = 0;
        cancelAnimationFrame(request)
    }, replay: function () {
        for (var a = 0; a < num; a++)point.features[a].geometry.coordinates = origins[a], route1.features[a].geometry.coordinates = [],
            route2.features[a].geometry.coordinates = [], route1.features[a].geometry.coordinates.push(origins[a]), route2.features[a].geometry.coordinates.push(origins[a]);
        map.getSource(pointid).setData(point);
        map.getSource(routeid1).setData(route1);
        map.getSource(routeid2).setData(route2);
        counter = 0;
        run(counter)
    }, pause: function () {
        cancelAnimationFrame(request)
    }, removetrace: function () {
        map.removeLayer(pointid);
        map.removeLayer(routeid1);
        map.removeLayer(routeid2);
        map.removeSource(pointid);
        map.removeSource(routeid1);
        map.removeSource(routeid2)
    },
    CLASS_NAME: "GeoGlobe.DynamicTrace"
});
GeoGlobe.DynamicFeature = GeoGlobe.Class({
    data: null, map: null, style: null, isdraw: null, id: null, property: null, initialize: function (a) {
        this.options = a;
        map = a.map;
        feat_data = a.data;
        speed = 500;
        i = 0;
        sourceid = null;
        style = a.style;
        property = style.property;
        val_property = feat_data.features[0].properties[property];
        sourceid = a.id;
        isdraw = a.isdraw;
        color_num = [];
        size_num = [];
        isdraw && (this.setdata(), this.setstyle())
    }, setdata: function (a) {
        a ? (map.removeSource(sourceid), map.addSource(sourceid, {type: "geojson", data: a})) : map.addSource(sourceid,
            {type: "geojson", data: feat_data})
    }, setstyle: function () {
        var a = 0;
        if (style.color) {
            color = style.color;
            for (var b = color[val_property], c = 0; c < b.length; c++)color_num.push([c, b[c]]);
            opacity = style.opacity;
            if (style.size) {
                size = style.size;
                b = size[val_property];
                for (c = 0; c < b.length; c++)size_num.push([c, b[c]])
            } else size_num = [[0, 7], [1, 5], [2, 3]]
        } else opacity = 0.3, color_num = [[0, "red"], [1, "#FFC0CB"], [2, "#FFB6C1"]], size_num = [[0, 7], [1, 5], [2, 3]];
        style.type === "point" ? setInterval(function () {
            i % speed === 0 && (map.addLayer({
                id: sourceid,
                type: "circle",
                source: sourceid,
                paint: {
                    "circle-color": {stops: [color_num[a]]},
                    "circle-opacity": opacity,
                    "circle-radius": {stops: [size_num[a]]}
                }
            }), a++, a > 2 && (a = 0));
            i += 5
        }, 1) : style.type === "line" ? setInterval(function () {
            i % speed === 0 && (map.addLayer({
                id: sourceid,
                type: "line",
                source: sourceid,
                paint: {
                    "line-color": {stops: [color_num[a]]},
                    "line-opacity": opacity,
                    "line-width": {stops: [size_num[a]]}
                }
            }), a++, a > 2 && (a = 0));
            i += 5
        }, 1) : style.type === "fill" ? setInterval(function () {
            i % speed === 0 && (map.addLayer({
                id: sourceid,
                type: "fill",
                source: sourceid,
                paint: {
                    "fill-color": {stops: [color_num[a]]},
                    "fill-opacity": 0.3,
                    "fill-outline-color": {stops: [color_num[a]]}
                }
            }), a++, a > 2 && (a = 0));
            i += 5
        }, 1) : alert("\u8bf7\u786e\u5b9a\u663e\u793a\u7684\u8981\u7d20\u7684\u7c7b\u578b")
    }, CLASS_NAME: "GeoGlobe.DynamicFeature"
});
GeoGlobe.Geometry = GeoGlobe.Class4OL({
    id: null, parent: null, bounds: null, initialize: function () {
        this.id = GeoGlobe.Util.createUniqueID(this.CLASS_NAME + "_")
    }, destroy: function () {
        this.bounds = this.id = null
    }, clone: function () {
        return new GeoGlobe.Geometry
    }, setBounds: function (a) {
        if (a) this.bounds = a.clone()
    }, clearBounds: function () {
        this.bounds = null;
        this.parent && this.parent.clearBounds()
    }, extendBounds: function (a) {
        this.getBounds() ? this.bounds.extend(a) : this.setBounds(a)
    }, getBounds: function () {
        this.bounds == null && this.calculateBounds();
        return this.bounds
    }, calculateBounds: function () {
    }, distanceTo: function () {
    }, getVertices: function () {
    }, atPoint: function (a, b, c) {
        var d = !1;
        this.getBounds() != null && a != null && (b = b != null ? b : 0, d = c != null ? c : 0, c = new GeoGlobe.LngLat(this.bounds._sw.lng - b, this.bounds._sw.lat - d), b = new GeoGlobe.LngLat(this.bounds._ne.lng + b, this.bounds._ne.lat + d), d = (new GeoGlobe.LngLatBounds(c, b)).containsLonLat(a));
        return d
    }, getLength: function () {
        return 0
    }, getArea: function () {
        return 0
    }, getCentroid: function () {
        return null
    }, toString: function () {
        return GeoGlobe.Format &&
        GeoGlobe.Format.WKT ? GeoGlobe.Format.WKT.prototype.write(new GeoGlobe.Feature(this)) : Object.prototype.toString.call(this)
    }, CLASS_NAME: "GeoGlobe.Geometry"
});
GeoGlobe.Geometry.fromWKT = function (a) {
    var b;
    if (GeoGlobe.Format && GeoGlobe.Format.WKT) {
        var c = GeoGlobe.Geometry.fromWKT.format;
        if (!c) c = new GeoGlobe.Format.WKT, GeoGlobe.Geometry.fromWKT.format = c;
        a = c.read(a);
        if (a instanceof GeoGlobe.Feature) b = a.geometry; else if (GeoGlobe.Util.isArray(a)) {
            b = a.length;
            for (var c = Array(b), d = 0; d < b; ++d)c[d] = a[d].geometry;
            b = new GeoGlobe.Geometry.Collection(c)
        }
    }
    return b
};
GeoGlobe.Geometry.segmentsIntersect = function (a, b, c) {
    var d = c && c.point, c = c && c.tolerance, e = !1, f = a.x1 - b.x1, g = a.y1 - b.y1, h = a.x2 - a.x1,
        j = a.y2 - a.y1, l = b.y2 - b.y1, m = b.x2 - b.x1, n = l * h - m * j, l = m * g - l * f, g = h * g - j * f;
    n == 0 ? l == 0 && g == 0 && (e = !0) : (f = l / n, n = g / n, f >= 0 && f <= 1 && n >= 0 && n <= 1 && (d ? (h = a.x1 + f * h, n = a.y1 + f * j, e = new GeoGlobe.Geometry.Point(h, n)) : e = !0));
    if (c)if (e) {
        if (d) {
            a = [a, b];
            b = 0;
            a:for (; b < 2; ++b) {
                f = a[b];
                for (j = 1; j < 3; ++j)if (h = f["x" + j], n = f["y" + j], d = Math.sqrt(Math.pow(h - e.x, 2) + Math.pow(n - e.y, 2)), d < c) {
                    e.x = h;
                    e.y = n;
                    break a
                }
            }
        }
    } else {
        a = [a,
            b];
        b = 0;
        a:for (; b < 2; ++b) {
            h = a[b];
            n = a[(b + 1) % 2];
            for (j = 1; j < 3; ++j)if (f = {
                    x: h["x" + j],
                    y: h["y" + j]
                }, g = GeoGlobe.Geometry.distanceToSegment(f, n), g.distance < c) {
                e = d ? new GeoGlobe.Geometry.Point(f.x, f.y) : !0;
                break a
            }
        }
    }
    return e
};
GeoGlobe.Geometry.distanceToSegment = function (a, b) {
    var c = GeoGlobe.Geometry.distanceSquaredToSegment(a, b);
    c.distance = Math.sqrt(c.distance);
    return c
};
GeoGlobe.Geometry.distanceSquaredToSegment = function (a, b) {
    var c = a.x, d = a.y, e = b.x1, f = b.y1, g = b.x2, h = b.y2, j = g - e, l = h - f,
        m = j == 0 && l == 0 ? 0 : (j * (c - e) + l * (d - f)) / (Math.pow(j, 2) + Math.pow(l, 2));
    m <= 0 || (m >= 1 ? (e = g, f = h) : (e += m * j, f += m * l));
    return {distance: Math.pow(e - c, 2) + Math.pow(f - d, 2), x: e, y: f, along: m}
};
GeoGlobe.Geometry.fromGeoJson = function (a) {
    var b;
    if (GeoGlobe.Format && GeoGlobe.Format.GeoJSON) {
        format = new GeoGlobe.Format.GeoJSON;
        b = null;
        try {
            b = format.parseGeometry(a)
        } catch (c) {
            console.log(c)
        }
    }
    return b
};
GeoGlobe.Geometry.Collection = GeoGlobe.Class4OL(GeoGlobe.Geometry, {
    components: null, componentTypes: null, initialize: function (a) {
        GeoGlobe.Geometry.prototype.initialize.apply(this, arguments);
        this.components = [];
        a != null && this.addComponents(a)
    }, destroy: function () {
        this.components.length = 0;
        this.components = null;
        GeoGlobe.Geometry.prototype.destroy.apply(this, arguments)
    }, clone: function () {
        for (var a = eval("new " + this.CLASS_NAME + "()"), b = 0, c = this.components.length; b < c; b++)a.addComponent(this.components[b].clone());
        GeoGlobe.Util.applyDefaults(a, this);
        return a
    }, getComponentsString: function () {
        for (var a = [], b = 0, c = this.components.length; b < c; b++)a.push(this.components[b].toShortString());
        return a.join(",")
    }, calculateBounds: function () {
        this.bounds = null;
        var a = new GeoGlobe.LngLatBounds, b = this.components;
        if (b)for (var c = 0, d = b.length; c < d; c++)a.extend(b[c].getBounds());
        a._sw != null && a._sw != null && a._ne != null && a._ne != null && a._sw.lng != null && a._sw.lat != null && a._ne.lng != null && a._ne.lat != null && this.setBounds(a)
    }, addComponents: function (a) {
        GeoGlobe.Util.isArray(a) ||
        (a = [a]);
        for (var b = 0, c = a.length; b < c; b++)this.addComponent(a[b])
    }, addComponent: function (a, b) {
        var c = !1;
        if (a && (this.componentTypes == null || GeoGlobe.Util.indexOf(this.componentTypes, a.CLASS_NAME) > -1)) {
            if (b != null && b < this.components.length) {
                var c = this.components.slice(0, b), d = this.components.slice(b, this.components.length);
                c.push(a);
                this.components = c.concat(d)
            } else this.components.push(a);
            a.parent = this;
            this.clearBounds();
            c = !0
        }
        return c
    }, removeComponents: function (a) {
        var b = !1;
        GeoGlobe.Util.isArray(a) || (a = [a]);
        for (var c = a.length - 1; c >= 0; --c)b = this.removeComponent(a[c]) || b;
        return b
    }, removeComponent: function (a) {
        GeoGlobe.Util.removeItem(this.components, a);
        this.clearBounds();
        return !0
    }, getLength: function () {
        for (var a = 0, b = 0, c = this.components.length; b < c; b++)a += this.components[b].getLength();
        return a
    }, getArea: function () {
        for (var a = 0, b = 0, c = this.components.length; b < c; b++)a += this.components[b].getArea();
        return a
    }, getGeodesicArea: function (a) {
        for (var b = 0, c = 0, d = this.components.length; c < d; c++)b += this.components[c].getGeodesicArea(a);
        return b
    }, getCentroid: function (a) {
        if (!a)return this.components.length && this.components[0].getCentroid();
        a = this.components.length;
        if (!a)return !1;
        for (var b = [], c = [], d = 0, e = Number.MAX_VALUE, f, g = 0; g < a; ++g) {
            f = this.components[g];
            var h = f.getArea();
            f = f.getCentroid(!0);
            !isNaN(h) && !isNaN(f.x) && !isNaN(f.y) && (b.push(h), d += h, e = h < e && h > 0 ? h : e, c.push(f))
        }
        a = b.length;
        if (d === 0) {
            for (g = 0; g < a; ++g)b[g] = 1;
            d = b.length
        } else {
            for (g = 0; g < a; ++g)b[g] /= e;
            d /= e
        }
        for (var j = e = 0, g = 0; g < a; ++g)f = c[g], h = b[g], e += f.x * h, j += f.y * h;
        return new GeoGlobe.Geometry.Point(e /
            d, j / d)
    }, getGeodesicLength: function (a) {
        for (var b = 0, c = 0, d = this.components.length; c < d; c++)b += this.components[c].getGeodesicLength(a);
        return b
    }, move: function (a, b) {
        for (var c = 0, d = this.components.length; c < d; c++)this.components[c].move(a, b)
    }, rotate: function (a, b) {
        for (var c = 0, d = this.components.length; c < d; ++c)this.components[c].rotate(a, b)
    }, resize: function (a, b, c) {
        for (var d = 0; d < this.components.length; ++d)this.components[d].resize(a, b, c);
        return this
    }, distanceTo: function (a, b) {
        for (var c = !(b && b.edge === !1) && b && b.details,
                 d, e, f, g = Number.POSITIVE_INFINITY, h = 0, j = this.components.length; h < j; ++h)if (d = this.components[h].distanceTo(a, b), f = c ? d.distance : d, f < g && (g = f, e = d, g == 0))break;
        return e
    }, equals: function (a) {
        var b = !0;
        if (!a || !a.CLASS_NAME || this.CLASS_NAME != a.CLASS_NAME) b = !1; else if (!GeoGlobe.Util.isArray(a.components) || a.components.length != this.components.length) b = !1; else for (var c = 0, d = this.components.length; c < d; ++c)if (!this.components[c].equals(a.components[c])) {
            b = !1;
            break
        }
        return b
    }, transform: function (a, b) {
        if (a && b) {
            for (var c =
                0, d = this.components.length; c < d; c++)this.components[c].transform(a, b);
            this.bounds = null
        }
        return this
    }, intersects: function (a) {
        for (var b = !1, c = 0, d = this.components.length; c < d; ++c)if (b = a.intersects(this.components[c]))break;
        return b
    }, getVertices: function (a) {
        for (var b = [], c = 0, d = this.components.length; c < d; ++c)Array.prototype.push.apply(b, this.components[c].getVertices(a));
        return b
    }, CLASS_NAME: "GeoGlobe.Geometry.Collection"
});
GeoGlobe.Geometry.Point = GeoGlobe.Class4OL(GeoGlobe.Geometry, {
    x: null, y: null, initialize: function (a, b) {
        GeoGlobe.Geometry.prototype.initialize.apply(this, arguments);
        this.x = parseFloat(a);
        this.y = parseFloat(b)
    }, clone: function (a) {
        a == null && (a = new GeoGlobe.Geometry.Point(this.x, this.y));
        GeoGlobe.Util.applyDefaults(a, this);
        return a
    }, calculateBounds: function () {
        var a = new GeoGlobe.LngLat(this.x, this.y), b = new GeoGlobe.LngLat(this.x, this.y);
        this.bounds = new GeoGlobe.LngLatBounds(a, b)
    }, distanceTo: function (a, b) {
        var c =
            !(b && b.edge === !1) && b && b.details, d, e, f, g, h;
        a instanceof GeoGlobe.Geometry.Point ? (e = this.x, f = this.y, g = a.x, h = a.y, d = Math.sqrt(Math.pow(e - g, 2) + Math.pow(f - h, 2)), d = !c ? d : {
            x0: e,
            y0: f,
            x1: g,
            y1: h,
            distance: d
        }) : (d = a.distanceTo(this, b), c && (d = {x0: d.x1, y0: d.y1, x1: d.x0, y1: d.y0, distance: d.distance}));
        return d
    }, equals: function (a) {
        var b = !1;
        a != null && (b = this.x == a.x && this.y == a.y || isNaN(this.x) && isNaN(this.y) && isNaN(a.x) && isNaN(a.y));
        return b
    }, toShortString: function () {
        return this.x + ", " + this.y
    }, move: function (a, b) {
        this.x +=
            a;
        this.y += b;
        this.clearBounds()
    }, rotate: function (a, b) {
        a *= Math.PI / 180;
        var c = this.distanceTo(b), d = a + Math.atan2(this.y - b.y, this.x - b.x);
        this.x = b.x + c * Math.cos(d);
        this.y = b.y + c * Math.sin(d);
        this.clearBounds()
    }, getCentroid: function () {
        return new GeoGlobe.Geometry.Point(this.x, this.y)
    }, resize: function (a, b, c) {
        this.x = b.x + a * (c == void 0 ? 1 : c) * (this.x - b.x);
        this.y = b.y + a * (this.y - b.y);
        this.clearBounds();
        return this
    }, intersects: function (a) {
        var b = !1;
        return b = a.CLASS_NAME == "GeoGlobe.Geometry.Point" ? this.equals(a) : a.intersects(this)
    },
    transform: function (a, b) {
        if (a && b) GeoGlobe.SpatialReference.transform(this, a, b), this.bounds = null;
        return this
    }, getVertices: function () {
        return [this]
    }, CLASS_NAME: "GeoGlobe.Geometry.Point"
});
GeoGlobe.Geometry.MultiPoint = GeoGlobe.Class4OL(GeoGlobe.Geometry.Collection, {
    componentTypes: ["GeoGlobe.Geometry.Point"],
    addPoint: function (a, b) {
        this.addComponent(a, b)
    },
    removePoint: function (a) {
        this.removeComponent(a)
    },
    CLASS_NAME: "GeoGlobe.Geometry.MultiPoint"
});
GeoGlobe.Geometry.Curve = GeoGlobe.Class4OL(GeoGlobe.Geometry.MultiPoint, {
    componentTypes: ["GeoGlobe.Geometry.Point"], getLength: function () {
        var a = 0;
        if (this.components && this.components.length > 1)for (var b = 1, c = this.components.length; b < c; b++)a += this.components[b - 1].distanceTo(this.components[b]);
        return a
    }, getGeodesicLength: function (a) {
        var b = this;
        if (a) {
            var c = new GeoGlobe.SpatialReference("EPSG:4326");
            c.equals(a) || (b = this.clone().transform(a, c))
        }
        a = 0;
        if (b.components && b.components.length > 1)for (var d, e = 1, f = b.components.length; e <
        f; e++)c = b.components[e - 1], d = b.components[e], a += GeoGlobe.Util.distVincenty({
            lng: c.x,
            lat: c.y
        }, {lng: d.x, lat: d.y});
        return a * 1E3
    }, CLASS_NAME: "GeoGlobe.Geometry.Curve"
});
GeoGlobe.Geometry.LineString = GeoGlobe.Class4OL(GeoGlobe.Geometry.Curve, {
    removeComponent: function () {
        var a = this.components && this.components.length > 2;
        a && GeoGlobe.Geometry.Collection.prototype.removeComponent.apply(this, arguments);
        return a
    }, intersects: function (a) {
        var b = !1, c = a.CLASS_NAME;
        if (c == "GeoGlobe.Geometry.LineString" || c == "GeoGlobe.Geometry.LinearRing" || c == "GeoGlobe.Geometry.Point") {
            var d = this.getSortedSegments(),
                a = c == "GeoGlobe.Geometry.Point" ? [{x1: a.x, y1: a.y, x2: a.x, y2: a.y}] : a.getSortedSegments(),
                e, f, g, h, j, l, m, n = 0, p = d.length;
            a:for (; n < p; ++n) {
                c = d[n];
                e = c.x1;
                f = c.x2;
                g = c.y1;
                h = c.y2;
                var q = 0, o = a.length;
                for (; q < o; ++q) {
                    j = a[q];
                    if (j.x1 > f)break;
                    if (!(j.x2 < e) && (l = j.y1, m = j.y2, !(Math.min(l, m) > Math.max(g, h)) && !(Math.max(l, m) < Math.min(g, h)) && GeoGlobe.Geometry.segmentsIntersect(c, j))) {
                        b = !0;
                        break a
                    }
                }
            }
        } else b = a.intersects(this);
        return b
    }, getSortedSegments: function () {
        for (var a = this.components.length - 1, b = Array(a), c, d, e = 0; e < a; ++e)c = this.components[e], d = this.components[e + 1], b[e] = c.x < d.x ? {
            x1: c.x,
            y1: c.y,
            x2: d.x,
            y2: d.y
        } :
            {x1: d.x, y1: d.y, x2: c.x, y2: c.y};
        return b.sort(function (a, b) {
            return a.x1 - b.x1
        })
    }, splitWithSegment: function (a, b) {
        for (var c = !(b && b.edge === !1), d = b && b.tolerance, e = [], f = this.getVertices(), g = [], h = [], j = !1, l, m, n, p = {
            point: !0,
            tolerance: d
        }, q = null, o = 0, s = f.length - 2; o <= s; ++o)if (d = f[o], g.push(d.clone()), l = f[o + 1], m = {
                x1: d.x,
                y1: d.y,
                x2: l.x,
                y2: l.y
            }, m = GeoGlobe.Geometry.segmentsIntersect(a, m, p), m instanceof GeoGlobe.Geometry.Point && ((n = m.x === a.x1 && m.y === a.y1 || m.x === a.x2 && m.y === a.y2 || m.equals(d) || m.equals(l) ? !0 : !1) || c)) m.equals(h[h.length -
        1]) || h.push(m.clone()), !(o === 0 && m.equals(d)) && !m.equals(l) && (j = !0, m.equals(d) || g.push(m), e.push(new GeoGlobe.Geometry.LineString(g)), g = [m.clone()]);
        j && (g.push(l.clone()), e.push(new GeoGlobe.Geometry.LineString(g)));
        if (h.length > 0)var r = a.x1 < a.x2 ? 1 : -1, t = a.y1 < a.y2 ? 1 : -1, q = {
            lines: e, points: h.sort(function (a, b) {
                return r * a.x - r * b.x || t * a.y - t * b.y
            })
        };
        return q
    }, split: function (a, b) {
        var c = null, d = b && b.mutual, e, f, g, h;
        if (a instanceof GeoGlobe.Geometry.LineString) {
            var j = this.getVertices(), l, m, n, p, q, o = [];
            g = [];
            for (var s =
                0, r = j.length - 2; s <= r; ++s) {
                l = j[s];
                m = j[s + 1];
                n = {x1: l.x, y1: l.y, x2: m.x, y2: m.y};
                h = h || [a];
                d && o.push(l.clone());
                for (var t = 0; t < h.length; ++t)if (p = h[t].splitWithSegment(n, b))if (q = p.lines, q.length > 0 && (q.unshift(t, 1), Array.prototype.splice.apply(h, q), t += q.length - 2), d)for (var u = 0, v = p.points.length; u < v; ++u)q = p.points[u], q.equals(l) || (o.push(q), g.push(new GeoGlobe.Geometry.LineString(o)), o = q.equals(m) ? [] : [q.clone()])
            }
            d && g.length > 0 && o.length > 0 && (o.push(m.clone()), g.push(new GeoGlobe.Geometry.LineString(o)))
        } else c =
            a.splitWith(this, b);
        h && h.length > 1 ? f = !0 : h = [];
        g && g.length > 1 ? e = !0 : g = [];
        if (f || e) c = d ? [g, h] : h;
        return c
    }, splitWith: function (a, b) {
        return a.split(this, b)
    }, getVertices: function (a) {
        return a === !0 ? [this.components[0], this.components[this.components.length - 1]] : a === !1 ? this.components.slice(1, this.components.length - 1) : this.components.slice()
    }, distanceTo: function (a, b) {
        var c = !(b && b.edge === !1) && b && b.details, d, e = {}, f = Number.POSITIVE_INFINITY;
        if (a instanceof GeoGlobe.Geometry.Point) {
            for (var g = this.getSortedSegments(),
                     h = a.x, j = a.y, l, m = 0, n = g.length; m < n; ++m)if (l = g[m], d = GeoGlobe.Geometry.distanceToSegment(a, l), d.distance < f) {
                if (f = d.distance, e = d, f === 0)break
            } else if (l.x2 > h && (j > l.y1 && j < l.y2 || j < l.y1 && j > l.y2))break;
            e = c ? {distance: e.distance, x0: e.x, y0: e.y, x1: h, y1: j} : e.distance
        } else if (a instanceof GeoGlobe.Geometry.LineString) {
            var g = this.getSortedSegments(), h = a.getSortedSegments(), p, q, o = h.length, s = {point: !0}, m = 0,
                n = g.length;
            a:for (; m < n; ++m) {
                j = g[m];
                l = j.x1;
                q = j.y1;
                for (var r = 0; r < o; ++r)if (d = h[r], p = GeoGlobe.Geometry.segmentsIntersect(j,
                        d, s)) {
                    f = 0;
                    e = {distance: 0, x0: p.x, y0: p.y, x1: p.x, y1: p.y};
                    break a
                } else if (d = GeoGlobe.Geometry.distanceToSegment({
                        x: l,
                        y: q
                    }, d), d.distance < f) f = d.distance, e = {distance: f, x0: l, y0: q, x1: d.x, y1: d.y}
            }
            if (!c) e = e.distance;
            f !== 0 && j && (d = a.distanceTo(new GeoGlobe.Geometry.Point(j.x2, j.y2), b), m = c ? d.distance : d, m < f && (e = c ? {
                distance: f,
                x0: d.x1,
                y0: d.y1,
                x1: d.x0,
                y1: d.y0
            } : m))
        } else e = a.distanceTo(this, b), c && (e = {distance: e.distance, x0: e.x1, y0: e.y1, x1: e.x0, y1: e.y0});
        return e
    }, simplify: function (a) {
        if (this && this !== null) {
            var b = this.getVertices();
            if (b.length < 3)return this;
            var c = function (a, b, d, j) {
                for (var l = 0, m = 0, n = b, p; n < d; n++)p = Math.abs(0.5 * (a[b].x * a[d].y + a[d].x * a[n].y + a[n].x * a[b].y - a[d].x * a[b].y - a[n].x * a[d].y - a[b].x * a[n].y)) / Math.sqrt(Math.pow(a[b].x - a[d].x, 2) + Math.pow(a[b].y - a[d].y, 2)) * 2, p > l && (l = p, m = n);
                l > j && m != b && (e.push(m), c(a, b, m, j), c(a, m, d, j))
            }, d = b.length - 1, e = [];
            e.push(0);
            for (e.push(d); b[0].equals(b[d]);)d--, e.push(d);
            c(b, 0, d, a);
            a = [];
            e.sort(function (a, b) {
                return a - b
            });
            for (d = 0; d < e.length; d++)a.push(b[e[d]]);
            return new GeoGlobe.Geometry.LineString(a)
        } else return this
    },
    CLASS_NAME: "GeoGlobe.Geometry.LineString"
});
GeoGlobe.Geometry.LineString.createCurveLine = function (a) {
    for (var b = [], c = 0; c < a.length - 1; c++) {
        var d = GeoGlobe.Geometry.LineString.getCurveCoordinatesByTwoPoints(a[c], a[c + 1]);
        d && d.length > 0 && (b = b.concat(d))
    }
    return new Geo.Geometry.LineString(b)
};
GeoGlobe.Geometry.LineString.getCurveCoordinatesByTwoPoints = function (a, b) {
    if (!a || !b || !(a instanceof GeoGlobe.Geometry.Point) || !(b instanceof GeoGlobe.Geometry.Point))return null;
    curveCoordinates = [];
    var c, d, e, f = d = 0;
    if (typeof b == "undefined") typeof curveCoordinates != "undefined" && (curveCoordinates = []); else {
        var g = parseFloat(a.y), h = parseFloat(b.y), j = parseFloat(a.x), l = parseFloat(b.x);
        l > j && parseFloat(l - j) > 180 && j < 0 && (j = parseFloat(360 + j));
        j > l && parseFloat(j - l) > 180 && l < 0 && (l = parseFloat(360 + l));
        e = 0;
        h == g ? (c = 0, d =
            j - l) : l == j ? (c = Math.PI / 2, d = g - h) : (c = Math.atan((h - g) / (l - j)), d = (h - g) / Math.sin(c));
        e == 0 && (e = c + Math.PI / 5);
        d /= 2;
        c = d * Math.cos(e) + j;
        e = d * Math.sin(e) + g;
        for (d = 0; d < 31; d++)curveCoordinates.push(new GeoGlobe.Geometry.Point(j * (1 - 2 * f + f * f) + c * (2 * f - 2 * f * f) + l * f * f, g * (1 - 2 * f + f * f) + e * (2 * f - 2 * f * f) + h * f * f)), f += 1 / 30;
        return curveCoordinates
    }
};
GeoGlobe.Geometry.LinearRing = GeoGlobe.Class4OL(GeoGlobe.Geometry.LineString, {
    componentTypes: ["GeoGlobe.Geometry.Point"], addComponent: function (a, b) {
        var c = !1, d = this.components.pop();
        if (b != null || !a.equals(d)) c = GeoGlobe.Geometry.Collection.prototype.addComponent.apply(this, arguments);
        GeoGlobe.Geometry.Collection.prototype.addComponent.apply(this, [this.components[0]]);
        return c
    }, removeComponent: function () {
        var a = this.components && this.components.length > 3;
        a && (this.components.pop(), GeoGlobe.Geometry.Collection.prototype.removeComponent.apply(this,
            arguments), GeoGlobe.Geometry.Collection.prototype.addComponent.apply(this, [this.components[0]]));
        return a
    }, move: function (a, b) {
        for (var c = 0, d = this.components.length; c < d - 1; c++)this.components[c].move(a, b)
    }, rotate: function (a, b) {
        for (var c = 0, d = this.components.length; c < d - 1; ++c)this.components[c].rotate(a, b)
    }, resize: function (a, b, c) {
        for (var d = 0, e = this.components.length; d < e - 1; ++d)this.components[d].resize(a, b, c);
        return this
    }, transform: function (a, b) {
        if (a && b) {
            for (var c = 0, d = this.components.length; c < d - 1; c++)this.components[c].transform(a,
                b);
            this.bounds = null
        }
        return this
    }, getCentroid: function () {
        if (this.components) {
            var a = this.components.length;
            if (a > 0 && a <= 2)return this.components[0].clone(); else if (a > 2) {
                var b = 0, c = 0, d = this.components[0].x, e = this.components[0].y, f = -1 * this.getArea();
                if (f != 0) {
                    for (var g = 0; g < a - 1; g++) {
                        var h = this.components[g], j = this.components[g + 1];
                        b += (h.x + j.x - 2 * d) * ((h.x - d) * (j.y - e) - (j.x - d) * (h.y - e));
                        c += (h.y + j.y - 2 * e) * ((h.x - d) * (j.y - e) - (j.x - d) * (h.y - e))
                    }
                    b = d + b / (6 * f);
                    a = e + c / (6 * f)
                } else {
                    for (g = 0; g < a - 1; g++)b += this.components[g].x, c += this.components[g].y;
                    b /= a - 1;
                    a = c / (a - 1)
                }
                return new GeoGlobe.Geometry.Point(b, a)
            } else return null
        }
    }, getArea: function () {
        var a = 0;
        if (this.components && this.components.length > 2) {
            for (var b = a = 0, c = this.components.length; b < c - 1; b++) {
                var d = this.components[b], e = this.components[b + 1];
                a += (d.x + e.x) * (e.y - d.y)
            }
            a = -a / 2
        }
        return a
    }, getGeodesicArea: function (a) {
        var b = this;
        if (a) {
            var c = new GeoGlobe.SpatialReference("EPSG:4326");
            c.equals(a) || (b = this.clone().transform(a, c))
        }
        a = 0;
        c = b.components && b.components.length;
        if (c > 2) {
            for (var d, e, f = 0; f < c - 1; f++)d =
                b.components[f], e = b.components[f + 1], a += GeoGlobe.Util.rad(e.x - d.x) * (2 + Math.sin(GeoGlobe.Util.rad(d.y)) + Math.sin(GeoGlobe.Util.rad(e.y)));
            a = a * 40680631590769 / 2
        }
        return a
    }, containsPoint: function (a) {
        for (var b = GeoGlobe.Number.limitSigDigs, c = b(a.x, 14), a = b(a.y, 14), d = this.components.length - 1, e, f, g, h, j, l = 0, m = 0; m < d; ++m)if (e = this.components[m], g = b(e.x, 14), e = b(e.y, 14), f = this.components[m + 1], h = b(f.x, 14), f = b(f.y, 14), e == f) {
            if (a == e && (g <= h && c >= g && c <= h || g >= h && c <= g && c >= h)) {
                l = -1;
                break
            }
        } else {
            j = b((a - f) * ((h - g) / (f - e)) + h, 14);
            if (j == c && (e < f && a >= e && a <= f || e > f && a <= e && a >= f)) {
                l = -1;
                break
            }
            j <= c || g != h && (j < Math.min(g, h) || j > Math.max(g, h)) || (e < f && a >= e && a < f || e > f && a < e && a >= f) && ++l
        }
        return l == -1 ? 1 : !!(l & 1)
    }, intersects: function (a) {
        var b = !1;
        if (a.CLASS_NAME == "GeoGlobe.Geometry.Point") b = this.containsPoint(a); else if (a.CLASS_NAME == "GeoGlobe.Geometry.LineString") b = a.intersects(this); else if (a.CLASS_NAME == "GeoGlobe.Geometry.LinearRing") b = GeoGlobe.Geometry.LineString.prototype.intersects.apply(this, [a]); else for (var c = 0, d = a.components.length; c <
        d; ++c)if (b = a.components[c].intersects(this))break;
        return b
    }, getVertices: function (a) {
        return a === !0 ? [] : this.components.slice(0, this.components.length - 1)
    }, CLASS_NAME: "GeoGlobe.Geometry.LinearRing"
});
GeoGlobe.Geometry.Polygon = GeoGlobe.Class4OL(GeoGlobe.Geometry.Collection, {
    componentTypes: ["GeoGlobe.Geometry.LinearRing"], getArea: function () {
        var a = 0;
        if (this.components && this.components.length > 0) {
            a += Math.abs(this.components[0].getArea());
            for (var b = 1, c = this.components.length; b < c; b++)a -= Math.abs(this.components[b].getArea())
        }
        return a
    }, getGeodesicArea: function (a) {
        var b = 0;
        if (this.components && this.components.length > 0) {
            b += Math.abs(this.components[0].getGeodesicArea(a));
            for (var c = 1, d = this.components.length; c <
            d; c++)b -= Math.abs(this.components[c].getGeodesicArea(a))
        }
        return b
    }, containsPoint: function (a) {
        var b = this.components.length, c = !1;
        if (b > 0 && (c = this.components[0].containsPoint(a), c !== 1 && c && b > 1))for (var d, e = 1; e < b; ++e)if (d = this.components[e].containsPoint(a)) {
            c = d === 1 ? 1 : !1;
            break
        }
        return c
    }, intersects: function (a) {
        var b = !1, c, d;
        if (a.CLASS_NAME == "GeoGlobe.Geometry.Point") b = this.containsPoint(a); else if (a.CLASS_NAME == "GeoGlobe.Geometry.LineString" || a.CLASS_NAME == "GeoGlobe.Geometry.LinearRing") {
            c = 0;
            for (d = this.components.length; c <
            d; ++c)if (b = a.intersects(this.components[c]))break;
            if (!b) {
                c = 0;
                for (d = a.components.length; c < d; ++c)if (b = this.containsPoint(a.components[c]))break
            }
        } else {
            c = 0;
            for (d = a.components.length; c < d; ++c)if (b = this.intersects(a.components[c]))break
        }
        if (!b && a.CLASS_NAME == "GeoGlobe.Geometry.Polygon") {
            var e = this.components[0];
            c = 0;
            for (d = e.components.length; c < d; ++c)if (b = a.containsPoint(e.components[c]))break
        }
        return b
    }, distanceTo: function (a, b) {
        return b && b.edge === !1 && this.intersects(a) ? 0 : GeoGlobe.Geometry.Collection.prototype.distanceTo.apply(this,
            [a, b])
    }, CLASS_NAME: "GeoGlobe.Geometry.Polygon"
});
GeoGlobe.Geometry.Polygon.createRegularPolygon = function (a, b, c, d) {
    var e = Math.PI * (1 / c - 0.5);
    d && (e += d / 180 * Math.PI);
    for (var f, g = [], h = 0; h < c; ++h)f = e + h * 2 * Math.PI / c, d = a.x + b * Math.cos(f), f = a.y + b * Math.sin(f), g.push(new GeoGlobe.Geometry.Point(d, f));
    a = new GeoGlobe.Geometry.LinearRing(g);
    return new GeoGlobe.Geometry.Polygon([a])
};
GeoGlobe.Geometry.MultiLineString = GeoGlobe.Class4OL(GeoGlobe.Geometry.Collection, {
    componentTypes: ["GeoGlobe.Geometry.LineString"], split: function (a, b) {
        for (var c = null, d = b && b.mutual, e, f, g, h, j = [], l = [a], m = 0, n = this.components.length; m < n; ++m) {
            f = this.components[m];
            g = !1;
            for (var p = 0; p < l.length; ++p)if (e = f.split(l[p], b)) {
                if (d) {
                    g = e[0];
                    for (var q = 0, o = g.length; q < o; ++q)q === 0 && j.length ? j[j.length - 1].addComponent(g[q]) : j.push(new GeoGlobe.Geometry.MultiLineString([g[q]]));
                    g = !0;
                    e = e[1]
                }
                if (e.length) {
                    e.unshift(p, 1);
                    Array.prototype.splice.apply(l,
                        e);
                    break
                }
            }
            g || (j.length ? j[j.length - 1].addComponent(f.clone()) : j = [new GeoGlobe.Geometry.MultiLineString(f.clone())])
        }
        j && j.length > 1 ? g = !0 : j = [];
        l && l.length > 1 ? h = !0 : l = [];
        if (g || h) c = d ? [j, l] : l;
        return c
    }, splitWith: function (a, b) {
        var c = null, d = b && b.mutual, e, f, g, h, j, l;
        if (a instanceof GeoGlobe.Geometry.LineString) {
            l = [];
            j = [a];
            for (var m = 0, n = this.components.length; m < n; ++m) {
                g = !1;
                f = this.components[m];
                for (var p = 0; p < j.length; ++p)if (e = j[p].split(f, b)) {
                    d && (g = e[0], g.length && (g.unshift(p, 1), Array.prototype.splice.apply(j, g),
                        p += g.length - 2), e = e[1], e.length === 0 && (e = [f.clone()]));
                    g = 0;
                    for (var q = e.length; g < q; ++g)g === 0 && l.length ? l[l.length - 1].addComponent(e[g]) : l.push(new GeoGlobe.Geometry.MultiLineString([e[g]]));
                    g = !0
                }
                g || (l.length ? l[l.length - 1].addComponent(f.clone()) : l = [new GeoGlobe.Geometry.MultiLineString([f.clone()])])
            }
        } else c = a.split(this);
        j && j.length > 1 ? h = !0 : j = [];
        l && l.length > 1 ? g = !0 : l = [];
        if (h || g) c = d ? [j, l] : l;
        return c
    }, CLASS_NAME: "GeoGlobe.Geometry.MultiLineString"
});
GeoGlobe.Geometry.MultiPolygon = GeoGlobe.Class4OL(GeoGlobe.Geometry.Collection, {
    componentTypes: ["GeoGlobe.Geometry.Polygon"],
    CLASS_NAME: "GeoGlobe.Geometry.MultiPolygon"
});
GeoGlobe.State = {UNKNOWN: "Unknown", INSERT: "Insert", UPDATE: "Update", DELETE: "Delete"};
GeoGlobe.Feature = GeoGlobe.Class4OL({
    id: null,
    fid: null,
    lonlat: null,
    geometry: null,
    attributes: null,
    data: null,
    bounds: null,
    state: null,
    url: null,
    modified: null,
    initialize: function (a, b) {
        this.data = b != null ? b : {};
        this.id = GeoGlobe.Util.createUniqueID(this.CLASS_NAME + "_");
        this.lonlat = null;
        this.geometry = a ? a : null;
        this.state = null;
        this.attributes = {};
        if (b) this.attributes = GeoGlobe.Util.extend(this.attributes, b)
    },
    destroy: function () {
        this.data = this.lonlat = this.id = this.modified = this.geometry = null
    },
    clone: function () {
        return new GeoGlobe.Feature(this.geometry ?
            this.geometry.clone() : null, this.attributes)
    },
    createMarker: function () {
        return null
    },
    destroyMarker: function () {
    },
    createPopup: function () {
        return null
    },
    atPoint: function (a, b, c) {
        var d = !1;
        this.geometry && (d = this.geometry.atPoint(a, b, c));
        return d
    },
    destroyPopup: function () {
    },
    toState: function (a) {
        if (a == GeoGlobe.State.UPDATE)switch (this.state) {
            case GeoGlobe.State.UNKNOWN:
            case GeoGlobe.State.DELETE:
                this.state = a
        } else if (a == GeoGlobe.State.INSERT)switch (this.state) {
            case GeoGlobe.State.UNKNOWN:
                break;
            default:
                this.state =
                    a
        } else if (a == GeoGlobe.State.DELETE)switch (this.state) {
            case GeoGlobe.State.UNKNOWN:
            case GeoGlobe.State.UPDATE:
                this.state = a
        } else if (a == GeoGlobe.State.UNKNOWN) this.state = a
    },
    CLASS_NAME: "GeoGlobe.Feature"
});
GeoGlobe.Feature.getBoundsByFeatures = function (a) {
    for (var b = a.length, c = Array(b), d = 0; d < b; ++d)c[d] = a[d].geometry;
    a = new GeoGlobe.Geometry.Collection(c);
    a.calculateBounds();
    return a.bounds
};
GeoGlobe.Feature.fromGeoJson = function (a) {
    var b;
    GeoGlobe.Format && GeoGlobe.Format.GeoJSON && (format = new GeoGlobe.Format.GeoJSON, b = format.read(a));
    return b
};
GeoGlobe.Filter = GeoGlobe.Class4OL({
    initialize: function (a) {
        GeoGlobe.Util.extend(this, a)
    }, destroy: function () {
    }, evaluate: function () {
        return !0
    }, clone: function () {
        return null
    }, toString: function () {
        return GeoGlobe.Format && GeoGlobe.Format.CQL ? GeoGlobe.Format.CQL.prototype.write(this) : Object.prototype.toString.call(this)
    }, CLASS_NAME: "GeoGlobe.Filter"
});
GeoGlobe.Filter.FeatureId = GeoGlobe.Class4OL(GeoGlobe.Filter, {
    fids: null, type: "FID", initialize: function (a) {
        this.fids = [];
        GeoGlobe.Filter.prototype.initialize.apply(this, [a])
    }, evaluate: function (a) {
        for (var b = 0, c = this.fids.length; b < c; b++)if ((a.fid || a.id) == this.fids[b])return !0;
        return !1
    }, clone: function () {
        var a = new GeoGlobe.Filter.FeatureId;
        GeoGlobe.Util.extend(a, this);
        a.fids = this.fids.slice();
        return a
    }, CLASS_NAME: "GeoGlobe.Filter.FeatureId"
});
GeoGlobe.Filter.Logical = GeoGlobe.Class4OL(GeoGlobe.Filter, {
    filters: null, type: null, initialize: function (a) {
        this.filters = [];
        GeoGlobe.Filter.prototype.initialize.apply(this, [a])
    }, destroy: function () {
        this.filters = null;
        GeoGlobe.Filter.prototype.destroy.apply(this)
    }, evaluate: function (a) {
        var b, c;
        switch (this.type) {
            case GeoGlobe.Filter.Logical.AND:
                b = 0;
                for (c = this.filters.length; b < c; b++)if (this.filters[b].evaluate(a) == !1)return !1;
                return !0;
            case GeoGlobe.Filter.Logical.OR:
                b = 0;
                for (c = this.filters.length; b < c; b++)if (this.filters[b].evaluate(a) ==
                    !0)return !0;
                return !1;
            case GeoGlobe.Filter.Logical.NOT:
                return !this.filters[0].evaluate(a)
        }
    }, clone: function () {
        for (var a = [], b = 0, c = this.filters.length; b < c; ++b)a.push(this.filters[b].clone());
        return new GeoGlobe.Filter.Logical({type: this.type, filters: a})
    }, CLASS_NAME: "GeoGlobe.Filter.Logical"
});
GeoGlobe.Filter.Logical.AND = "&&";
GeoGlobe.Filter.Logical.OR = "||";
GeoGlobe.Filter.Logical.NOT = "!";
GeoGlobe.Filter.Comparison = GeoGlobe.Class4OL(GeoGlobe.Filter, {
    type: null,
    property: null,
    value: null,
    matchCase: !0,
    lowerBoundary: null,
    upperBoundary: null,
    initialize: function (a) {
        GeoGlobe.Filter.prototype.initialize.apply(this, [a]);
        if (this.type === GeoGlobe.Filter.Comparison.LIKE && a.matchCase === void 0) this.matchCase = null
    },
    evaluate: function (a) {
        if (a instanceof GeoGlobe.Feature) a = a.attributes;
        var b = !1, a = a[this.property];
        if (a === void 0)return !1;
        switch (this.type) {
            case GeoGlobe.Filter.Comparison.EQUAL_TO:
                b = this.value;
                b = !this.matchCase && typeof a == "string" && typeof b == "string" ? a.toUpperCase() == b.toUpperCase() : a == b;
                break;
            case GeoGlobe.Filter.Comparison.NOT_EQUAL_TO:
                b = this.value;
                b = !this.matchCase && typeof a == "string" && typeof b == "string" ? a.toUpperCase() != b.toUpperCase() : a != b;
                break;
            case GeoGlobe.Filter.Comparison.LESS_THAN:
                b = a < this.value;
                break;
            case GeoGlobe.Filter.Comparison.GREATER_THAN:
                b = a > this.value;
                break;
            case GeoGlobe.Filter.Comparison.LESS_THAN_OR_EQUAL_TO:
                b = a <= this.value;
                break;
            case GeoGlobe.Filter.Comparison.GREATER_THAN_OR_EQUAL_TO:
                b =
                    a >= this.value;
                break;
            case GeoGlobe.Filter.Comparison.BETWEEN:
                b = a >= this.lowerBoundary && a <= this.upperBoundary;
                break;
            case GeoGlobe.Filter.Comparison.LIKE:
                b = RegExp(this.value, "gi").test(a);
                break;
            case GeoGlobe.Filter.Comparison.IS_NULL:
                b = a === null
        }
        return b
    },
    value2regex: function (a, b, c) {
        if (a == ".")throw Error("'.' is an unsupported wildCard character for GeoGlobe.Filter.Comparison");
        a = a ? a : "*";
        b = b ? b : ".";
        this.value = this.value.replace(RegExp("\\" + (c ? c : "!") + "(.|$)", "g"), "\\$1");
        this.value = this.value.replace(RegExp("\\" +
            b, "g"), ".");
        this.value = this.value.replace(RegExp("\\" + a, "g"), ".*");
        this.value = this.value.replace(RegExp("\\\\.\\*", "g"), "\\" + a);
        return this.value = this.value.replace(RegExp("\\\\\\.", "g"), "\\" + b)
    },
    regex2value: function () {
        var a = this.value, a = a.replace(/!/g, "!!"), a = a.replace(/(\\)?\\\./g, function (a, c) {
            return c ? a : "!."
        }), a = a.replace(/(\\)?\\\*/g, function (a, c) {
            return c ? a : "!*"
        }), a = a.replace(/\\\\/g, "\\");
        return a = a.replace(/\.\*/g, "*")
    },
    clone: function () {
        return GeoGlobe.Util.extend(new GeoGlobe.Filter.Comparison,
            this)
    },
    CLASS_NAME: "GeoGlobe.Filter.Comparison"
});
GeoGlobe.Filter.Comparison.EQUAL_TO = "==";
GeoGlobe.Filter.Comparison.NOT_EQUAL_TO = "!=";
GeoGlobe.Filter.Comparison.LESS_THAN = "<";
GeoGlobe.Filter.Comparison.GREATER_THAN = ">";
GeoGlobe.Filter.Comparison.LESS_THAN_OR_EQUAL_TO = "<=";
GeoGlobe.Filter.Comparison.GREATER_THAN_OR_EQUAL_TO = ">=";
GeoGlobe.Filter.Comparison.BETWEEN = "..";
GeoGlobe.Filter.Comparison.LIKE = "~";
GeoGlobe.Filter.Comparison.IS_NULL = "NULL";
GeoGlobe.Filter.Spatial = GeoGlobe.Class4OL(GeoGlobe.Filter, {
    type: null, property: null, value: null, distance: null, distanceUnits: null, evaluate: function (a) {
        var b = !1;
        switch (this.type) {
            case GeoGlobe.Filter.Spatial.BBOX:
            case GeoGlobe.Filter.Spatial.INTERSECTS:
                if (a.geometry) {
                    var c = this.value;
                    this.value.CLASS_NAME == "GeoGlobe.LngLatBounds" && (c = this.value.toGeometry());
                    a.geometry.intersects(c) && (b = !0)
                }
                break;
            default:
                throw Error("evaluate is not implemented for this filter type.");
        }
        return b
    }, clone: function () {
        var a =
            GeoGlobe.Util.applyDefaults({value: this.value && this.value.clone && this.value.clone()}, this);
        return new GeoGlobe.Filter.Spatial(a)
    }, CLASS_NAME: "GeoGlobe.Filter.Spatial"
});
GeoGlobe.Filter.Spatial.BBOX = "BBOX";
GeoGlobe.Filter.Spatial.INTERSECTS = "INTERSECTS";
GeoGlobe.Filter.Spatial.DWITHIN = "DWITHIN";
GeoGlobe.Filter.Spatial.WITHIN = "WITHIN";
GeoGlobe.Filter.Spatial.CONTAINS = "CONTAINS";
GeoGlobe.Filter.Function = GeoGlobe.Class4OL(GeoGlobe.Filter, {
    name: null,
    params: null,
    CLASS_NAME: "GeoGlobe.Filter.Function"
});
GeoGlobe.Protocol = GeoGlobe.Class4OL({
    format: null, options: null, autoDestroy: !0, defaultFilter: null, initialize: function (a) {
        a = a || {};
        GeoGlobe.Util.extend(this, a);
        this.options = a
    }, mergeWithDefaultFilter: function (a) {
        return a && this.defaultFilter ? new GeoGlobe.Filter.Logical({
            type: GeoGlobe.Filter.Logical.AND,
            filters: [this.defaultFilter, a]
        }) : a || this.defaultFilter || void 0
    }, destroy: function () {
        this.format = this.options = null
    }, read: function (a) {
        a = a || {};
        a.filter = this.mergeWithDefaultFilter(a.filter)
    }, create: function () {
    },
    update: function () {
    }, "delete": function () {
    }, commit: function () {
    }, abort: function () {
    }, createCallback: function (a, b, c) {
        return GeoGlobe.Function.bind(function () {
            a.apply(this, [b, c])
        }, this)
    }, CLASS_NAME: "GeoGlobe.Protocol"
});
GeoGlobe.Protocol.Response = GeoGlobe.Class4OL({
    code: null,
    requestType: null,
    last: !0,
    features: null,
    data: null,
    reqFeatures: null,
    priv: null,
    error: null,
    initialize: function (a) {
        GeoGlobe.Util.extend(this, a)
    },
    success: function () {
        return this.code > 0
    },
    CLASS_NAME: "GeoGlobe.Protocol.Response"
});
GeoGlobe.Protocol.Response.SUCCESS = 1;
GeoGlobe.Protocol.Response.FAILURE = 0;
GeoGlobe.Protocol.HTTP = GeoGlobe.Class4OL(GeoGlobe.Protocol, {
    url: null,
    headers: null,
    params: null,
    callback: null,
    scope: null,
    readWithPOST: !1,
    updateWithPOST: !1,
    deleteWithPOST: !1,
    wildcarded: !1,
    srsInBBOX: !1,
    initialize: function () {
        this.params = {};
        this.headers = {};
        GeoGlobe.Protocol.prototype.initialize.apply(this, arguments);
        if (!this.filterToParams && GeoGlobe.Format.QueryStringFilter) {
            var a = new GeoGlobe.Format.QueryStringFilter({wildcarded: this.wildcarded, srsInBBOX: this.srsInBBOX});
            this.filterToParams = function (b,
                                            c) {
                return a.write(b, c)
            }
        }
    },
    destroy: function () {
        this.headers = this.params = null;
        GeoGlobe.Protocol.prototype.destroy.apply(this)
    },
    read: function (a) {
        GeoGlobe.Protocol.prototype.read.apply(this, arguments);
        a = a || {};
        a.params = GeoGlobe.Util.applyDefaults(a.params, this.options.params);
        a = GeoGlobe.Util.applyDefaults(a, this.options);
        if (a.filter && this.filterToParams) a.params = this.filterToParams(a.filter, a.params);
        var b = a.readWithPOST !== void 0 ? a.readWithPOST : this.readWithPOST,
            c = new GeoGlobe.Protocol.Response({requestType: "read"});
        b ? (b = a.headers || {}, b["Content-Type"] = "application/x-www-form-urlencoded", c.priv = GeoGlobe.Request.POST({
            url: a.url,
            callback: this.createCallback(this.handleRead, c, a),
            data: GeoGlobe.Util.getParameterString(a.params),
            headers: b
        })) : c.priv = GeoGlobe.Request.GET({
            url: a.url,
            callback: this.createCallback(this.handleRead, c, a),
            params: a.params,
            headers: a.headers
        });
        return c
    },
    handleRead: function (a, b) {
        this.handleResponse(a, b)
    },
    create: function (a, b) {
        var b = GeoGlobe.Util.applyDefaults(b, this.options), c = new GeoGlobe.Protocol.Response({
            reqFeatures: a,
            requestType: "create"
        });
        c.priv = GeoGlobe.Request.POST({
            url: b.url,
            callback: this.createCallback(this.handleCreate, c, b),
            headers: b.headers,
            data: this.format.write(a)
        });
        return c
    },
    handleCreate: function (a, b) {
        this.handleResponse(a, b)
    },
    update: function (a, b) {
        var b = b || {}, c = b.url || a.url || this.options.url + "/" + a.fid,
            b = GeoGlobe.Util.applyDefaults(b, this.options),
            d = new GeoGlobe.Protocol.Response({reqFeatures: a, requestType: "update"});
        d.priv = GeoGlobe.Request[this.updateWithPOST ? "POST" : "PUT"]({
            url: c, callback: this.createCallback(this.handleUpdate,
                d, b), headers: b.headers, data: this.format.write(a)
        });
        return d
    },
    handleUpdate: function (a, b) {
        this.handleResponse(a, b)
    },
    "delete": function (a, b) {
        var b = b || {}, c = b.url || a.url || this.options.url + "/" + a.fid,
            b = GeoGlobe.Util.applyDefaults(b, this.options),
            d = new GeoGlobe.Protocol.Response({reqFeatures: a, requestType: "delete"}),
            e = this.deleteWithPOST ? "POST" : "DELETE",
            c = {url: c, callback: this.createCallback(this.handleDelete, d, b), headers: b.headers};
        if (this.deleteWithPOST) c.data = this.format.write(a);
        d.priv = GeoGlobe.Request[e](c);
        return d
    },
    handleDelete: function (a, b) {
        this.handleResponse(a, b)
    },
    handleResponse: function (a, b) {
        var c = a.priv;
        if (b.callback) {
            if (c.status >= 200 && c.status < 300) {
                if (a.requestType != "delete") a.features = this.parseFeatures(c);
                a.code = GeoGlobe.Protocol.Response.SUCCESS
            } else a.code = GeoGlobe.Protocol.Response.FAILURE;
            b.callback.call(b.scope, a)
        }
    },
    parseFeatures: function (a) {
        var b = a.responseXML;
        if (!b || !b.documentElement) b = a.responseText;
        if (!b || b.length <= 0)return null;
        return this.format.read(b)
    },
    commit: function (a, b) {
        function c(a) {
            for (var b =
                a.features ? a.features.length : 0, c = Array(b), e = 0; e < b; ++e)c[e] = a.features[e].fid;
            o.insertIds = c;
            d.apply(this, [a])
        }

        function d(a) {
            this.callUserCallback(a, b);
            q = q && a.success();
            f++;
            if (f >= p && b.callback) o.code = q ? GeoGlobe.Protocol.Response.SUCCESS : GeoGlobe.Protocol.Response.FAILURE, b.callback.apply(b.scope, [o])
        }

        var b = GeoGlobe.Util.applyDefaults(b, this.options), e = [], f = 0, g = {};
        g[GeoGlobe.State.INSERT] = [];
        g[GeoGlobe.State.UPDATE] = [];
        g[GeoGlobe.State.DELETE] = [];
        for (var h, j, l = [], m = 0, n = a.length; m < n; ++m)if (h = a[m], j = g[h.state]) j.push(h),
            l.push(h);
        var p = (g[GeoGlobe.State.INSERT].length > 0 ? 1 : 0) + g[GeoGlobe.State.UPDATE].length + g[GeoGlobe.State.DELETE].length,
            q = !0, o = new GeoGlobe.Protocol.Response({reqFeatures: l});
        h = g[GeoGlobe.State.INSERT];
        h.length > 0 && e.push(this.create(h, GeoGlobe.Util.applyDefaults({callback: c, scope: this}, b.create)));
        h = g[GeoGlobe.State.UPDATE];
        for (m = h.length - 1; m >= 0; --m)e.push(this.update(h[m], GeoGlobe.Util.applyDefaults({
            callback: d,
            scope: this
        }, b.update)));
        h = g[GeoGlobe.State.DELETE];
        for (m = h.length - 1; m >= 0; --m)e.push(this["delete"](h[m],
            GeoGlobe.Util.applyDefaults({callback: d, scope: this}, b["delete"])));
        return e
    },
    abort: function (a) {
        a && a.priv.abort()
    },
    callUserCallback: function (a, b) {
        var c = b[a.requestType];
        c && c.callback && c.callback.call(c.scope, a)
    },
    CLASS_NAME: "GeoGlobe.Protocol.HTTP"
});
GeoGlobe.Protocol.WFS = function (a) {
    var a = GeoGlobe.Util.applyDefaults(a, GeoGlobe.Protocol.WFS.DEFAULTS),
        b = GeoGlobe.Protocol.WFS["v" + a.version.replace(/\./g, "_")];
    if (!b)throw"Unsupported WFS version: " + a.version;
    return new b(a)
};
GeoGlobe.Protocol.WFS.DEFAULTS = {version: "1.0.0"};
GeoGlobe.Protocol.WFS.v1 = GeoGlobe.Class4OL(GeoGlobe.Protocol, {
    version: null,
    srsName: "EPSG:4326",
    featureType: null,
    featureNS: null,
    geometryName: "the_geom",
    schema: null,
    featurePrefix: "feature",
    formatOptions: null,
    readFormat: null,
    readOptions: null,
    initialize: function (a) {
        GeoGlobe.Protocol.prototype.initialize.apply(this, [a]);
        if (!a.format) this.format = GeoGlobe.Format.WFST(GeoGlobe.Util.extend({
            version: this.version,
            featureType: this.featureType,
            featureNS: this.featureNS,
            featurePrefix: this.featurePrefix,
            geometryName: this.geometryName,
            srsName: this.srsName,
            schema: this.schema
        }, this.formatOptions));
        !a.geometryName && parseFloat(this.format.version) > 1 && this.setGeometryName(null)
    },
    destroy: function () {
        this.options && !this.options.format && this.format.destroy();
        this.format = null;
        GeoGlobe.Protocol.prototype.destroy.apply(this)
    },
    read: function (a) {
        GeoGlobe.Protocol.prototype.read.apply(this, arguments);
        a = GeoGlobe.Util.extend({}, a);
        GeoGlobe.Util.applyDefaults(a, this.options || {});
        var b = new GeoGlobe.Protocol.Response({requestType: "read"}),
            c = GeoGlobe.Format.XML.prototype.write.apply(this.format,
                [this.format.writeNode("wfs:GetFeature", a)]);
        b.priv = GeoGlobe.Request.POST({
            url: a.url,
            callback: this.createCallback(this.handleRead, b, a),
            params: a.params,
            headers: a.headers,
            data: c
        });
        return b
    },
    setFeatureType: function (a) {
        this.featureType = a;
        this.format.featureType = a
    },
    setGeometryName: function (a) {
        this.geometryName = a;
        this.format.geometryName = a
    },
    handleRead: function (a, b) {
        b = GeoGlobe.Util.extend({}, b);
        GeoGlobe.Util.applyDefaults(b, this.options);
        if (b.callback) {
            var c = a.priv;
            c.status >= 200 && c.status < 300 ? (c = this.parseResponse(c,
                b.readOptions)) && c.success !== !1 ? (b.readOptions && b.readOptions.output == "object" ? GeoGlobe.Util.extend(a, c) : a.features = c, a.code = GeoGlobe.Protocol.Response.SUCCESS) : (a.code = GeoGlobe.Protocol.Response.FAILURE, a.error = c) : a.code = GeoGlobe.Protocol.Response.FAILURE;
            b.callback.call(b.scope, a)
        }
    },
    parseResponse: function (a, b) {
        var c = a.responseXML;
        if (!c || !c.documentElement) c = a.responseText;
        if (!c || c.length <= 0)return null;
        var d = null;
        try {
            d = this.readFormat !== null ? this.readFormat.read(c) : this.format.read(c, b)
        } catch (e) {
            alert("\u7a0b\u5e8f\u8fd0\u884c\u5f02\u5e38\uff1a" +
                e.name + "\uff0c" + e.message)
        }
        if (!this.featureNS) c = this.readFormat || this.format, this.featureNS = c.featureNS, c.autoConfig = !1, this.geometryName || this.setGeometryName(c.geometryName);
        return d
    },
    commit: function (a, b) {
        b = GeoGlobe.Util.extend({}, b);
        GeoGlobe.Util.applyDefaults(b, this.options);
        var c = new GeoGlobe.Protocol.Response({requestType: "commit", reqFeatures: a});
        c.priv = GeoGlobe.Request.POST({
            url: b.url,
            headers: b.headers,
            data: this.format.write(a, b),
            callback: this.createCallback(this.handleCommit, c, b)
        });
        return c
    },
    handleCommit: function (a, b) {
        if (b.callback) {
            var c = a.priv, d = c.responseXML;
            if (!d || !d.documentElement) d = c.responseText;
            c = this.format.read(d) || {};
            a.insertIds = c.insertIds || [];
            c.success ? a.code = GeoGlobe.Protocol.Response.SUCCESS : (a.code = GeoGlobe.Protocol.Response.FAILURE, a.error = c);
            b.callback.call(b.scope, a)
        }
    },
    filterDelete: function (a, b) {
        b = GeoGlobe.Util.extend({}, b);
        GeoGlobe.Util.applyDefaults(b, this.options);
        new GeoGlobe.Protocol.Response({requestType: "commit"});
        var c = this.format.createElementNSPlus("wfs:Transaction",
            {attributes: {service: "WFS", version: this.version}}),
            d = this.format.createElementNSPlus("wfs:Delete", {attributes: {typeName: (b.featureNS ? this.featurePrefix + ":" : "") + b.featureType}});
        b.featureNS && d.setAttribute("xmlns:" + this.featurePrefix, b.featureNS);
        var e = this.format.writeNode("ogc:Filter", a);
        d.appendChild(e);
        c.appendChild(d);
        c = GeoGlobe.Format.XML.prototype.write.apply(this.format, [c]);
        return GeoGlobe.Request.POST({
            url: this.url, callback: b.callback || function () {
            }, data: c
        })
    },
    abort: function (a) {
        a && a.priv.abort()
    },
    CLASS_NAME: "GeoGlobe.Protocol.WFS.v1"
});
GeoGlobe.Protocol.WFS.v1_0_0 = GeoGlobe.Class4OL(GeoGlobe.Protocol.WFS.v1, {
    version: "1.0.0",
    CLASS_NAME: "GeoGlobe.Protocol.WFS.v1_0_0"
});
GeoGlobe.Protocol.WFS.v1_1_0 = GeoGlobe.Class4OL(GeoGlobe.Protocol.WFS.v1, {
    version: "1.1.0", initialize: function () {
        GeoGlobe.Protocol.WFS.v1.prototype.initialize.apply(this, arguments);
        if (this.outputFormat && !this.readFormat)if (this.outputFormat.toLowerCase() == "gml2") this.readFormat = new GeoGlobe.Format.GML.v2({
            featureType: this.featureType,
            featureNS: this.featureNS,
            geometryName: this.geometryName
        }); else if (this.outputFormat.toLowerCase() == "json") this.readFormat = new GeoGlobe.Format.GeoJSON
    }, CLASS_NAME: "GeoGlobe.Protocol.WFS.v1_1_0"
});
GeoGlobe.Protocol.CSW = function (a) {
    var a = GeoGlobe.Util.applyDefaults(a, GeoGlobe.Protocol.CSW.DEFAULTS),
        b = GeoGlobe.Protocol.CSW["v" + a.version.replace(/\./g, "_")];
    if (!b)throw"Unsupported CSW version: " + a.version;
    return new b(a)
};
GeoGlobe.Protocol.CSW.DEFAULTS = {version: "2.0.2"};
GeoGlobe.Protocol.CSW.v2_0_2 = GeoGlobe.Class4OL(GeoGlobe.Protocol, {
    formatOptions: null, initialize: function (a) {
        GeoGlobe.Protocol.prototype.initialize.apply(this, [a]);
        if (!a.format) this.format = new GeoGlobe.Format.CSWGetRecords.v2_0_2(GeoGlobe.Util.extend({}, this.formatOptions))
    }, destroy: function () {
        this.options && !this.options.format && this.format.destroy();
        this.format = null;
        GeoGlobe.Protocol.prototype.destroy.apply(this)
    }, read: function (a) {
        a = GeoGlobe.Util.extend({}, a);
        GeoGlobe.Util.applyDefaults(a, this.options ||
            {});
        var b = new GeoGlobe.Protocol.Response({requestType: "read"}), c = this.format.write(a.params || a);
        b.priv = GeoGlobe.Request.POST({
            url: a.url,
            callback: this.createCallback(this.handleRead, b, a),
            params: a.params,
            headers: a.headers,
            data: c
        });
        return b
    }, handleRead: function (a, b) {
        if (b.callback) {
            var c = a.priv;
            c.status >= 200 && c.status < 300 ? (a.data = this.parseData(c), a.code = GeoGlobe.Protocol.Response.SUCCESS) : a.code = GeoGlobe.Protocol.Response.FAILURE;
            b.callback.call(b.scope, a)
        }
    }, parseData: function (a) {
        var b = a.responseXML;
        if (!b || !b.documentElement) b = a.responseText;
        if (!b || b.length <= 0)return null;
        return this.format.read(b)
    }, CLASS_NAME: "GeoGlobe.Protocol.CSW.v2_0_2"
});
GeoGlobe.Protocol.Script = GeoGlobe.Class4OL(GeoGlobe.Protocol, {
    url: null,
    params: null,
    callback: null,
    callbackTemplate: "GeoGlobe.Protocol.Script.registry.${id}",
    callbackKey: "callback",
    callbackPrefix: "",
    scope: null,
    format: null,
    pendingRequests: null,
    srsInBBOX: !1,
    initialize: function () {
        this.params = {};
        this.pendingRequests = {};
        GeoGlobe.Protocol.prototype.initialize.apply(this, arguments);
        if (!this.format) this.format = new GeoGlobe.Format.GeoJSON;
        if (!this.filterToParams && GeoGlobe.Format.QueryStringFilter) {
            var a = new GeoGlobe.Format.QueryStringFilter({srsInBBOX: this.srsInBBOX});
            this.filterToParams = function (b, c) {
                return a.write(b, c)
            }
        }
    },
    read: function (a) {
        GeoGlobe.Protocol.prototype.read.apply(this, arguments);
        a = GeoGlobe.Util.applyDefaults(a, this.options);
        a.params = GeoGlobe.Util.applyDefaults(a.params, this.options.params);
        if (a.filter && this.filterToParams) a.params = this.filterToParams(a.filter, a.params);
        var b = new GeoGlobe.Protocol.Response({requestType: "read"}),
            c = this.createRequest(a.url, a.params, GeoGlobe.Function.bind(function (c) {
                b.data = c;
                this.handleRead(b, a)
            }, this));
        b.priv = c;
        return b
    },
    createRequest: function (a, b, c) {
        var c = GeoGlobe.Protocol.Script.register(c), d = GeoGlobe.String.format(this.callbackTemplate, {id: c}),
            b = GeoGlobe.Util.extend({}, b);
        b[this.callbackKey] = this.callbackPrefix + d;
        a = GeoGlobe.Util.urlAppend(a, GeoGlobe.Util.getParameterString(b));
        b = document.createElement("script");
        b.type = "text/javascript";
        b.src = a;
        b.id = "GeoGlobe_Protocol_Script_" + c;
        this.pendingRequests[b.id] = b;
        document.getElementsByTagName("head")[0].appendChild(b);
        return b
    },
    destroyRequest: function (a) {
        GeoGlobe.Protocol.Script.unregister(a.id.split("_").pop());
        delete this.pendingRequests[a.id];
        a.parentNode && a.parentNode.removeChild(a)
    },
    handleRead: function (a, b) {
        this.handleResponse(a, b)
    },
    handleResponse: function (a, b) {
        if (b.callback) a.data ? (a.features = this.parseFeatures(a.data), a.code = GeoGlobe.Protocol.Response.SUCCESS) : a.code = GeoGlobe.Protocol.Response.FAILURE, this.destroyRequest(a.priv), b.callback.call(b.scope, a)
    },
    parseFeatures: function (a) {
        return this.format.read(a)
    },
    abort: function (a) {
        if (a) this.destroyRequest(a.priv); else for (var b in this.pendingRequests)this.destroyRequest(this.pendingRequests[b])
    },
    destroy: function () {
        this.abort();
        delete this.params;
        delete this.format;
        GeoGlobe.Protocol.prototype.destroy.apply(this)
    },
    CLASS_NAME: "GeoGlobe.Protocol.Script"
});
(function () {
    var a = GeoGlobe.Protocol.Script, b = 0;
    a.registry = {};
    a.register = function (c) {
        var d = "c" + ++b;
        a.registry[d] = function () {
            c.apply(this, arguments)
        };
        return d
    };
    a.unregister = function (b) {
        delete a.registry[b]
    }
})();
GeoGlobe.Format = GeoGlobe.Class4OL({
    options: null,
    externalProjection: null,
    internalProjection: null,
    data: null,
    keepData: !1,
    initialize: function (a) {
        GeoGlobe.Util.extend(this, a);
        this.options = a
    },
    destroy: function () {
    },
    read: function () {
        throw Error("Read not implemented.");
    },
    write: function () {
        throw Error("Write not implemented.");
    },
    CLASS_NAME: "GeoGlobe.Format"
});
GeoGlobe.Format.XML = GeoGlobe.Class4OL(GeoGlobe.Format, {
    namespaces: null,
    namespaceAlias: null,
    defaultPrefix: null,
    readers: {},
    writers: {},
    xmldom: null,
    initialize: function (a) {
        if (window.ActiveXObject) this.xmldom = new ActiveXObject("Microsoft.XMLDOM");
        GeoGlobe.Format.prototype.initialize.apply(this, [a]);
        this.namespaces = GeoGlobe.Util.extend({}, this.namespaces);
        this.namespaceAlias = {};
        for (var b in this.namespaces)this.namespaceAlias[this.namespaces[b]] = b
    },
    destroy: function () {
        this.xmldom = null;
        GeoGlobe.Format.prototype.destroy.apply(this,
            arguments)
    },
    setNamespace: function (a, b) {
        this.namespaces[a] = b;
        this.namespaceAlias[b] = a
    },
    read: function (a) {
        var b = a.indexOf("<");
        b > 0 && (a = a.substring(b));
        b = GeoGlobe.Util.Try(GeoGlobe.Function.bind(function () {
            var b;
            b = window.ActiveXObject && !this.xmldom ? new ActiveXObject("Microsoft.XMLDOM") : this.xmldom;
            b.loadXML(a);
            return b
        }, this), function () {
            return (new DOMParser).parseFromString(a, "text/xml")
        }, function () {
            var b = new XMLHttpRequest;
            b.open("GET", "data:text/xml;charset=utf-8," + encodeURIComponent(a), !1);
            b.overrideMimeType &&
            b.overrideMimeType("text/xml");
            b.send(null);
            return b.responseXML
        });
        if (this.keepData) this.data = b;
        return b
    },
    write: function (a) {
        if (a.xml) a = a.xml; else {
            var b = new XMLSerializer;
            if (a.nodeType == 1) {
                var c = document.implementation.createDocument("", "", null);
                c.importNode && (a = c.importNode(a, !0));
                c.appendChild(a);
                a = b.serializeToString(c)
            } else a = b.serializeToString(a)
        }
        return a
    },
    createElementNS: function (a, b) {
        return this.xmldom ? typeof a == "string" ? this.xmldom.createNode(1, b, a) : this.xmldom.createNode(1, b, "") : document.createElementNS(a,
            b)
    },
    createDocumentFragment: function () {
        return this.xmldom ? this.xmldom.createDocumentFragment() : document.createDocumentFragment()
    },
    createTextNode: function (a) {
        typeof a !== "string" && (a = String(a));
        return this.xmldom ? this.xmldom.createTextNode(a) : document.createTextNode(a)
    },
    getElementsByTagNameNS: function (a, b, c) {
        var d = [];
        if (a.getElementsByTagNameNS) d = a.getElementsByTagNameNS(b, c); else for (var a = a.getElementsByTagName("*"), e, f, g = 0, h = a.length; g < h; ++g)if (e = a[g], f = e.prefix ? e.prefix + ":" + c : c, c == "*" || f == e.nodeName) (b ==
        "*" || b == e.namespaceURI) && d.push(e);
        return d
    },
    getAttributeNodeNS: function (a, b, c) {
        var d = null;
        if (a.getAttributeNodeNS) d = a.getAttributeNodeNS(b, c); else for (var a = a.attributes, e, f, g = 0, h = a.length; g < h; ++g)if (e = a[g], e.namespaceURI == b && (f = e.prefix ? e.prefix + ":" + c : c, f == e.nodeName)) {
            d = e;
            break
        }
        return d
    },
    getAttributeNS: function (a, b, c) {
        var d = "";
        if (a.getAttributeNS) d = a.getAttributeNS(b, c) || ""; else if (a = this.getAttributeNodeNS(a, b, c)) d = a.nodeValue;
        return d
    },
    getChildValue: function (a, b) {
        var c = b || "";
        if (a)for (var d = a.firstChild; d; d =
            d.nextSibling)switch (d.nodeType) {
            case 3:
            case 4:
                c += d.nodeValue
        }
        return c
    },
    isSimpleContent: function (a) {
        for (var b = !0, a = a.firstChild; a; a = a.nextSibling)if (a.nodeType === 1) {
            b = !1;
            break
        }
        return b
    },
    contentType: function (a) {
        for (var b = !1, c = !1, d = GeoGlobe.Format.XML.CONTENT_TYPE.EMPTY, a = a.firstChild; a; a = a.nextSibling) {
            switch (a.nodeType) {
                case 1:
                    c = !0;
                    break;
                case 8:
                    break;
                default:
                    b = !0
            }
            if (c && b)break
        }
        if (c && b) d = GeoGlobe.Format.XML.CONTENT_TYPE.MIXED; else if (c)return GeoGlobe.Format.XML.CONTENT_TYPE.COMPLEX; else if (b)return GeoGlobe.Format.XML.CONTENT_TYPE.SIMPLE;
        return d
    },
    hasAttributeNS: function (a, b, c) {
        var d = !1;
        return d = a.hasAttributeNS ? a.hasAttributeNS(b, c) : !!this.getAttributeNodeNS(a, b, c)
    },
    setAttributeNS: function (a, b, c, d) {
        if (a.setAttributeNS) a.setAttributeNS(b, c, d); else if (this.xmldom) b ? (b = a.ownerDocument.createNode(2, c, b), b.nodeValue = d, a.setAttributeNode(b)) : a.setAttribute(c, d); else throw"setAttributeNS not implemented";
    },
    createElementNSPlus: function (a, b) {
        var b = b || {}, c = b.uri || this.namespaces[b.prefix];
        c || (c = a.indexOf(":"), c = this.namespaces[a.substring(0,
            c)]);
        c || (c = this.namespaces[this.defaultPrefix]);
        c = this.createElementNS(c, a);
        b.attributes && this.setAttributes(c, b.attributes);
        var d = b.value;
        d != null && c.appendChild(this.createTextNode(d));
        return c
    },
    setAttributes: function (a, b) {
        var c, d, e;
        for (e in b)b[e] != null && b[e].toString && (c = b[e].toString(), d = this.namespaces[e.substring(0, e.indexOf(":"))] || null, this.setAttributeNS(a, d, e, c))
    },
    readNode: function (a, b) {
        b || (b = {});
        var c = this.readers[a.namespaceURI ? this.namespaceAlias[a.namespaceURI] : this.defaultPrefix];
        if (c) {
            var d =
                a.localName || a.nodeName.split(":").pop();
            (c = c[d] || c["*"]) && c.apply(this, [a, b])
        }
        return b
    },
    readChildNodes: function (a, b) {
        b || (b = {});
        for (var c = a.childNodes, d, e = 0, f = c.length; e < f; ++e)d = c[e], d.nodeType == 1 && this.readNode(d, b);
        return b
    },
    writeNode: function (a, b, c) {
        var d, e = a.indexOf(":");
        e > 0 ? (d = a.substring(0, e), a = a.substring(e + 1)) : d = c ? this.namespaceAlias[c.namespaceURI] : this.defaultPrefix;
        b = this.writers[d][a].apply(this, [b]);
        c && c.appendChild(b);
        return b
    },
    getChildEl: function (a, b, c) {
        return a && this.getThisOrNextEl(a.firstChild,
                b, c)
    },
    getNextEl: function (a, b, c) {
        return a && this.getThisOrNextEl(a.nextSibling, b, c)
    },
    getThisOrNextEl: function (a, b, c) {
        a:for (; a; a = a.nextSibling)switch (a.nodeType) {
            case 1:
                if ((!b || b === (a.localName || a.nodeName.split(":").pop())) && (!c || c === a.namespaceURI))break a;
                a = null;
                break a;
            case 3:
                if (/^\s*$/.test(a.nodeValue))break;
            case 4:
            case 6:
            case 12:
            case 10:
            case 11:
                a = null;
                break a
        }
        return a || null
    },
    lookupNamespaceURI: function (a, b) {
        var c = null;
        if (a)if (a.lookupNamespaceURI) c = a.lookupNamespaceURI(b); else a:switch (a.nodeType) {
            case 1:
                if (a.namespaceURI !==
                    null && a.prefix === b) {
                    c = a.namespaceURI;
                    break a
                }
                if (c = a.attributes.length)for (var d, e = 0; e < c; ++e)if (d = a.attributes[e], d.prefix === "xmlns" && d.name === "xmlns:" + b) {
                    c = d.value || null;
                    break a
                } else if (d.name === "xmlns" && b === null) {
                    c = d.value || null;
                    break a
                }
                c = this.lookupNamespaceURI(a.parentNode, b);
                break a;
            case 2:
                c = this.lookupNamespaceURI(a.ownerElement, b);
                break a;
            case 9:
                c = this.lookupNamespaceURI(a.documentElement, b);
                break a;
            case 6:
            case 12:
            case 10:
            case 11:
                break a;
            default:
                c = this.lookupNamespaceURI(a.parentNode, b)
        }
        return c
    },
    getXMLDoc: function () {
        if (!GeoGlobe.Format.XML.document && !this.xmldom)if (document.implementation && document.implementation.createDocument) GeoGlobe.Format.XML.document = document.implementation.createDocument("", "", null); else if (!this.xmldom && window.ActiveXObject) this.xmldom = new ActiveXObject("Microsoft.XMLDOM");
        return GeoGlobe.Format.XML.document || this.xmldom
    },
    CLASS_NAME: "GeoGlobe.Format.XML"
});
GeoGlobe.Format.XML.CONTENT_TYPE = {EMPTY: 0, SIMPLE: 1, COMPLEX: 2, MIXED: 3};
GeoGlobe.Format.XML.lookupNamespaceURI = GeoGlobe.Function.bind(GeoGlobe.Format.XML.prototype.lookupNamespaceURI, GeoGlobe.Format.XML.prototype);
GeoGlobe.Format.XML.document = null;
GeoGlobe.Format.XML.VersionedOGC = GeoGlobe.Class4OL(GeoGlobe.Format.XML, {
    defaultVersion: null,
    version: null,
    profile: null,
    allowFallback: !1,
    name: null,
    stringifyOutput: !1,
    parser: null,
    initialize: function (a) {
        GeoGlobe.Format.XML.prototype.initialize.apply(this, [a]);
        a = this.CLASS_NAME;
        this.name = a.substring(a.lastIndexOf(".") + 1)
    },
    getVersion: function (a, b) {
        var c;
        if (a) {
            if (c = this.version, !c && (c = a.getAttribute("version"), !c)) c = this.defaultVersion
        } else c = b && b.version || this.version || this.defaultVersion;
        return c
    },
    getParser: function (a) {
        var a =
            a || this.defaultVersion, b = this.profile ? "_" + this.profile : "";
        if (!this.parser || this.parser.VERSION != a) {
            var c = GeoGlobe.Format[this.name]["v" + a.replace(/\./g, "_") + b];
            if (!c && (b !== "" && this.allowFallback && (b = "", c = GeoGlobe.Format[this.name]["v" + a.replace(/\./g, "_")]), !c))throw"Can't find a " + this.name + " parser for version " + a + b;
            this.parser = new c(this.options)
        }
        return this.parser
    },
    write: function (a, b) {
        this.parser = this.getParser(this.getVersion(null, b));
        var c = this.parser.write(a, b);
        return this.stringifyOutput ===
        !1 ? c : GeoGlobe.Format.XML.prototype.write.apply(this, [c])
    },
    read: function (a, b) {
        typeof a == "string" && (a = GeoGlobe.Format.XML.prototype.read.apply(this, [a]));
        var c = this.getVersion(a.documentElement);
        this.parser = this.getParser(c);
        var d = this.parser.read(a, b), e = this.parser.errorProperty || null;
        if (e !== null && d[e] === void 0) e = new GeoGlobe.Format.OGCExceptionReport, d.error = e.read(a);
        d.version = c;
        return d
    },
    CLASS_NAME: "GeoGlobe.Format.XML.VersionedOGC"
});
GeoGlobe.Format.GML = GeoGlobe.Class4OL(GeoGlobe.Format.XML, {
    featureNS: "http://mapserver.gis.umn.edu/mapserver",
    featurePrefix: "feature",
    featureName: "featureMember",
    layerName: "features",
    geometryName: "geometry",
    collectionName: "FeatureCollection",
    gmlns: "http://www.opengis.net/gml",
    extractAttributes: !0,
    xy: !0,
    initialize: function (a) {
        this.regExes = {trimSpace: /^\s*|\s*$/g, removeSpace: /\s*/g, splitSpace: /\s+/, trimComma: /\s*,\s*/g};
        GeoGlobe.Format.XML.prototype.initialize.apply(this, [a])
    },
    read: function (a) {
        typeof a ==
        "string" && (a = GeoGlobe.Format.XML.prototype.read.apply(this, [a]));
        for (var a = this.getElementsByTagNameNS(a.documentElement, this.gmlns, this.featureName), b = [], c = 0; c < a.length; c++) {
            var d = this.parseFeature(a[c]);
            d && b.push(d)
        }
        return b
    },
    parseFeature: function (a) {
        for (var b = ["MultiPolygon", "Polygon", "MultiLineString", "LineString", "MultiPoint", "Point", "Envelope"], c, d, e, f = 0; f < b.length; ++f)if (c = b[f], d = this.getElementsByTagNameNS(a, this.gmlns, c), d.length > 0) {
            if (e = this.parseGeometry[c.toLowerCase()]) e = e.apply(this,
                [d[0]]), this.internalProjection && this.externalProjection && e.transform(this.externalProjection, this.internalProjection); else throw new TypeError("Unsupported geometry type: " + c);
            break
        }
        var g;
        c = this.getElementsByTagNameNS(a, this.gmlns, "Box");
        for (f = 0; f < c.length; ++f)b = c[f], d = this.parseGeometry.box.apply(this, [b]), b = b.parentNode, (b.localName || b.nodeName.split(":").pop()) === "boundedBy" ? g = d : e = d.toGeometry();
        var h;
        this.extractAttributes && (h = this.parseAttributes(a));
        h = new GeoGlobe.Feature(e, h);
        h.bounds = g;
        h.gml =
            {
                featureType: a.firstChild.nodeName.split(":")[1],
                featureNS: a.firstChild.namespaceURI,
                featureNSPrefix: a.firstChild.prefix
            };
        for (var a = a.firstChild, j; a;) {
            if (a.nodeType == 1 && (j = a.getAttribute("fid") || a.getAttribute("id")))break;
            a = a.nextSibling
        }
        h.fid = j;
        return h
    },
    parseGeometry: {
        point: function (a) {
            var b, c;
            c = [];
            b = this.getElementsByTagNameNS(a, this.gmlns, "pos");
            if (b.length > 0) c = b[0].firstChild.nodeValue, c = c.replace(this.regExes.trimSpace, ""), c = c.split(this.regExes.splitSpace);
            if (c.length == 0 && (b = this.getElementsByTagNameNS(a,
                    this.gmlns, "coordinates"), b.length > 0)) c = b[0].firstChild.nodeValue, c = c.replace(this.regExes.removeSpace, ""), c = c.split(",");
            c.length == 0 && (b = this.getElementsByTagNameNS(a, this.gmlns, "coord"), b.length > 0 && (a = this.getElementsByTagNameNS(b[0], this.gmlns, "X"), b = this.getElementsByTagNameNS(b[0], this.gmlns, "Y"), a.length > 0 && b.length > 0 && (c = [a[0].firstChild.nodeValue, b[0].firstChild.nodeValue])));
            c.length == 2 && (c[2] = null);
            return this.xy ? new GeoGlobe.Geometry.Point(c[0], c[1], c[2]) : new GeoGlobe.Geometry.Point(c[1],
                c[0], c[2])
        }, multipoint: function (a) {
            var a = this.getElementsByTagNameNS(a, this.gmlns, "Point"), b = [];
            if (a.length > 0)for (var c, d = 0; d < a.length; ++d)(c = this.parseGeometry.point.apply(this, [a[d]])) && b.push(c);
            return new GeoGlobe.Geometry.MultiPoint(b)
        }, linestring: function (a, b) {
            var c, d;
            d = [];
            var e = [];
            c = this.getElementsByTagNameNS(a, this.gmlns, "posList");
            if (c.length > 0) {
                d = this.getChildValue(c[0]);
                d = d.replace(this.regExes.trimSpace, "");
                d = d.split(this.regExes.splitSpace);
                var f = parseInt(c[0].getAttribute("dimension")),
                    g, h, j;
                for (c = 0; c < d.length / f; ++c)g = c * f, h = d[g], j = d[g + 1], g = f == 2 ? null : d[g + 2], this.xy ? e.push(new GeoGlobe.Geometry.Point(h, j, g)) : e.push(new GeoGlobe.Geometry.Point(j, h, g))
            }
            if (d.length == 0 && (c = this.getElementsByTagNameNS(a, this.gmlns, "coordinates"), c.length > 0)) {
                d = this.getChildValue(c[0]);
                d = d.replace(this.regExes.trimSpace, "");
                d = d.replace(this.regExes.trimComma, ",");
                f = d.split(this.regExes.splitSpace);
                for (c = 0; c < f.length; ++c)d = f[c].split(","), d.length == 2 && (d[2] = null), this.xy ? e.push(new GeoGlobe.Geometry.Point(d[0],
                    d[1], d[2])) : e.push(new GeoGlobe.Geometry.Point(d[1], d[0], d[2]))
            }
            d = null;
            e.length != 0 && (d = b ? new GeoGlobe.Geometry.LinearRing(e) : new GeoGlobe.Geometry.LineString(e));
            return d
        }, multilinestring: function (a) {
            var a = this.getElementsByTagNameNS(a, this.gmlns, "LineString"), b = [];
            if (a.length > 0)for (var c, d = 0; d < a.length; ++d)(c = this.parseGeometry.linestring.apply(this, [a[d]])) && b.push(c);
            return new GeoGlobe.Geometry.MultiLineString(b)
        }, polygon: function (a) {
            var a = this.getElementsByTagNameNS(a, this.gmlns, "LinearRing"),
                b = [];
            if (a.length > 0)for (var c, d = 0; d < a.length; ++d)(c = this.parseGeometry.linestring.apply(this, [a[d], !0])) && b.push(c);
            return new GeoGlobe.Geometry.Polygon(b)
        }, multipolygon: function (a) {
            var a = this.getElementsByTagNameNS(a, this.gmlns, "Polygon"), b = [];
            if (a.length > 0)for (var c, d = 0; d < a.length; ++d)(c = this.parseGeometry.polygon.apply(this, [a[d]])) && b.push(c);
            return new GeoGlobe.Geometry.MultiPolygon(b)
        }, envelope: function (a) {
            var b = [], c, d, e = this.getElementsByTagNameNS(a, this.gmlns, "lowerCorner");
            if (e.length > 0) {
                c =
                    [];
                if (e.length > 0) c = e[0].firstChild.nodeValue, c = c.replace(this.regExes.trimSpace, ""), c = c.split(this.regExes.splitSpace);
                c.length == 2 && (c[2] = null);
                var f = this.xy ? new GeoGlobe.Geometry.Point(c[0], c[1], c[2]) : new GeoGlobe.Geometry.Point(c[1], c[0], c[2])
            }
            a = this.getElementsByTagNameNS(a, this.gmlns, "upperCorner");
            if (a.length > 0) {
                c = [];
                if (a.length > 0) c = a[0].firstChild.nodeValue, c = c.replace(this.regExes.trimSpace, ""), c = c.split(this.regExes.splitSpace);
                c.length == 2 && (c[2] = null);
                var g = this.xy ? new GeoGlobe.Geometry.Point(c[0],
                    c[1], c[2]) : new GeoGlobe.Geometry.Point(c[1], c[0], c[2])
            }
            f && g && (b.push(new GeoGlobe.Geometry.Point(f.x, f.y)), b.push(new GeoGlobe.Geometry.Point(g.x, f.y)), b.push(new GeoGlobe.Geometry.Point(g.x, g.y)), b.push(new GeoGlobe.Geometry.Point(f.x, g.y)), b.push(new GeoGlobe.Geometry.Point(f.x, f.y)), b = new GeoGlobe.Geometry.LinearRing(b), d = new GeoGlobe.Geometry.Polygon([b]));
            return d
        }, box: function (a) {
            var b = this.getElementsByTagNameNS(a, this.gmlns, "coordinates"), c = null, a = null;
            if (b.length > 0) b = b[0].firstChild.nodeValue,
                b = b.split(" "), b.length == 2 && (c = b[0].split(","), a = b[1].split(","));
            if (c !== null && a !== null)return c = new GeoGlobe.LngLat(parseFloat(c[0]), parseFloat(c[1])), a = new GeoGlobe.LngLat(parseFloat(a[0]), parseFloat(a[1])), new GeoGlobe.LngLatBounds(c, a)
        }
    },
    parseAttributes: function (a) {
        for (var b = {}, a = a.firstChild, c, d, e; a;) {
            if (a.nodeType == 1) {
                a = a.childNodes;
                for (c = 0; c < a.length; ++c)if (d = a[c], d.nodeType == 1)if (e = d.childNodes, e.length == 1) {
                    if (e = e[0], e.nodeType == 3 || e.nodeType == 4) d = d.prefix ? d.nodeName.split(":")[1] : d.nodeName,
                        e = e.nodeValue.replace(this.regExes.trimSpace, ""), b[d] = e
                } else b[d.nodeName.split(":").pop()] = null;
                break
            }
            a = a.nextSibling
        }
        return b
    },
    write: function (a) {
        GeoGlobe.Util.isArray(a) || (a = [a]);
        for (var b = this.createElementNS("http://www.opengis.net/wfs", "wfs:" + this.collectionName), c = 0; c < a.length; c++)b.appendChild(this.createFeatureXML(a[c]));
        return GeoGlobe.Format.XML.prototype.write.apply(this, [b])
    },
    createFeatureXML: function (a) {
        var b = this.buildGeometryNode(a.geometry), c = this.createElementNS(this.featureNS, this.featurePrefix +
            ":" + this.geometryName);
        c.appendChild(b);
        var b = this.createElementNS(this.gmlns, "gml:" + this.featureName),
            d = this.createElementNS(this.featureNS, this.featurePrefix + ":" + this.layerName);
        d.setAttribute("fid", a.fid || a.id);
        d.appendChild(c);
        for (var e in a.attributes) {
            var c = this.createTextNode(a.attributes[e]),
                f = this.createElementNS(this.featureNS, this.featurePrefix + ":" + e.substring(e.lastIndexOf(":") + 1));
            f.appendChild(c);
            d.appendChild(f)
        }
        b.appendChild(d);
        return b
    },
    buildGeometryNode: function (a) {
        this.externalProjection &&
        this.internalProjection && (a = a.clone(), a.transform(this.internalProjection, this.externalProjection));
        var b = a.CLASS_NAME;
        return this.buildGeometry[b.substring(b.lastIndexOf(".") + 1).toLowerCase()].apply(this, [a])
    },
    buildGeometry: {
        point: function (a) {
            var b = this.createElementNS(this.gmlns, "gml:Point");
            b.appendChild(this.buildCoordinatesNode(a));
            return b
        }, multipoint: function (a) {
            for (var b = this.createElementNS(this.gmlns, "gml:MultiPoint"), a = a.components, c, d, e = 0; e < a.length; e++)c = this.createElementNS(this.gmlns,
                "gml:pointMember"), d = this.buildGeometry.point.apply(this, [a[e]]), c.appendChild(d), b.appendChild(c);
            return b
        }, linestring: function (a) {
            var b = this.createElementNS(this.gmlns, "gml:LineString");
            b.appendChild(this.buildCoordinatesNode(a));
            return b
        }, multilinestring: function (a) {
            for (var b = this.createElementNS(this.gmlns, "gml:MultiLineString"), a = a.components, c, d, e = 0; e < a.length; ++e)c = this.createElementNS(this.gmlns, "gml:lineStringMember"), d = this.buildGeometry.linestring.apply(this, [a[e]]), c.appendChild(d), b.appendChild(c);
            return b
        }, linearring: function (a) {
            var b = this.createElementNS(this.gmlns, "gml:LinearRing");
            b.appendChild(this.buildCoordinatesNode(a));
            return b
        }, polygon: function (a) {
            for (var b = this.createElementNS(this.gmlns, "gml:Polygon"), a = a.components, c, d, e = 0; e < a.length; ++e)c = e == 0 ? "outerBoundaryIs" : "innerBoundaryIs", c = this.createElementNS(this.gmlns, "gml:" + c), d = this.buildGeometry.linearring.apply(this, [a[e]]), c.appendChild(d), b.appendChild(c);
            return b
        }, multipolygon: function (a) {
            for (var b = this.createElementNS(this.gmlns,
                "gml:MultiPolygon"), a = a.components, c, d, e = 0; e < a.length; ++e)c = this.createElementNS(this.gmlns, "gml:polygonMember"), d = this.buildGeometry.polygon.apply(this, [a[e]]), c.appendChild(d), b.appendChild(c);
            return b
        }, lnglatbounds: function (a) {
            var b = this.createElementNS(this.gmlns, "gml:Box");
            b.appendChild(this.buildCoordinatesNode(a));
            return b
        }
    },
    buildCoordinatesNode: function (a) {
        var b = this.createElementNS(this.gmlns, "gml:coordinates");
        b.setAttribute("decimal", ".");
        b.setAttribute("cs", ",");
        b.setAttribute("ts", " ");
        var c = [];
        if (a instanceof mapboxgl.LngLatBounds) c.push(a.getWest() + "," + a.getSouth()), c.push(a.getEast() + "," + a.getNorth()); else for (var a = a.components ? a.components : [a], d = 0; d < a.length; d++)c.push(a[d].x + "," + a[d].y);
        c = this.createTextNode(c.join(" "));
        b.appendChild(c);
        return b
    },
    CLASS_NAME: "GeoGlobe.Format.GML"
});
if (!GeoGlobe.Format.GML) GeoGlobe.Format.GML = {};
GeoGlobe.Format.GML.Base = GeoGlobe.Class4OL(GeoGlobe.Format.XML, {
    namespaces: {
        gml: "http://www.opengis.net/gml",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance",
        wfs: "http://www.opengis.net/wfs"
    },
    defaultPrefix: "gml",
    schemaLocation: null,
    featureType: null,
    featureNS: null,
    geometryName: "geometry",
    extractAttributes: !0,
    srsName: null,
    xy: !0,
    geometryTypes: null,
    singleFeatureType: null,
    regExes: {
        trimSpace: /^\s*|\s*$/g,
        removeSpace: /\s*/g,
        splitSpace: /\s+/,
        trimComma: /\s*,\s*/g,
        featureMember: /^(.*:)?featureMembers?$/
    },
    initialize: function (a) {
        GeoGlobe.Format.XML.prototype.initialize.apply(this, [a]);
        this.setGeometryTypes();
        a && a.featureNS && this.setNamespace("feature", a.featureNS);
        this.singleFeatureType = !a || typeof a.featureType === "string"
    },
    read: function (a) {
        typeof a == "string" && (a = GeoGlobe.Format.XML.prototype.read.apply(this, [a]));
        if (a && a.nodeType == 9) a = a.documentElement;
        var b = [];
        this.readNode(a, {features: b}, !0);
        if (b.length == 0) {
            var c = this.getElementsByTagNameNS(a, this.namespaces.gml, "featureMember");
            if (c.length)for (var a =
                0, d = c.length; a < d; ++a)this.readNode(c[a], {features: b}, !0); else c = this.getElementsByTagNameNS(a, this.namespaces.gml, "featureMembers"), c.length && this.readNode(c[0], {features: b}, !0)
        }
        return b
    },
    readNode: function (a, b, c) {
        if (c === !0 && this.autoConfig === !0) this.featureType = null, delete this.namespaceAlias[this.featureNS], delete this.namespaces.feature, this.featureNS = null;
        if (!this.featureNS && !(a.prefix in this.namespaces) && a.parentNode.namespaceURI == this.namespaces.gml && this.regExes.featureMember.test(a.parentNode.nodeName)) this.featureType =
            a.nodeName.split(":").pop(), this.setNamespace("feature", a.namespaceURI), this.featureNS = a.namespaceURI, this.autoConfig = !0;
        return GeoGlobe.Format.XML.prototype.readNode.apply(this, [a, b])
    },
    readers: {
        gml: {
            _inherit: function () {
            }, featureMember: function (a, b) {
                this.readChildNodes(a, b)
            }, featureMembers: function (a, b) {
                this.readChildNodes(a, b)
            }, name: function (a, b) {
                b.name = this.getChildValue(a)
            }, boundedBy: function (a, b) {
                var c = {};
                this.readChildNodes(a, c);
                if (c.components && c.components.length > 0) b.bounds = c.components[0]
            },
            Point: function (a, b) {
                var c = {points: []};
                this.readChildNodes(a, c);
                if (!b.components) b.components = [];
                b.components.push(c.points[0])
            }, coordinates: function (a, b) {
                for (var c = this.getChildValue(a).replace(this.regExes.trimSpace, ""), c = c.replace(this.regExes.trimComma, ","), c = c.split(this.regExes.splitSpace), d, e = c.length, f = Array(e), g = 0; g < e; ++g)d = c[g].split(","), f[g] = this.xy ? new GeoGlobe.Geometry.Point(d[0], d[1], d[2]) : new GeoGlobe.Geometry.Point(d[1], d[0], d[2]);
                b.points = f
            }, coord: function (a, b) {
                var c = {};
                this.readChildNodes(a,
                    c);
                if (!b.points) b.points = [];
                b.points.push(new GeoGlobe.Geometry.Point(c.x, c.y, c.z))
            }, X: function (a, b) {
                b.x = this.getChildValue(a)
            }, Y: function (a, b) {
                b.y = this.getChildValue(a)
            }, Z: function (a, b) {
                b.z = this.getChildValue(a)
            }, MultiPoint: function (a, b) {
                var c = {components: []};
                this.readers.gml._inherit.apply(this, [a, c, b]);
                this.readChildNodes(a, c);
                b.components = [new GeoGlobe.Geometry.MultiPoint(c.components)]
            }, pointMember: function (a, b) {
                this.readChildNodes(a, b)
            }, LineString: function (a, b) {
                var c = {};
                this.readers.gml._inherit.apply(this,
                    [a, c, b]);
                this.readChildNodes(a, c);
                if (!b.components) b.components = [];
                b.components.push(new GeoGlobe.Geometry.LineString(c.points))
            }, MultiLineString: function (a, b) {
                var c = {components: []};
                this.readers.gml._inherit.apply(this, [a, c, b]);
                this.readChildNodes(a, c);
                b.components = [new GeoGlobe.Geometry.MultiLineString(c.components)]
            }, lineStringMember: function (a, b) {
                this.readChildNodes(a, b)
            }, Polygon: function (a, b) {
                var c = {outer: null, inner: []};
                this.readers.gml._inherit.apply(this, [a, c, b]);
                this.readChildNodes(a, c);
                c.inner.unshift(c.outer);
                if (!b.components) b.components = [];
                b.components.push(new GeoGlobe.Geometry.Polygon(c.inner))
            }, LinearRing: function (a, b) {
                var c = {};
                this.readers.gml._inherit.apply(this, [a, c]);
                this.readChildNodes(a, c);
                b.components = [new GeoGlobe.Geometry.LinearRing(c.points)]
            }, MultiPolygon: function (a, b) {
                var c = {components: []};
                this.readers.gml._inherit.apply(this, [a, c, b]);
                this.readChildNodes(a, c);
                b.components = [new GeoGlobe.Geometry.MultiPolygon(c.components)]
            }, polygonMember: function (a, b) {
                this.readChildNodes(a, b)
            }, GeometryCollection: function (a,
                                             b) {
                var c = {components: []};
                this.readers.gml._inherit.apply(this, [a, c, b]);
                this.readChildNodes(a, c);
                b.components = [new GeoGlobe.Geometry.Collection(c.components)]
            }, geometryMember: function (a, b) {
                this.readChildNodes(a, b)
            }
        }, feature: {
            "*": function (a, b) {
                var c, d = a.localName || a.nodeName.split(":").pop();
                if (b.features)if (!this.singleFeatureType && GeoGlobe.Util.indexOf(this.featureType, d) !== -1) c = "_typeName"; else if (d === this.featureType) c = "_typeName"; else {
                    if (GeoGlobe.Util.isArray(this.featureType_))for (var e = 0; e < this.featureType_.length; e++)if (this.featureType_[e] ===
                        d) {
                        c = "_typeName";
                        break
                    }
                } else a.childNodes.length == 0 || a.childNodes.length == 1 && a.firstChild.nodeType == 3 ? this.extractAttributes && (c = "_attribute") : c = "_geometry";
                c && this.readers.feature[c].apply(this, [a, b])
            }, _typeName: function (a, b) {
                var c = {components: [], attributes: {}};
                this.readChildNodes(a, c);
                if (c.name) c.attributes.name = c.name;
                var d = new GeoGlobe.Feature(c.components[0], c.attributes);
                if (!this.singleFeatureType) d.type = a.nodeName.split(":").pop(), d.namespace = a.namespaceURI;
                var e = a.getAttribute("fid") || this.getAttributeNS(a,
                        this.namespaces.gml, "id");
                if (e) d.fid = e;
                this.internalProjection && this.externalProjection && d.geometry && d.geometry.transform(this.externalProjection, this.internalProjection);
                if (c.bounds) d.bounds = c.bounds;
                b.features.push(d)
            }, _geometry: function (a, b) {
                if (!this.geometryName) this.geometryName = a.nodeName.split(":").pop();
                this.readChildNodes(a, b)
            }, _attribute: function (a, b) {
                var c = a.localName || a.nodeName.split(":").pop(), d = this.getChildValue(a);
                b.attributes[c] = d
            }
        }, wfs: {
            FeatureCollection: function (a, b) {
                this.readChildNodes(a,
                    b)
            }
        }
    },
    write: function (a) {
        a = this.writeNode("gml:" + (GeoGlobe.Util.isArray(a) ? "featureMembers" : "featureMember"), a);
        this.setAttributeNS(a, this.namespaces.xsi, "xsi:schemaLocation", this.schemaLocation);
        return GeoGlobe.Format.XML.prototype.write.apply(this, [a])
    },
    writers: {
        gml: {
            featureMember: function (a) {
                var b = this.createElementNSPlus("gml:featureMember");
                this.writeNode("feature:_typeName", a, b);
                return b
            }, MultiPoint: function (a) {
                for (var b = this.createElementNSPlus("gml:MultiPoint"), a = a.components || [a], c = 0, d = a.length; c <
                d; ++c)this.writeNode("pointMember", a[c], b);
                return b
            }, pointMember: function (a) {
                var b = this.createElementNSPlus("gml:pointMember");
                this.writeNode("Point", a, b);
                return b
            }, MultiLineString: function (a) {
                for (var b = this.createElementNSPlus("gml:MultiLineString"), a = a.components || [a], c = 0, d = a.length; c < d; ++c)this.writeNode("lineStringMember", a[c], b);
                return b
            }, lineStringMember: function (a) {
                var b = this.createElementNSPlus("gml:lineStringMember");
                this.writeNode("LineString", a, b);
                return b
            }, MultiPolygon: function (a) {
                for (var b =
                    this.createElementNSPlus("gml:MultiPolygon"), a = a.components || [a], c = 0, d = a.length; c < d; ++c)this.writeNode("polygonMember", a[c], b);
                return b
            }, polygonMember: function (a) {
                var b = this.createElementNSPlus("gml:polygonMember");
                this.writeNode("Polygon", a, b);
                return b
            }, GeometryCollection: function (a) {
                for (var b = this.createElementNSPlus("gml:GeometryCollection"), c = 0, d = a.components.length; c < d; ++c)this.writeNode("geometryMember", a.components[c], b);
                return b
            }, geometryMember: function (a) {
                var b = this.createElementNSPlus("gml:geometryMember"),
                    a = this.writeNode("feature:_geometry", a);
                b.appendChild(a.firstChild);
                return b
            }
        }, feature: {
            _typeName: function (a) {
                var b = this.createElementNSPlus("feature:" + this.featureType, {attributes: {fid: a.fid}});
                a.geometry && this.writeNode("feature:_geometry", a.geometry, b);
                for (var c in a.attributes) {
                    var d = a.attributes[c];
                    d != null && this.writeNode("feature:_attribute", {name: c, value: d}, b)
                }
                return b
            }, _geometry: function (a) {
                this.externalProjection && this.internalProjection && (a = a.clone().transform(this.internalProjection, this.externalProjection));
                var b = this.createElementNSPlus("feature:" + this.geometryName),
                    a = this.writeNode("gml:" + this.geometryTypes[a.CLASS_NAME], a, b);
                this.srsName && a.setAttribute("srsName", this.srsName);
                return b
            }, _attribute: function (a) {
                return this.createElementNSPlus("feature:" + a.name, {value: a.value})
            }
        }, wfs: {
            FeatureCollection: function (a) {
                for (var b = this.createElementNSPlus("wfs:FeatureCollection"), c = 0, d = a.length; c < d; ++c)this.writeNode("gml:featureMember", a[c], b);
                return b
            }
        }
    },
    setGeometryTypes: function () {
        this.geometryTypes = {
            "GeoGlobe.Geometry.Point": "Point",
            "GeoGlobe.Geometry.MultiPoint": "MultiPoint",
            "GeoGlobe.Geometry.LineString": "LineString",
            "GeoGlobe.Geometry.MultiLineString": "MultiLineString",
            "GeoGlobe.Geometry.Polygon": "Polygon",
            "GeoGlobe.Geometry.MultiPolygon": "MultiPolygon",
            "GeoGlobe.Geometry.Collection": "GeometryCollection"
        }
    },
    setFeatureType_: function (a) {
        this.featureType_ = a
    },
    CLASS_NAME: "GeoGlobe.Format.GML.Base"
});
GeoGlobe.Format.GML.v2 = GeoGlobe.Class4OL(GeoGlobe.Format.GML.Base, {
    schemaLocation: "http://www.opengis.net/gml http://schemas.opengis.net/gml/2.1.2/feature.xsd",
    initialize: function (a) {
        GeoGlobe.Format.GML.Base.prototype.initialize.apply(this, [a])
    },
    readers: {
        gml: GeoGlobe.Util.applyDefaults({
            outerBoundaryIs: function (a, b) {
                var c = {};
                this.readChildNodes(a, c);
                b.outer = c.components[0]
            }, innerBoundaryIs: function (a, b) {
                var c = {};
                this.readChildNodes(a, c);
                b.inner.push(c.components[0])
            }, Box: function (a, b) {
                var c = {};
                this.readChildNodes(a,
                    c);
                if (!b.components) b.components = [];
                var d = c.points[0], c = c.points[1], d = new GeoGlobe.LngLat(d.x, d.y),
                    c = new GeoGlobe.LngLat(c.x, c.y);
                b.components.push(new GeoGlobe.LngLatBounds(d, c))
            }
        }, GeoGlobe.Format.GML.Base.prototype.readers.gml),
        feature: GeoGlobe.Format.GML.Base.prototype.readers.feature,
        wfs: GeoGlobe.Format.GML.Base.prototype.readers.wfs
    },
    write: function (a) {
        a = this.writeNode(GeoGlobe.Util.isArray(a) ? "wfs:FeatureCollection" : "gml:featureMember", a);
        this.setAttributeNS(a, this.namespaces.xsi, "xsi:schemaLocation",
            this.schemaLocation);
        return GeoGlobe.Format.XML.prototype.write.apply(this, [a])
    },
    writers: {
        gml: GeoGlobe.Util.applyDefaults({
            Point: function (a) {
                var b = this.createElementNSPlus("gml:Point");
                this.writeNode("coordinates", [a], b);
                return b
            }, coordinates: function (a) {
                for (var b = a.length, c = Array(b), d, e = 0; e < b; ++e)d = a[e], c[e] = this.xy ? d.x + "," + d.y : d.y + "," + d.x, d.z != void 0 && (c[e] += "," + d.z);
                return this.createElementNSPlus("gml:coordinates", {
                    attributes: {decimal: ".", cs: ",", ts: " "},
                    value: b == 1 ? c[0] : c.join(" ")
                })
            }, LineString: function (a) {
                var b =
                    this.createElementNSPlus("gml:LineString");
                this.writeNode("coordinates", a.components, b);
                return b
            }, Polygon: function (a) {
                var b = this.createElementNSPlus("gml:Polygon");
                this.writeNode("outerBoundaryIs", a.components[0], b);
                for (var c = 1; c < a.components.length; ++c)this.writeNode("innerBoundaryIs", a.components[c], b);
                return b
            }, outerBoundaryIs: function (a) {
                var b = this.createElementNSPlus("gml:outerBoundaryIs");
                this.writeNode("LinearRing", a, b);
                return b
            }, innerBoundaryIs: function (a) {
                var b = this.createElementNSPlus("gml:innerBoundaryIs");
                this.writeNode("LinearRing", a, b);
                return b
            }, LinearRing: function (a) {
                var b = this.createElementNSPlus("gml:LinearRing");
                this.writeNode("coordinates", a.components, b);
                return b
            }, Box: function (a) {
                var b = this.createElementNSPlus("gml:Box");
                this.writeNode("coordinates", [{x: a._sw.lng, y: a._sw.lat}, {x: a._ne.lng, y: a._ne.lat}], b);
                this.srsName && b.setAttribute("srsName", this.srsName);
                return b
            }
        }, GeoGlobe.Format.GML.Base.prototype.writers.gml),
        feature: GeoGlobe.Format.GML.Base.prototype.writers.feature,
        wfs: GeoGlobe.Format.GML.Base.prototype.writers.wfs
    },
    CLASS_NAME: "GeoGlobe.Format.GML.v2"
});
GeoGlobe.Format.GML.v3 = GeoGlobe.Class4OL(GeoGlobe.Format.GML.Base, {
    schemaLocation: "http://www.opengis.net/gml http://schemas.opengis.net/gml/3.1.1/profiles/gmlsfProfile/1.0.0/gmlsf.xsd",
    curve: !1,
    multiCurve: !0,
    surface: !1,
    multiSurface: !0,
    initialize: function (a) {
        GeoGlobe.Format.GML.Base.prototype.initialize.apply(this, [a])
    },
    readers: {
        gml: GeoGlobe.Util.applyDefaults({
            _inherit: function (a, b, c) {
                if (a = parseInt(a.getAttribute("srsDimension"), 10) || c && c.srsDimension) b.srsDimension = a
            }, featureMembers: function (a,
                                         b) {
                this.readChildNodes(a, b)
            }, Curve: function (a, b) {
                var c = {points: []};
                this.readers.gml._inherit.apply(this, [a, c, b]);
                this.readChildNodes(a, c);
                if (!b.components) b.components = [];
                b.components.push(new GeoGlobe.Geometry.LineString(c.points))
            }, segments: function (a, b) {
                this.readChildNodes(a, b)
            }, LineStringSegment: function (a, b) {
                var c = {};
                this.readChildNodes(a, c);
                c.points && Array.prototype.push.apply(b.points, c.points)
            }, pos: function (a, b) {
                var c = this.getChildValue(a).replace(this.regExes.trimSpace, "").split(this.regExes.splitSpace),
                    c = this.xy ? new GeoGlobe.Geometry.Point(c[0], c[1], c[2]) : new GeoGlobe.Geometry.Point(c[1], c[0], c[2]);
                b.points = [c]
            }, posList: function (a, b) {
                for (var c = this.getChildValue(a).replace(this.regExes.trimSpace, "").split(this.regExes.splitSpace), d = b.srsDimension || parseInt(a.getAttribute("srsDimension") || a.getAttribute("dimension"), 10) || 2, e, f, g, h = Array(c.length / d), j = 0, l = c.length; j < l; j += d)e = c[j], f = c[j + 1], g = d == 2 ? void 0 : c[j + 2], h[j / d] = this.xy ? new GeoGlobe.Geometry.Point(e, f, g) : new GeoGlobe.Geometry.Point(f, e, g);
                b.points =
                    h
            }, Surface: function (a, b) {
                this.readChildNodes(a, b)
            }, patches: function (a, b) {
                this.readChildNodes(a, b)
            }, PolygonPatch: function (a, b) {
                this.readers.gml.Polygon.apply(this, [a, b])
            }, exterior: function (a, b) {
                var c = {};
                this.readChildNodes(a, c);
                b.outer = c.components[0]
            }, interior: function (a, b) {
                var c = {};
                this.readChildNodes(a, c);
                b.inner.push(c.components[0])
            }, MultiCurve: function (a, b) {
                var c = {components: []};
                this.readers.gml._inherit.apply(this, [a, c, b]);
                this.readChildNodes(a, c);
                if (c.components.length > 0) b.components = [new GeoGlobe.Geometry.MultiLineString(c.components)]
            },
            curveMember: function (a, b) {
                this.readChildNodes(a, b)
            }, MultiSurface: function (a, b) {
                var c = {components: []};
                this.readers.gml._inherit.apply(this, [a, c, b]);
                this.readChildNodes(a, c);
                if (c.components.length > 0) b.components = [new GeoGlobe.Geometry.MultiPolygon(c.components)]
            }, surfaceMember: function (a, b) {
                this.readChildNodes(a, b)
            }, surfaceMembers: function (a, b) {
                this.readChildNodes(a, b)
            }, pointMembers: function (a, b) {
                this.readChildNodes(a, b)
            }, lineStringMembers: function (a, b) {
                this.readChildNodes(a, b)
            }, polygonMembers: function (a,
                                         b) {
                this.readChildNodes(a, b)
            }, geometryMembers: function (a, b) {
                this.readChildNodes(a, b)
            }, Envelope: function (a, b) {
                var c = {points: Array(2)};
                this.readChildNodes(a, c);
                if (!b.components) b.components = [];
                var d = c.points[0], c = c.points[1], d = new GeoGlobe.LngLat(d.x, d.y),
                    c = new GeoGlobe.LngLat(c.x, c.y);
                b.components.push(new GeoGlobe.LngLatBounds(d, c))
            }, lowerCorner: function (a, b) {
                var c = {};
                this.readers.gml.pos.apply(this, [a, c]);
                b.points[0] = c.points[0]
            }, upperCorner: function (a, b) {
                var c = {};
                this.readers.gml.pos.apply(this,
                    [a, c]);
                b.points[1] = c.points[0]
            }
        }, GeoGlobe.Format.GML.Base.prototype.readers.gml),
        feature: GeoGlobe.Format.GML.Base.prototype.readers.feature,
        wfs: GeoGlobe.Format.GML.Base.prototype.readers.wfs
    },
    write: function (a) {
        a = this.writeNode("gml:" + (GeoGlobe.Util.isArray(a) ? "featureMembers" : "featureMember"), a);
        this.setAttributeNS(a, this.namespaces.xsi, "xsi:schemaLocation", this.schemaLocation);
        return GeoGlobe.Format.XML.prototype.write.apply(this, [a])
    },
    writers: {
        gml: GeoGlobe.Util.applyDefaults({
            featureMembers: function (a) {
                for (var b =
                    this.createElementNSPlus("gml:featureMembers"), c = 0, d = a.length; c < d; ++c)this.writeNode("feature:_typeName", a[c], b);
                return b
            }, Point: function (a) {
                var b = this.createElementNSPlus("gml:Point");
                this.writeNode("pos", a, b);
                return b
            }, pos: function (a) {
                return this.createElementNSPlus("gml:pos", {value: this.xy ? a.x + " " + a.y : a.y + " " + a.x})
            }, LineString: function (a) {
                var b = this.createElementNSPlus("gml:LineString");
                this.writeNode("posList", a.components, b);
                return b
            }, Curve: function (a) {
                var b = this.createElementNSPlus("gml:Curve");
                this.writeNode("segments", a, b);
                return b
            }, segments: function (a) {
                var b = this.createElementNSPlus("gml:segments");
                this.writeNode("LineStringSegment", a, b);
                return b
            }, LineStringSegment: function (a) {
                var b = this.createElementNSPlus("gml:LineStringSegment");
                this.writeNode("posList", a.components, b);
                return b
            }, posList: function (a) {
                for (var b = a.length, c = Array(b), d, e = 0; e < b; ++e)d = a[e], c[e] = this.xy ? d.x + " " + d.y : d.y + " " + d.x;
                return this.createElementNSPlus("gml:posList", {value: c.join(" ")})
            }, Surface: function (a) {
                var b = this.createElementNSPlus("gml:Surface");
                this.writeNode("patches", a, b);
                return b
            }, patches: function (a) {
                var b = this.createElementNSPlus("gml:patches");
                this.writeNode("PolygonPatch", a, b);
                return b
            }, PolygonPatch: function (a) {
                var b = this.createElementNSPlus("gml:PolygonPatch", {attributes: {interpolation: "planar"}});
                this.writeNode("exterior", a.components[0], b);
                for (var c = 1, d = a.components.length; c < d; ++c)this.writeNode("interior", a.components[c], b);
                return b
            }, Polygon: function (a) {
                var b = this.createElementNSPlus("gml:Polygon");
                this.writeNode("exterior", a.components[0],
                    b);
                for (var c = 1, d = a.components.length; c < d; ++c)this.writeNode("interior", a.components[c], b);
                return b
            }, exterior: function (a) {
                var b = this.createElementNSPlus("gml:exterior");
                this.writeNode("LinearRing", a, b);
                return b
            }, interior: function (a) {
                var b = this.createElementNSPlus("gml:interior");
                this.writeNode("LinearRing", a, b);
                return b
            }, LinearRing: function (a) {
                var b = this.createElementNSPlus("gml:LinearRing");
                this.writeNode("posList", a.components, b);
                return b
            }, MultiCurve: function (a) {
                for (var b = this.createElementNSPlus("gml:MultiCurve"),
                         a = a.components || [a], c = 0, d = a.length; c < d; ++c)this.writeNode("curveMember", a[c], b);
                return b
            }, curveMember: function (a) {
                var b = this.createElementNSPlus("gml:curveMember");
                this.curve ? this.writeNode("Curve", a, b) : this.writeNode("LineString", a, b);
                return b
            }, MultiSurface: function (a) {
                for (var b = this.createElementNSPlus("gml:MultiSurface"), a = a.components || [a], c = 0, d = a.length; c < d; ++c)this.writeNode("surfaceMember", a[c], b);
                return b
            }, surfaceMember: function (a) {
                var b = this.createElementNSPlus("gml:surfaceMember");
                this.surface ?
                    this.writeNode("Surface", a, b) : this.writeNode("Polygon", a, b);
                return b
            }, Envelope: function (a) {
                var b = this.createElementNSPlus("gml:Envelope");
                this.writeNode("lowerCorner", a, b);
                this.writeNode("upperCorner", a, b);
                this.srsName && b.setAttribute("srsName", this.srsName);
                return b
            }, lowerCorner: function (a) {
                return this.createElementNSPlus("gml:lowerCorner", {value: this.xy ? a._sw.lng + " " + a._sw.lat : a._sw.lat + " " + a._sw.lng})
            }, upperCorner: function (a) {
                return this.createElementNSPlus("gml:upperCorner", {
                    value: this.xy ? a._ne.lng +
                        " " + a._ne.lat : a._ne.lat + " " + a._ne.lng
                })
            }
        }, GeoGlobe.Format.GML.Base.prototype.writers.gml),
        feature: GeoGlobe.Format.GML.Base.prototype.writers.feature,
        wfs: GeoGlobe.Format.GML.Base.prototype.writers.wfs
    },
    setGeometryTypes: function () {
        this.geometryTypes = {
            "GeoGlobe.Geometry.Point": "Point",
            "GeoGlobe.Geometry.MultiPoint": "MultiPoint",
            "GeoGlobe.Geometry.LineString": this.curve === !0 ? "Curve" : "LineString",
            "GeoGlobe.Geometry.MultiLineString": this.multiCurve === !1 ? "MultiLineString" : "MultiCurve",
            "GeoGlobe.Geometry.Polygon": this.surface ===
            !0 ? "Surface" : "Polygon",
            "GeoGlobe.Geometry.MultiPolygon": this.multiSurface === !1 ? "MultiPolygon" : "MultiSurface",
            "GeoGlobe.Geometry.Collection": "GeometryCollection"
        }
    },
    CLASS_NAME: "GeoGlobe.Format.GML.v3"
});
GeoGlobe.Format.KML = GeoGlobe.Class4OL(GeoGlobe.Format.XML, {
    namespaces: {kml: "http://www.opengis.net/kml/2.2", gx: "http://www.google.com/kml/ext/2.2"},
    kmlns: "http://earth.google.com/kml/2.0",
    placemarksDesc: "No description available",
    foldersName: "GeoGlobe export",
    foldersDesc: "Exported on " + new Date,
    extractAttributes: !0,
    kvpAttributes: !1,
    extractStyles: !1,
    extractTracks: !1,
    trackAttributes: null,
    internalns: null,
    features: null,
    styles: null,
    styleBaseUrl: "",
    fetched: null,
    maxDepth: 0,
    initialize: function (a) {
        this.regExes =
            {
                trimSpace: /^\s*|\s*$/g,
                removeSpace: /\s*/g,
                splitSpace: /\s+/,
                trimComma: /\s*,\s*/g,
                kmlColor: /(\w{2})(\w{2})(\w{2})(\w{2})/,
                kmlIconPalette: /root:\/\/icons\/palette-(\d+)(\.\w+)/,
                straightBracket: /\$\[(.*?)\]/g
            };
        this.externalProjection = new GeoGlobe.SpatialReference("EPSG:4326");
        GeoGlobe.Format.XML.prototype.initialize.apply(this, [a])
    },
    read: function (a) {
        this.features = [];
        this.styles = {};
        this.fetched = {};
        return this.parseData(a, {depth: 0, styleBaseUrl: this.styleBaseUrl})
    },
    parseData: function (a, b) {
        typeof a == "string" &&
        (a = GeoGlobe.Format.XML.prototype.read.apply(this, [a]));
        for (var c = ["Link", "NetworkLink", "Style", "StyleMap", "Placemark"], d = 0, e = c.length; d < e; ++d) {
            var f = c[d], g = this.getElementsByTagNameNS(a, "*", f);
            if (g.length != 0)switch (f.toLowerCase()) {
                case "link":
                case "networklink":
                    this.parseLinks(g, b);
                    break;
                case "style":
                    this.extractStyles && this.parseStyles(g, b);
                    break;
                case "stylemap":
                    this.extractStyles && this.parseStyleMaps(g, b);
                    break;
                case "placemark":
                    this.parseFeatures(g, b)
            }
        }
        return this.features
    },
    parseLinks: function (a,
                          b) {
        if (b.depth >= this.maxDepth)return !1;
        var c = GeoGlobe.Util.extend({}, b);
        c.depth++;
        for (var d = 0, e = a.length; d < e; d++) {
            var f = this.parseProperty(a[d], "*", "href");
            f && !this.fetched[f] && (this.fetched[f] = !0, (f = this.fetchLink(f)) && this.parseData(f, c))
        }
    },
    fetchLink: function (a) {
        if (a = GeoGlobe.Request.GET({url: a, async: !1}))return a.responseText
    },
    parseStyles: function (a, b) {
        for (var c = 0, d = a.length; c < d; c++) {
            var e = this.parseStyle(a[c]);
            e && (this.styles[(b.styleBaseUrl || "") + "#" + e.id] = e)
        }
    },
    parseKmlColor: function (a) {
        var b =
            null;
        a && (a = a.match(this.regExes.kmlColor)) && (b = {
            color: "#" + a[4] + a[3] + a[2],
            opacity: parseInt(a[1], 16) / 255
        });
        return b
    },
    parseStyle: function (a) {
        for (var b = {}, c = ["LineStyle", "PolyStyle", "IconStyle", "BalloonStyle", "LabelStyle"], d, e, f = 0, g = c.length; f < g; ++f)if (d = c[f], e = this.getElementsByTagNameNS(a, "*", d)[0])switch (d.toLowerCase()) {
            case "linestyle":
                d = this.parseProperty(e, "*", "color");
                if (d = this.parseKmlColor(d)) b.strokeColor = d.color, b.strokeOpacity = d.opacity;
                (d = this.parseProperty(e, "*", "width")) && (b.strokeWidth =
                    d);
                break;
            case "polystyle":
                d = this.parseProperty(e, "*", "color");
                if (d = this.parseKmlColor(d)) b.fillOpacity = d.opacity, b.fillColor = d.color;
                this.parseProperty(e, "*", "fill") == "0" && (b.fillColor = "none");
                this.parseProperty(e, "*", "outline") == "0" && (b.strokeWidth = "0");
                break;
            case "iconstyle":
                var h = parseFloat(this.parseProperty(e, "*", "scale") || 1);
                d = 32 * h;
                var j = 32 * h, l = this.getElementsByTagNameNS(e, "*", "Icon")[0];
                if (l) {
                    var m = this.parseProperty(l, "*", "href");
                    if (m) {
                        var n = this.parseProperty(l, "*", "w"), p = this.parseProperty(l,
                            "*", "h");
                        GeoGlobe.String.startsWith(m, "http://maps.google.com/mapfiles/kml") && !n && !p && (p = n = 64, h /= 2);
                        n = n || p;
                        p = p || n;
                        n && (d = parseInt(n) * h);
                        p && (j = parseInt(p) * h);
                        if (p = m.match(this.regExes.kmlIconPalette)) n = p[1], p = p[2], m = this.parseProperty(l, "*", "x"), l = this.parseProperty(l, "*", "y"), m = "http://maps.google.com/mapfiles/kml/pal" + n + "/icon" + ((l ? 7 - l / 32 : 7) * 8 + (m ? m / 32 : 0)) + p;
                        b.graphicOpacity = 1;
                        b.externalGraphic = m
                    }
                }
                if (e = this.getElementsByTagNameNS(e, "*", "hotSpot")[0]) m = parseFloat(e.getAttribute("x")), l = parseFloat(e.getAttribute("y")),
                    n = e.getAttribute("xunits"), n == "pixels" ? b.graphicXOffset = -m * h : n == "insetPixels" ? b.graphicXOffset = -d + m * h : n == "fraction" && (b.graphicXOffset = -d * m), e = e.getAttribute("yunits"), e == "pixels" ? b.graphicYOffset = -j + l * h + 1 : e == "insetPixels" ? b.graphicYOffset = -(l * h) + 1 : e == "fraction" && (b.graphicYOffset = -j * (1 - l) + 1);
                b.graphicWidth = d;
                b.graphicHeight = j;
                break;
            case "balloonstyle":
                (e = GeoGlobe.Util.getXmlNodeValue(e)) && (b.balloonStyle = e.replace(this.regExes.straightBracket, "${$1}"));
                break;
            case "labelstyle":
                if (d = this.parseProperty(e,
                        "*", "color"), d = this.parseKmlColor(d)) b.fontColor = d.color, b.fontOpacity = d.opacity
        }
        !b.strokeColor && b.fillColor && (b.strokeColor = b.fillColor);
        if ((a = a.getAttribute("id")) && b) b.id = a;
        return b
    },
    parseStyleMaps: function (a, b) {
        for (var c = 0, d = a.length; c < d; c++)for (var e = a[c], f = this.getElementsByTagNameNS(e, "*", "Pair"), e = e.getAttribute("id"), g = 0, h = f.length; g < h; g++) {
            var j = f[g], l = this.parseProperty(j, "*", "key");
            (j = this.parseProperty(j, "*", "styleUrl")) && l == "normal" && (this.styles[(b.styleBaseUrl || "") + "#" + e] = this.styles[(b.styleBaseUrl ||
            "") + j])
        }
    },
    parseFeatures: function (a, b) {
        for (var c = [], d = 0, e = a.length; d < e; d++) {
            var f = a[d], g = this.parseFeature.apply(this, [f]);
            if (g) {
                if (this.extractStyles && g.attributes && g.attributes.styleUrl) g.style = this.getStyle(g.attributes.styleUrl, b);
                if (this.extractStyles) {
                    var h = this.getElementsByTagNameNS(f, "*", "Style")[0];
                    if (h && (h = this.parseStyle(h))) g.style = GeoGlobe.Util.extend(g.style, h)
                }
                if (this.extractTracks) {
                    if ((f = this.getElementsByTagNameNS(f, this.namespaces.gx, "Track")) && f.length > 0) g = {
                        features: [],
                        feature: g
                    },
                        this.readNode(f[0], g), g.features.length > 0 && c.push.apply(c, g.features)
                } else c.push(g)
            } else throw"Bad Placemark: " + d;
        }
        this.features = this.features.concat(c)
    },
    readers: {
        kml: {
            when: function (a, b) {
                b.whens.push(GeoGlobe.Date.parse(this.getChildValue(a)))
            }, _trackPointAttribute: function (a, b) {
                var c = a.nodeName.split(":").pop();
                b.attributes[c].push(this.getChildValue(a))
            }
        }, gx: {
            Track: function (a, b) {
                var c = {whens: [], points: [], angles: []};
                if (this.trackAttributes) {
                    var d;
                    c.attributes = {};
                    for (var e = 0, f = this.trackAttributes.length; e <
                    f; ++e)if (d = this.trackAttributes[e], c.attributes[d] = [], !(d in this.readers.kml)) this.readers.kml[d] = this.readers.kml._trackPointAttribute
                }
                this.readChildNodes(a, c);
                if (c.whens.length !== c.points.length)throw Error("gx:Track with unequal number of when (" + c.whens.length + ") and gx:coord (" + c.points.length + ") elements.");
                var g = c.angles.length > 0;
                if (g && c.whens.length !== c.angles.length)throw Error("gx:Track with unequal number of when (" + c.whens.length + ") and gx:angles (" + c.angles.length + ") elements.");
                for (var h,
                         e = 0, f = c.whens.length; e < f; ++e) {
                    h = b.feature.clone();
                    h.fid = b.feature.fid || b.feature.id;
                    d = c.points[e];
                    h.geometry = d;
                    if ("z" in d) h.attributes.altitude = d.z;
                    this.internalProjection && this.externalProjection && h.geometry.transform(this.externalProjection, this.internalProjection);
                    if (this.trackAttributes)for (var j = 0, l = this.trackAttributes.length; j < l; ++j)d = this.trackAttributes[j], h.attributes[d] = c.attributes[d][e];
                    h.attributes.when = c.whens[e];
                    h.attributes.trackId = b.feature.id;
                    if (g) d = c.angles[e], h.attributes.heading =
                        parseFloat(d[0]), h.attributes.tilt = parseFloat(d[1]), h.attributes.roll = parseFloat(d[2]);
                    b.features.push(h)
                }
            }, coord: function (a, b) {
                var c = this.getChildValue(a).replace(this.regExes.trimSpace, "").split(/\s+/),
                    d = new GeoGlobe.Geometry.Point(c[0], c[1]);
                if (c.length > 2) d.z = parseFloat(c[2]);
                b.points.push(d)
            }, angles: function (a, b) {
                var c = this.getChildValue(a).replace(this.regExes.trimSpace, "").split(/\s+/);
                b.angles.push(c)
            }
        }
    },
    parseFeature: function (a) {
        for (var b = ["MultiGeometry", "Polygon", "LineString", "Point"], c,
                 d, e, f = 0, g = b.length; f < g; ++f)if (c = b[f], this.internalns = a.namespaceURI ? a.namespaceURI : this.kmlns, d = this.getElementsByTagNameNS(a, this.internalns, c), d.length > 0) {
            if (b = this.parseGeometry[c.toLowerCase()]) e = b.apply(this, [d[0]]), this.internalProjection && this.externalProjection && e.transform(this.externalProjection, this.internalProjection); else throw new TypeError("Unsupported geometry type: " + c);
            break
        }
        var h;
        this.extractAttributes && (h = this.parseAttributes(a));
        c = new GeoGlobe.Feature(e, h);
        a = a.getAttribute("id") ||
            a.getAttribute("name");
        if (a != null) c.fid = a;
        return c
    },
    getStyle: function (a, b) {
        var c = GeoGlobe.Util.removeTail(a), d = GeoGlobe.Util.extend({}, b);
        d.depth++;
        d.styleBaseUrl = c;
        !this.styles[a] && !GeoGlobe.String.startsWith(a, "#") && d.depth <= this.maxDepth && !this.fetched[c] && (c = this.fetchLink(c)) && this.parseData(c, d);
        return GeoGlobe.Util.extend({}, this.styles[a])
    },
    parseGeometry: {
        point: function (a) {
            var b = this.getElementsByTagNameNS(a, this.internalns, "coordinates"), a = [];
            if (b.length > 0)var c = b[0].firstChild.nodeValue,
                c = c.replace(this.regExes.removeSpace, ""), a = c.split(",");
            b = null;
            if (a.length > 1) a.length == 2 && (a[2] = null), b = new GeoGlobe.Geometry.Point(a[0], a[1], a[2]); else throw"Bad coordinate string: " + c;
            return b
        }, linestring: function (a, b) {
            var c = this.getElementsByTagNameNS(a, this.internalns, "coordinates"), d = null;
            if (c.length > 0) {
                for (var c = this.getChildValue(c[0]), c = c.replace(this.regExes.trimSpace, ""), c = c.replace(this.regExes.trimComma, ","), d = c.split(this.regExes.splitSpace), e = d.length, f = Array(e), g, h, j = 0; j < e; ++j)if (g =
                        d[j].split(","), h = g.length, h > 1) g.length == 2 && (g[2] = null), f[j] = new GeoGlobe.Geometry.Point(g[0], g[1], g[2]); else throw"Bad LineString point coordinates: " + d[j];
                if (e) d = b ? new GeoGlobe.Geometry.LinearRing(f) : new GeoGlobe.Geometry.LineString(f); else throw"Bad LineString coordinates: " + c;
            }
            return d
        }, polygon: function (a) {
            var a = this.getElementsByTagNameNS(a, this.internalns, "LinearRing"), b = a.length, c = Array(b);
            if (b > 0)for (var d = 0, e = a.length; d < e; ++d)if (b = this.parseGeometry.linestring.apply(this, [a[d], !0])) c[d] = b;
            else throw"Bad LinearRing geometry: " + d;
            return new GeoGlobe.Geometry.Polygon(c)
        }, multigeometry: function (a) {
            for (var b, c = [], d = a.childNodes, e = 0, f = d.length; e < f; ++e)a = d[e], a.nodeType == 1 && (b = this.parseGeometry[(a.prefix ? a.nodeName.split(":")[1] : a.nodeName).toLowerCase()]) && c.push(b.apply(this, [a]));
            return new GeoGlobe.Geometry.Collection(c)
        }
    },
    parseAttributes: function (a) {
        var b = {}, c = a.getElementsByTagName("ExtendedData");
        c.length && (b = this.parseExtendedData(c[0]));
        for (var d, e, f, a = a.childNodes, c = 0, g = a.length; c <
        g; ++c)if (d = a[c], d.nodeType == 1 && (e = d.childNodes, e.length >= 1 && e.length <= 3)) {
            switch (e.length) {
                case 1:
                    f = e[0];
                    break;
                case 2:
                    f = e[0];
                    e = e[1];
                    f = f.nodeType == 3 || f.nodeType == 4 ? f : e;
                    break;
                default:
                    f = e[1]
            }
            if (f.nodeType == 3 || f.nodeType == 4)if (d = d.prefix ? d.nodeName.split(":")[1] : d.nodeName, f = GeoGlobe.Util.getXmlNodeValue(f)) f = f.replace(this.regExes.trimSpace, ""), b[d] = f
        }
        return b
    },
    parseExtendedData: function (a) {
        var b = {}, c, d, e, f, g = a.getElementsByTagName("Data");
        c = 0;
        for (d = g.length; c < d; c++) {
            e = g[c];
            f = e.getAttribute("name");
            var h = {}, j = e.getElementsByTagName("value");
            j.length && (h.value = this.getChildValue(j[0]));
            this.kvpAttributes ? b[f] = h.value : (e = e.getElementsByTagName("displayName"), e.length && (h.displayName = this.getChildValue(e[0])), b[f] = h)
        }
        a = a.getElementsByTagName("SimpleData");
        c = 0;
        for (d = a.length; c < d; c++)h = {}, e = a[c], f = e.getAttribute("name"), h.value = this.getChildValue(e), this.kvpAttributes ? b[f] = h.value : (h.displayName = f, b[f] = h);
        return b
    },
    parseProperty: function (a, b, c) {
        var d, a = this.getElementsByTagNameNS(a, b, c);
        try {
            d = GeoGlobe.Util.getXmlNodeValue(a[0])
        } catch (e) {
            d =
                null
        }
        return d
    },
    write: function (a) {
        GeoGlobe.Util.isArray(a) || (a = [a]);
        for (var b = this.createElementNS(this.kmlns, "kml"), c = this.createFolderXML(), d = 0, e = a.length; d < e; ++d)c.appendChild(this.createPlacemarkXML(a[d]));
        b.appendChild(c);
        return GeoGlobe.Format.XML.prototype.write.apply(this, [b])
    },
    createFolderXML: function () {
        var a = this.createElementNS(this.kmlns, "Folder");
        if (this.foldersName) {
            var b = this.createElementNS(this.kmlns, "name"), c = this.createTextNode(this.foldersName);
            b.appendChild(c);
            a.appendChild(b)
        }
        this.foldersDesc &&
        (b = this.createElementNS(this.kmlns, "description"), c = this.createTextNode(this.foldersDesc), b.appendChild(c), a.appendChild(b));
        return a
    },
    createPlacemarkXML: function (a) {
        var b = this.createElementNS(this.kmlns, "name"), c = a.style && a.style.label ? a.style.label : a.id;
        b.appendChild(this.createTextNode(a.attributes.name || c));
        var d = this.createElementNS(this.kmlns, "description");
        d.appendChild(this.createTextNode(a.attributes.description || this.placemarksDesc));
        c = this.createElementNS(this.kmlns, "Placemark");
        a.fid !=
        null && c.setAttribute("id", a.fid);
        c.appendChild(b);
        c.appendChild(d);
        b = this.buildGeometryNode(a.geometry);
        c.appendChild(b);
        a.attributes && (a = this.buildExtendedData(a.attributes)) && c.appendChild(a);
        return c
    },
    buildGeometryNode: function (a) {
        var b = a.CLASS_NAME, b = this.buildGeometry[b.substring(b.lastIndexOf(".") + 1).toLowerCase()], c = null;
        b && (c = b.apply(this, [a]));
        return c
    },
    buildGeometry: {
        point: function (a) {
            var b = this.createElementNS(this.kmlns, "Point");
            b.appendChild(this.buildCoordinatesNode(a));
            return b
        }, multipoint: function (a) {
            return this.buildGeometry.collection.apply(this,
                [a])
        }, linestring: function (a) {
            var b = this.createElementNS(this.kmlns, "LineString");
            b.appendChild(this.buildCoordinatesNode(a));
            return b
        }, multilinestring: function (a) {
            return this.buildGeometry.collection.apply(this, [a])
        }, linearring: function (a) {
            var b = this.createElementNS(this.kmlns, "LinearRing");
            b.appendChild(this.buildCoordinatesNode(a));
            return b
        }, polygon: function (a) {
            for (var b = this.createElementNS(this.kmlns, "Polygon"), a = a.components, c, d, e = 0, f = a.length; e < f; ++e)c = e == 0 ? "outerBoundaryIs" : "innerBoundaryIs",
                c = this.createElementNS(this.kmlns, c), d = this.buildGeometry.linearring.apply(this, [a[e]]), c.appendChild(d), b.appendChild(c);
            return b
        }, multipolygon: function (a) {
            return this.buildGeometry.collection.apply(this, [a])
        }, collection: function (a) {
            for (var b = this.createElementNS(this.kmlns, "MultiGeometry"), c, d = 0, e = a.components.length; d < e; ++d)(c = this.buildGeometryNode.apply(this, [a.components[d]])) && b.appendChild(c);
            return b
        }
    },
    buildCoordinatesNode: function (a) {
        var b = this.createElementNS(this.kmlns, "coordinates"),
            c;
        if (c = a.components) {
            for (var d = c.length, e = Array(d), f = 0; f < d; ++f)a = c[f], e[f] = this.buildCoordinates(a);
            c = e.join(" ")
        } else c = this.buildCoordinates(a);
        c = this.createTextNode(c);
        b.appendChild(c);
        return b
    },
    buildCoordinates: function (a) {
        this.internalProjection && this.externalProjection && (a = a.clone(), a.transform(this.internalProjection, this.externalProjection));
        return a.x + "," + a.y
    },
    buildExtendedData: function (a) {
        var b = this.createElementNS(this.kmlns, "ExtendedData"), c;
        for (c in a)if (a[c] && c != "name" && c != "description" &&
            c != "styleUrl") {
            var d = this.createElementNS(this.kmlns, "Data");
            d.setAttribute("name", c);
            var e = this.createElementNS(this.kmlns, "value");
            if (typeof a[c] == "object") {
                if (a[c].value && e.appendChild(this.createTextNode(a[c].value)), a[c].displayName) {
                    var f = this.createElementNS(this.kmlns, "displayName");
                    f.appendChild(this.getXMLDoc().createCDATASection(a[c].displayName));
                    d.appendChild(f)
                }
            } else e.appendChild(this.createTextNode(a[c]));
            d.appendChild(e);
            b.appendChild(d)
        }
        return this.isSimpleContent(b) ? null : b
    },
    CLASS_NAME: "GeoGlobe.Format.KML"
});
GeoGlobe.Format.OWSCommon = GeoGlobe.Class4OL(GeoGlobe.Format.XML.VersionedOGC, {
    defaultVersion: "1.0.0",
    getVersion: function (a) {
        var b = this.version;
        if (!b && ((a = a.getAttribute("xmlns:ows")) && a.substring(a.lastIndexOf("/") + 1) === "1.1" && (b = "1.1.0"), !b)) b = this.defaultVersion;
        return b
    },
    CLASS_NAME: "GeoGlobe.Format.OWSCommon"
});
GeoGlobe.Format.OWSCommon.v1 = GeoGlobe.Class4OL(GeoGlobe.Format.XML, {
    regExes: {trimSpace: /^\s*|\s*$/g, removeSpace: /\s*/g, splitSpace: /\s+/, trimComma: /\s*,\s*/g},
    read: function (a, b) {
        GeoGlobe.Util.applyDefaults(b, this.options);
        var c = {};
        this.readChildNodes(a, c);
        return c
    },
    readers: {
        ows: {
            Exception: function (a, b) {
                var c = {code: a.getAttribute("exceptionCode"), locator: a.getAttribute("locator"), texts: []};
                b.exceptions.push(c);
                this.readChildNodes(a, c)
            }, ExceptionText: function (a, b) {
                var c = this.getChildValue(a);
                b.texts.push(c)
            },
            ServiceIdentification: function (a, b) {
                b.serviceIdentification = {};
                this.readChildNodes(a, b.serviceIdentification)
            }, Title: function (a, b) {
                b.title = this.getChildValue(a)
            }, Abstract: function (a, b) {
                b["abstract"] = this.getChildValue(a)
            }, Keywords: function (a, b) {
                b.keywords = {};
                this.readChildNodes(a, b.keywords)
            }, Keyword: function (a, b) {
                b[this.getChildValue(a)] = !0
            }, ServiceType: function (a, b) {
                b.serviceType = {codeSpace: a.getAttribute("codeSpace"), value: this.getChildValue(a)}
            }, ServiceTypeVersion: function (a, b) {
                b.serviceTypeVersion =
                    this.getChildValue(a)
            }, Fees: function (a, b) {
                b.fees = this.getChildValue(a)
            }, AccessConstraints: function (a, b) {
                b.accessConstraints = this.getChildValue(a)
            }, ServiceProvider: function (a, b) {
                b.serviceProvider = {};
                this.readChildNodes(a, b.serviceProvider)
            }, ProviderName: function (a, b) {
                b.providerName = this.getChildValue(a)
            }, ProviderSite: function (a, b) {
                b.providerSite = this.getAttributeNS(a, this.namespaces.xlink, "href")
            }, ServiceContact: function (a, b) {
                b.serviceContact = {};
                this.readChildNodes(a, b.serviceContact)
            }, IndividualName: function (a,
                                         b) {
                b.individualName = this.getChildValue(a)
            }, PositionName: function (a, b) {
                b.positionName = this.getChildValue(a)
            }, ContactInfo: function (a, b) {
                b.contactInfo = {};
                this.readChildNodes(a, b.contactInfo)
            }, Phone: function (a, b) {
                b.phone = {};
                this.readChildNodes(a, b.phone)
            }, Voice: function (a, b) {
                b.voice = this.getChildValue(a)
            }, Address: function (a, b) {
                b.address = {};
                this.readChildNodes(a, b.address)
            }, DeliveryPoint: function (a, b) {
                b.deliveryPoint = this.getChildValue(a)
            }, City: function (a, b) {
                b.city = this.getChildValue(a)
            }, AdministrativeArea: function (a,
                                             b) {
                b.administrativeArea = this.getChildValue(a)
            }, PostalCode: function (a, b) {
                b.postalCode = this.getChildValue(a)
            }, Country: function (a, b) {
                b.country = this.getChildValue(a)
            }, ElectronicMailAddress: function (a, b) {
                b.electronicMailAddress = this.getChildValue(a)
            }, Role: function (a, b) {
                b.role = this.getChildValue(a)
            }, OperationsMetadata: function (a, b) {
                b.operationsMetadata = {};
                this.readChildNodes(a, b.operationsMetadata)
            }, Operation: function (a, b) {
                var c = a.getAttribute("name");
                b[c] = {};
                this.readChildNodes(a, b[c])
            }, DCP: function (a,
                              b) {
                b.dcp = {};
                this.readChildNodes(a, b.dcp)
            }, HTTP: function (a, b) {
                b.http = {};
                this.readChildNodes(a, b.http)
            }, Get: function (a, b) {
                if (!b.get) b.get = [];
                var c = {url: this.getAttributeNS(a, this.namespaces.xlink, "href")};
                this.readChildNodes(a, c);
                b.get.push(c)
            }, Post: function (a, b) {
                if (!b.post) b.post = [];
                var c = {url: this.getAttributeNS(a, this.namespaces.xlink, "href")};
                this.readChildNodes(a, c);
                b.post.push(c)
            }, Parameter: function (a, b) {
                if (!b.parameters) b.parameters = {};
                var c = a.getAttribute("name");
                b.parameters[c] = {};
                this.readChildNodes(a,
                    b.parameters[c])
            }, Constraint: function (a, b) {
                if (!b.constraints) b.constraints = {};
                var c = a.getAttribute("name");
                b.constraints[c] = {};
                this.readChildNodes(a, b.constraints[c])
            }, Value: function (a, b) {
                b[this.getChildValue(a)] = !0
            }, OutputFormat: function (a, b) {
                b.formats.push({value: this.getChildValue(a)});
                this.readChildNodes(a, b)
            }, WGS84BoundingBox: function (a, b) {
                var c = {};
                c.crs = a.getAttribute("crs");
                if (!b.BoundingBox) b.BoundingBox = [];
                b.BoundingBox ? b.BoundingBox.push(c) : (b.projection = c.crs, c = b);
                this.readChildNodes(a,
                    c)
            }, BoundingBox: function (a, b) {
                this.readers.ows.WGS84BoundingBox.apply(this, [a, b])
            }, LowerCorner: function (a, b) {
                var c = this.getChildValue(a).replace(this.regExes.trimSpace, ""),
                    c = c.replace(this.regExes.trimComma, ","), c = c.split(this.regExes.splitSpace);
                b.left = c[0];
                b.bottom = c[1]
            }, UpperCorner: function (a, b) {
                var c = this.getChildValue(a).replace(this.regExes.trimSpace, ""),
                    c = c.replace(this.regExes.trimComma, ","), c = c.split(this.regExes.splitSpace);
                b.right = c[0];
                b.top = c[1];
                b.bounds = new GeoGlobe.LngLatBounds(new GeoGlobe.LngLat(b.left,
                    b.bottom), new GeoGlobe.LngLat(b.right, b.top));
                delete b.left;
                delete b.bottom;
                delete b.right;
                delete b.top
            }, Language: function (a, b) {
                b.language = this.getChildValue(a)
            }
        }
    },
    writers: {
        ows: {
            BoundingBox: function (a, b) {
                var c = this.createElementNSPlus(b || "ows:BoundingBox", {attributes: {crs: a.projection}});
                this.writeNode("ows:LowerCorner", a, c);
                this.writeNode("ows:UpperCorner", a, c);
                return c
            }, LowerCorner: function (a) {
                return this.createElementNSPlus("ows:LowerCorner", {value: a.bounds._sw.lng + " " + a.bounds._sw.lat})
            }, UpperCorner: function (a) {
                return this.createElementNSPlus("ows:UpperCorner",
                    {value: a.bounds._ne.lng + " " + a.bounds._ne.lat})
            }, Identifier: function (a) {
                return this.createElementNSPlus("ows:Identifier", {value: a})
            }, Title: function (a) {
                return this.createElementNSPlus("ows:Title", {value: a})
            }, Abstract: function (a) {
                return this.createElementNSPlus("ows:Abstract", {value: a})
            }, OutputFormat: function (a) {
                return this.createElementNSPlus("ows:OutputFormat", {value: a})
            }
        }
    },
    CLASS_NAME: "GeoGlobe.Format.OWSCommon.v1"
});
GeoGlobe.Format.OWSCommon.v1_0_0 = GeoGlobe.Class4OL(GeoGlobe.Format.OWSCommon.v1, {
    namespaces: {ows: "http://www.opengis.net/ows", xlink: "http://www.w3.org/1999/xlink"},
    readers: {
        ows: GeoGlobe.Util.applyDefaults({
            ExceptionReport: function (a, b) {
                b.success = !1;
                b.exceptionReport = {
                    version: a.getAttribute("version"),
                    language: a.getAttribute("language"),
                    exceptions: []
                };
                this.readChildNodes(a, b.exceptionReport)
            }
        }, GeoGlobe.Format.OWSCommon.v1.prototype.readers.ows)
    },
    writers: {ows: GeoGlobe.Format.OWSCommon.v1.prototype.writers.ows},
    CLASS_NAME: "GeoGlobe.Format.OWSCommon.v1_0_0"
});
GeoGlobe.Format.OWSCommon.v1_1_0 = GeoGlobe.Class4OL(GeoGlobe.Format.OWSCommon.v1, {
    namespaces: {ows: "http://www.opengis.net/ows/1.1", xlink: "http://www.w3.org/1999/xlink"}, readers: {
        ows: GeoGlobe.Util.applyDefaults({
            ExceptionReport: function (a, b) {
                b.exceptionReport = {
                    version: a.getAttribute("version"),
                    language: a.getAttribute("xml:lang"),
                    exceptions: []
                };
                this.readChildNodes(a, b.exceptionReport)
            }, AllowedValues: function (a, b) {
                b.allowedValues = {};
                this.readChildNodes(a, b.allowedValues)
            }, AnyValue: function (a, b) {
                b.anyValue =
                    !0
            }, DataType: function (a, b) {
                b.dataType = this.getChildValue(a)
            }, Range: function (a, b) {
                b.range = {};
                this.readChildNodes(a, b.range)
            }, MinimumValue: function (a, b) {
                b.minValue = this.getChildValue(a)
            }, MaximumValue: function (a, b) {
                b.maxValue = this.getChildValue(a)
            }, Identifier: function (a, b) {
                b.identifier = this.getChildValue(a)
            }, SupportedCRS: function (a, b) {
                b.supportedCRS = this.getChildValue(a)
            }
        }, GeoGlobe.Format.OWSCommon.v1.prototype.readers.ows)
    }, writers: {
        ows: GeoGlobe.Util.applyDefaults({
            Range: function (a) {
                var b = this.createElementNSPlus("ows:Range",
                    {attributes: {"ows:rangeClosure": a.closure}});
                this.writeNode("ows:MinimumValue", a.minValue, b);
                this.writeNode("ows:MaximumValue", a.maxValue, b);
                return b
            }, MinimumValue: function (a) {
                return this.createElementNSPlus("ows:MinimumValue", {value: a})
            }, MaximumValue: function (a) {
                return this.createElementNSPlus("ows:MaximumValue", {value: a})
            }, Value: function (a) {
                return this.createElementNSPlus("ows:Value", {value: a})
            }
        }, GeoGlobe.Format.OWSCommon.v1.prototype.writers.ows)
    }, CLASS_NAME: "GeoGlobe.Format.OWSCommon.v1_1_0"
});
GeoGlobe.Format.WFSCapabilities = GeoGlobe.Class4OL(GeoGlobe.Format.XML.VersionedOGC, {
    defaultVersion: "1.1.0",
    CLASS_NAME: "GeoGlobe.Format.WFSCapabilities"
});
GeoGlobe.Format.WFSCapabilities.v1 = GeoGlobe.Class4OL(GeoGlobe.Format.XML, {
    namespaces: {
        wfs: "http://www.opengis.net/wfs",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance",
        ows: "http://www.opengis.net/ows"
    }, errorProperty: "featureTypeList", defaultPrefix: "wfs", read: function (a) {
        typeof a == "string" && (a = GeoGlobe.Format.XML.prototype.read.apply(this, [a]));
        if (a && a.nodeType == 9) a = a.documentElement;
        var b = {};
        this.readNode(a, b);
        return b
    }, readers: {
        wfs: {
            WFS_Capabilities: function (a,
                                        b) {
                this.readChildNodes(a, b)
            }, FeatureTypeList: function (a, b) {
                b.featureTypeList = {featureTypes: []};
                this.readChildNodes(a, b.featureTypeList)
            }, FeatureType: function (a, b) {
                var c = {};
                this.readChildNodes(a, c);
                b.featureTypes.push(c)
            }, Name: function (a, b) {
                var c = this.getChildValue(a);
                if (c && (c = c.split(":"), b.name = c.pop(), c.length > 0)) b.featureNS = this.lookupNamespaceURI(a, c[0])
            }, Title: function (a, b) {
                var c = this.getChildValue(a);
                if (c) b.title = c
            }, Abstract: function (a, b) {
                var c = this.getChildValue(a);
                c && (b["abstract"] = c)
            }
        }
    },
    CLASS_NAME: "GeoGlobe.Format.WFSCapabilities.v1"
});
GeoGlobe.Format.WFSCapabilities.v1_0_0 = GeoGlobe.Class4OL(GeoGlobe.Format.WFSCapabilities.v1, {
    readers: {
        wfs: GeoGlobe.Util.applyDefaults({
            Service: function (a, b) {
                b.service = {};
                this.readChildNodes(a, b.service)
            }, Fees: function (a, b) {
                var c = this.getChildValue(a);
                if (c && c.toLowerCase() != "none") b.fees = c
            }, AccessConstraints: function (a, b) {
                var c = this.getChildValue(a);
                if (c && c.toLowerCase() != "none") b.accessConstraints = c
            }, OnlineResource: function (a, b) {
                var c = this.getChildValue(a);
                if (c && c.toLowerCase() != "none") b.onlineResource =
                    c
            }, Keywords: function (a, b) {
                var c = this.getChildValue(a);
                if (c && c.toLowerCase() != "none") b.keywords = c.split(", ")
            }, Capability: function (a, b) {
                b.capability = {};
                this.readChildNodes(a, b.capability)
            }, Request: function (a, b) {
                b.request = {};
                this.readChildNodes(a, b.request)
            }, GetFeature: function (a, b) {
                b.getfeature = {href: {}, formats: []};
                this.readChildNodes(a, b.getfeature)
            }, ResultFormat: function (a, b) {
                for (var c = a.childNodes, d, e = 0; e < c.length; e++)d = c[e], d.nodeType == 1 && b.formats.push(d.nodeName)
            }, DCPType: function (a, b) {
                this.readChildNodes(a,
                    b)
            }, HTTP: function (a, b) {
                this.readChildNodes(a, b.href)
            }, Get: function (a, b) {
                b.get = a.getAttribute("onlineResource")
            }, Post: function (a, b) {
                b.post = a.getAttribute("onlineResource")
            }, SRS: function (a, b) {
                var c = this.getChildValue(a);
                if (c) b.srs = c
            }, LatLongBoundingBox: function (a, b) {
                var c = a.getAttribute("minx"), d = a.getAttribute("miny"), e = a.getAttribute("maxx"),
                    f = a.getAttribute("maxy");
                b.bbox = c + "," + d + "," + e + "," + f
            }, TemporalFeatureLayer: function (a, b) {
                b.temporalFeatureLayers = [];
                var c = {};
                this.readChildNodes(a, c);
                b.temporalFeatureLayers.push(c)
            },
            Extent: function (a, b) {
                b.defaultTime = a.getAttribute("default");
                var c = this.getChildValue(a).split("/");
                b.time = c
            }, Dimension: function (a, b) {
                b.defaultTime = a.getAttribute("default");
                var c = this.getChildValue(a).split("/");
                b.time = c
            }
        }, GeoGlobe.Format.WFSCapabilities.v1.prototype.readers.wfs)
    }, CLASS_NAME: "GeoGlobe.Format.WFSCapabilities.v1_0_0"
});
GeoGlobe.Format.WFSCapabilities.v1_1_0 = GeoGlobe.Class4OL(GeoGlobe.Format.WFSCapabilities.v1, {
    regExes: {trimSpace: /^\s*|\s*$/g, removeSpace: /\s*/g, splitSpace: /\s+/, trimComma: /\s*,\s*/g}, readers: {
        wfs: GeoGlobe.Util.applyDefaults({
            DefaultSRS: function (a, b) {
                var c = this.getChildValue(a);
                if (c) b.srs = c
            }, WGS84BoundingBox: function (a, b) {
                var c = this.getChildValue(a.getElementsByTagName("ows:LowerCorner")[0]).split(" "),
                    d = this.getChildValue(a.getElementsByTagName("ows:UpperCorner")[0]).split(" ");
                b.bbox = c[0] + "," + c[1] +
                    "," + d[0] + "," + d[1]
            }, TemporalFeatureLayer: function (a, b) {
                b.temporalFeatureLayers = [];
                var c = {};
                this.readChildNodes(a, c);
                b.temporalFeatureLayers.push(c)
            }, Extent: function (a, b) {
                b.defaultTime = a.getAttribute("default");
                var c = this.getChildValue(a).split("/");
                b.time = c
            }, Dimension: function (a, b) {
                b.defaultTime = a.getAttribute("default");
                var c = this.getChildValue(a).split("/");
                b.time = c
            }
        }, GeoGlobe.Format.WFSCapabilities.v1.prototype.readers.wfs),
        ows: GeoGlobe.Format.OWSCommon.v1.prototype.readers.ows
    }, CLASS_NAME: "GeoGlobe.Format.WFSCapabilities.v1_1_0"
});
GeoGlobe.Format.WFSDescribeFeatureType = GeoGlobe.Class4OL(GeoGlobe.Format.XML, {
    regExes: {trimSpace: /^\s*|\s*$/g}, namespaces: {xsd: "http://www.w3.org/2001/XMLSchema"}, readers: {
        xsd: {
            schema: function (a, b) {
                var c = [], d = {}, e, f;
                this.readChildNodes(a, {complexTypes: c, customTypes: d});
                var g = a.attributes, h, j;
                e = 0;
                for (f = g.length; e < f; ++e)h = g[e], j = h.name, j.indexOf("xmlns") === 0 ? this.setNamespace(j.split(":")[1] || "", h.value) : b[j] = h.value;
                b.featureTypes = c;
                b.targetPrefix = this.namespaceAlias[b.targetNamespace];
                e = 0;
                for (f = c.length; e <
                f; ++e)if (g = c[e], h = d[g.typeName], d[g.typeName]) g.typeName = h.name
            }, complexType: function (a, b) {
                var c = {typeName: a.getAttribute("name")};
                this.readChildNodes(a, c);
                b.complexTypes.push(c)
            }, complexContent: function (a, b) {
                this.readChildNodes(a, b)
            }, extension: function (a, b) {
                this.readChildNodes(a, b)
            }, sequence: function (a, b) {
                var c = {elements: []};
                this.readChildNodes(a, c);
                b.properties = c.elements
            }, element: function (a, b) {
                var c;
                if (b.elements) {
                    var d = {};
                    c = a.attributes;
                    for (var e, f = 0, g = c.length; f < g; ++f)e = c[f], d[e.name] = e.value;
                    c = d.type || d.ref;
                    if (!c) c = {}, this.readChildNodes(a, c), d.restriction = c, d.type = c.base;
                    d.localType = (c.base || c).split(":").pop();
                    b.elements.push(d);
                    this.readChildNodes(a, d)
                }
                b.complexTypes && (c = a.getAttribute("type"), d = c.split(":").pop(), b.customTypes[d] = {
                    name: a.getAttribute("name"),
                    type: c
                })
            }, annotation: function (a, b) {
                b.annotation = {};
                this.readChildNodes(a, b.annotation)
            }, appinfo: function (a, b) {
                if (!b.appinfo) b.appinfo = [];
                b.appinfo.push(this.getChildValue(a))
            }, documentation: function (a, b) {
                if (!b.documentation) b.documentation =
                    [];
                var c = this.getChildValue(a);
                b.documentation.push({
                    lang: a.getAttribute("xml:lang"),
                    textContent: c.replace(this.regExes.trimSpace, "")
                })
            }, simpleType: function (a, b) {
                this.readChildNodes(a, b)
            }, restriction: function (a, b) {
                b.base = a.getAttribute("base");
                this.readRestriction(a, b)
            }
        }
    }, readRestriction: function (a, b) {
        for (var c = a.childNodes, d, e, f = 0, g = c.length; f < g; ++f)d = c[f], d.nodeType == 1 && (e = d.nodeName.split(":").pop(), d = d.getAttribute("value"), b[e] ? (typeof b[e] == "string" && (b[e] = [b[e]]), b[e].push(d)) : b[e] = d)
    }, read: function (a) {
        typeof a ==
        "string" && (a = GeoGlobe.Format.XML.prototype.read.apply(this, [a]));
        if (a && a.nodeType == 9) a = a.documentElement;
        var b = {};
        if (a.nodeName.split(":").pop() === "ExceptionReport") {
            var c = new GeoGlobe.Format.OGCExceptionReport;
            b.error = c.read(a)
        } else this.readNode(a, b);
        return b
    }, CLASS_NAME: "GeoGlobe.Format.WFSDescribeFeatureType"
});
GeoGlobe.Format.WKT = GeoGlobe.Class4OL(GeoGlobe.Format, {
    initialize: function (a) {
        this.regExes = {
            typeStr: /^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,
            spaces: /\s+/,
            parenComma: /\)\s*,\s*\(/,
            doubleParenComma: /\)\s*\)\s*,\s*\(\s*\(/,
            trimParens: /^\s*\(?(.*?)\)?\s*$/
        };
        GeoGlobe.Format.prototype.initialize.apply(this, [a])
    }, read: function (a) {
        var b, c, a = a.replace(/[\n\r]/g, " ");
        if (c = this.regExes.typeStr.exec(a))if (a = c[1].toLowerCase(), c = c[2], this.parse[a] && (b = this.parse[a].apply(this, [c])), this.internalProjection && this.externalProjection)if (b &&
            b.CLASS_NAME == "GeoGlobe.Feature") b.geometry.transform(this.externalProjection, this.internalProjection); else if (b && a != "geometrycollection" && typeof b == "object") {
            a = 0;
            for (c = b.length; a < c; a++)b[a].geometry.transform(this.externalProjection, this.internalProjection)
        }
        return b
    }, write: function (a) {
        var b, c;
        a.constructor == Array ? c = !0 : (a = [a], c = !1);
        var d = [];
        c && d.push("GEOMETRYCOLLECTION(");
        for (var e = 0, f = a.length; e < f; ++e)c && e > 0 && d.push(","), b = a[e].geometry, d.push(this.extractGeometry(b));
        c && d.push(")");
        return d.join("")
    },
    extractGeometry: function (a) {
        var b = a.CLASS_NAME.split(".")[2].toLowerCase();
        if (!this.extract[b])return null;
        this.internalProjection && this.externalProjection && (a = a.clone(), a.transform(this.internalProjection, this.externalProjection));
        return (b == "collection" ? "GEOMETRYCOLLECTION" : b.toUpperCase()) + "(" + this.extract[b].apply(this, [a]) + ")"
    }, extract: {
        point: function (a) {
            return a.x + " " + a.y
        }, multipoint: function (a) {
            for (var b = [], c = 0, d = a.components.length; c < d; ++c)b.push("(" + this.extract.point.apply(this, [a.components[c]]) +
                ")");
            return b.join(",")
        }, linestring: function (a) {
            for (var b = [], c = 0, d = a.components.length; c < d; ++c)b.push(this.extract.point.apply(this, [a.components[c]]));
            return b.join(",")
        }, multilinestring: function (a) {
            for (var b = [], c = 0, d = a.components.length; c < d; ++c)b.push("(" + this.extract.linestring.apply(this, [a.components[c]]) + ")");
            return b.join(",")
        }, polygon: function (a) {
            for (var b = [], c = 0, d = a.components.length; c < d; ++c)b.push("(" + this.extract.linestring.apply(this, [a.components[c]]) + ")");
            return b.join(",")
        }, multipolygon: function (a) {
            for (var b =
                [], c = 0, d = a.components.length; c < d; ++c)b.push("(" + this.extract.polygon.apply(this, [a.components[c]]) + ")");
            return b.join(",")
        }, collection: function (a) {
            for (var b = [], c = 0, d = a.components.length; c < d; ++c)b.push(this.extractGeometry.apply(this, [a.components[c]]));
            return b.join(",")
        }
    }, parse: {
        point: function (a) {
            a = GeoGlobe.String.trim(a).split(this.regExes.spaces);
            return new GeoGlobe.Feature(new GeoGlobe.Geometry.Point(a[0], a[1]))
        }, multipoint: function (a) {
            for (var b = GeoGlobe.String.trim(a).split(","), c = [], d = 0, e = b.length; d <
            e; ++d)a = b[d].replace(this.regExes.trimParens, "$1"), c.push(this.parse.point.apply(this, [a]).geometry);
            return new GeoGlobe.Feature(new GeoGlobe.Geometry.MultiPoint(c))
        }, linestring: function (a) {
            for (var a = GeoGlobe.String.trim(a).split(","), b = [], c = 0, d = a.length; c < d; ++c)b.push(this.parse.point.apply(this, [a[c]]).geometry);
            return new GeoGlobe.Feature(new GeoGlobe.Geometry.LineString(b))
        }, multilinestring: function (a) {
            for (var b = GeoGlobe.String.trim(a).split(this.regExes.parenComma), c = [], d = 0, e = b.length; d < e; ++d)a =
                b[d].replace(this.regExes.trimParens, "$1"), c.push(this.parse.linestring.apply(this, [a]).geometry);
            return new GeoGlobe.Feature(new GeoGlobe.Geometry.MultiLineString(c))
        }, polygon: function (a) {
            for (var b, a = GeoGlobe.String.trim(a).split(this.regExes.parenComma), c = [], d = 0, e = a.length; d < e; ++d)b = a[d].replace(this.regExes.trimParens, "$1"), b = this.parse.linestring.apply(this, [b]).geometry, b = new GeoGlobe.Geometry.LinearRing(b.components), c.push(b);
            return new GeoGlobe.Feature(new GeoGlobe.Geometry.Polygon(c))
        }, multipolygon: function (a) {
            for (var b =
                GeoGlobe.String.trim(a).split(this.regExes.doubleParenComma), c = [], d = 0, e = b.length; d < e; ++d)a = b[d].replace(this.regExes.trimParens, "$1"), c.push(this.parse.polygon.apply(this, [a]).geometry);
            return new GeoGlobe.Feature(new GeoGlobe.Geometry.MultiPolygon(c))
        }, geometrycollection: function (a) {
            for (var a = a.replace(/,\s*([A-Za-z])/g, "|$1"), a = GeoGlobe.String.trim(a).split("|"), b = [], c = 0, d = a.length; c < d; ++c)b.push(GeoGlobe.Format.WKT.prototype.read.apply(this, [a[c]]));
            return b
        }
    }, CLASS_NAME: "GeoGlobe.Format.WKT"
});
GeoGlobe.Format.CQL = function () {
    function a(a) {
        function b() {
            var a = e.pop();
            switch (a.type) {
                case "LOGICAL":
                    var c = b(), g = b();
                    return new GeoGlobe.Filter.Logical({filters: [g, c], type: f[a.text.toUpperCase()]});
                case "NOT":
                    return a = b(), new GeoGlobe.Filter.Logical({filters: [a], type: GeoGlobe.Filter.Logical.NOT});
                case "BETWEEN":
                    return e.pop(), g = b(), a = b(), c = b(), new GeoGlobe.Filter.Comparison({
                        property: c,
                        lowerBoundary: a,
                        upperBoundary: g,
                        type: GeoGlobe.Filter.Comparison.BETWEEN
                    });
                case "COMPARISON":
                    return g = b(), c = b(),
                        new GeoGlobe.Filter.Comparison({property: c, value: g, type: d[a.text.toUpperCase()]});
                case "IS_NULL":
                    return c = b(), new GeoGlobe.Filter.Comparison({property: c, type: d[a.text.toUpperCase()]});
                case "VALUE":
                    return (c = a.text.match(/^'(.*)'$/)) ? c[1].replace(/''/g, "'") : Number(a.text);
                case "SPATIAL":
                    switch (a.text.toUpperCase()) {
                        case "BBOX":
                            var a = b(), c = b(), g = b(), h = b(), j = b();
                            return new GeoGlobe.Filter.Spatial({
                                type: GeoGlobe.Filter.Spatial.BBOX,
                                property: j,
                                value: GeoGlobe.LngLatBounds.fromArray([h, g, c, a])
                            });
                        case "INTERSECTS":
                            return g =
                                b(), c = b(), new GeoGlobe.Filter.Spatial({
                                type: GeoGlobe.Filter.Spatial.INTERSECTS,
                                property: c,
                                value: g
                            });
                        case "WITHIN":
                            return g = b(), c = b(), new GeoGlobe.Filter.Spatial({
                                type: GeoGlobe.Filter.Spatial.WITHIN,
                                property: c,
                                value: g
                            });
                        case "CONTAINS":
                            return g = b(), c = b(), new GeoGlobe.Filter.Spatial({
                                type: GeoGlobe.Filter.Spatial.CONTAINS,
                                property: c,
                                value: g
                            });
                        case "DWITHIN":
                            return a = b(), g = b(), c = b(), new GeoGlobe.Filter.Spatial({
                                type: GeoGlobe.Filter.Spatial.DWITHIN,
                                value: g,
                                property: c,
                                distance: Number(a)
                            })
                    }
                case "GEOMETRY":
                    return GeoGlobe.Geometry.fromWKT(a.text);
                default:
                    return a.text
            }
        }

        for (var c = [], e = []; a.length;) {
            var g = a.shift();
            switch (g.type) {
                case "PROPERTY":
                case "GEOMETRY":
                case "VALUE":
                    e.push(g);
                    break;
                case "COMPARISON":
                case "BETWEEN":
                case "IS_NULL":
                case "LOGICAL":
                    for (var j = h[g.type]; c.length > 0 && h[c[c.length - 1].type] <= j;)e.push(c.pop());
                    c.push(g);
                    break;
                case "SPATIAL":
                case "NOT":
                case "LPAREN":
                    c.push(g);
                    break;
                case "RPAREN":
                    for (; c.length > 0 && c[c.length - 1].type != "LPAREN";)e.push(c.pop());
                    c.pop();
                    c.length > 0 && c[c.length - 1].type == "SPATIAL" && e.push(c.pop());
                case "COMMA":
                case "END":
                    break;
                default:
                    throw Error("Unknown token type " + g.type);
            }
        }
        for (; c.length > 0;)e.push(c.pop());
        a = b();
        if (e.length > 0) {
            a = "Remaining tokens after building AST: \n";
            for (c = e.length - 1; c >= 0; c--)a += e[c].type + ": " + e[c].text + "\n";
            throw Error(a);
        }
        return a
    }

    var b = {
            PROPERTY: /^[_a-zA-Z]\w*/,
            COMPARISON: /^(=|<>|<=|<|>=|>|LIKE)/i,
            IS_NULL: /^IS NULL/i,
            COMMA: /^,/,
            LOGICAL: /^(AND|OR)/i,
            VALUE: /^('([^']|'')*'|\d+(\.\d*)?|\.\d+)/,
            LPAREN: /^\(/,
            RPAREN: /^\)/,
            SPATIAL: /^(BBOX|INTERSECTS|DWITHIN|WITHIN|CONTAINS)/i,
            NOT: /^NOT/i,
            BETWEEN: /^BETWEEN/i,
            GEOMETRY: function (a) {
                var b = /^(POINT|LINESTRING|POLYGON|MULTIPOINT|MULTILINESTRING|MULTIPOLYGON|GEOMETRYCOLLECTION)/.exec(a);
                if (b) {
                    var c = a.length, b = a.indexOf("(", b[0].length);
                    if (b > -1)for (var d = 1; b < c && d > 0;)switch (b++, a.charAt(b)) {
                        case "(":
                            d++;
                            break;
                        case ")":
                            d--
                    }
                    return [a.substr(0, b + 1)]
                }
            },
            END: /^$/
        }, c = {
            LPAREN: ["GEOMETRY", "SPATIAL", "PROPERTY", "VALUE", "LPAREN"],
            RPAREN: ["NOT", "LOGICAL", "END", "RPAREN"],
            PROPERTY: ["COMPARISON", "BETWEEN", "COMMA", "IS_NULL"],
            BETWEEN: ["VALUE"],
            IS_NULL: ["END"],
            COMPARISON: ["VALUE"],
            COMMA: ["GEOMETRY", "VALUE", "PROPERTY"],
            VALUE: ["LOGICAL", "COMMA", "RPAREN", "END"],
            SPATIAL: ["LPAREN"],
            LOGICAL: ["NOT", "VALUE", "SPATIAL", "PROPERTY", "LPAREN"],
            NOT: ["PROPERTY", "LPAREN"],
            GEOMETRY: ["COMMA", "RPAREN"]
        }, d = {
            "=": GeoGlobe.Filter.Comparison.EQUAL_TO,
            "<>": GeoGlobe.Filter.Comparison.NOT_EQUAL_TO,
            "<": GeoGlobe.Filter.Comparison.LESS_THAN,
            "<=": GeoGlobe.Filter.Comparison.LESS_THAN_OR_EQUAL_TO,
            ">": GeoGlobe.Filter.Comparison.GREATER_THAN,
            ">=": GeoGlobe.Filter.Comparison.GREATER_THAN_OR_EQUAL_TO,
            LIKE: GeoGlobe.Filter.Comparison.LIKE,
            BETWEEN: GeoGlobe.Filter.Comparison.BETWEEN,
            "IS NULL": GeoGlobe.Filter.Comparison.IS_NULL
        }, e = {}, f = {AND: GeoGlobe.Filter.Logical.AND, OR: GeoGlobe.Filter.Logical.OR}, g = {},
        h = {RPAREN: 3, LOGICAL: 2, COMPARISON: 1}, j;
    for (j in d)d.hasOwnProperty(j) && (e[d[j]] = j);
    for (j in f)f.hasOwnProperty(j) && (g[f[j]] = j);
    return GeoGlobe.Class4OL(GeoGlobe.Format, {
        read: function (d) {
            var e = d, d = [], f, g = ["NOT", "GEOMETRY", "SPATIAL", "PROPERTY", "LPAREN"];
            do {
                a:{
                    f = g;
                    for (var h = void 0, g = void 0, j = f.length, h = 0; h < j; h++) {
                        var g = f[h], s = b[g] instanceof
                        RegExp ? b[g].exec(e) : (0, b[g])(e);
                        if (s) {
                            f = s[0];
                            e = e.substr(f.length).replace(/^\s*/, "");
                            f = {type: g, text: f, remainder: e};
                            break a
                        }
                    }
                    d = "ERROR: In parsing: [" + e + "], expected one of: ";
                    for (h = 0; h < j; h++)g = f[h], d += "\n    " + g + ": " + b[g];
                    throw Error(d);
                }
                e = f.remainder;
                g = c[f.type];
                if (f.type != "END" && !g)throw Error("No follows list for " + f.type);
                d.push(f)
            } while (f.type != "END");
            d = a(d);
            if (this.keepData) this.data = d;
            return d
        }, write: function (a) {
            if (a instanceof GeoGlobe.Geometry)return a.toString();
            switch (a.CLASS_NAME) {
                case "GeoGlobe.Filter.Spatial":
                    switch (a.type) {
                        case GeoGlobe.Filter.Spatial.BBOX:
                            return "BBOX(" +
                                a.property + "," + a.value.toBBOX() + ")";
                        case GeoGlobe.Filter.Spatial.DWITHIN:
                            return "DWITHIN(" + a.property + ", " + this.write(a.value) + ", " + a.distance + ")";
                        case GeoGlobe.Filter.Spatial.WITHIN:
                            return "WITHIN(" + a.property + ", " + this.write(a.value) + ")";
                        case GeoGlobe.Filter.Spatial.INTERSECTS:
                            return "INTERSECTS(" + a.property + ", " + this.write(a.value) + ")";
                        case GeoGlobe.Filter.Spatial.CONTAINS:
                            return "CONTAINS(" + a.property + ", " + this.write(a.value) + ")";
                        default:
                            throw Error("Unknown spatial filter type: " + a.type);
                    }
                case "GeoGlobe.Filter.Logical":
                    if (a.type ==
                        GeoGlobe.Filter.Logical.NOT)return "NOT (" + this.write(a.filters[0]) + ")"; else {
                        for (var b = "(", c = !0, d = 0; d < a.filters.length; d++)c ? c = !1 : b += ") " + g[a.type] + " (", b += this.write(a.filters[d]);
                        return b + ")"
                    }
                case "GeoGlobe.Filter.Comparison":
                    return a.type == GeoGlobe.Filter.Comparison.BETWEEN ? a.property + " BETWEEN " + this.write(a.lowerBoundary) + " AND " + this.write(a.upperBoundary) : a.value !== null ? a.property + " " + e[a.type] + " " + this.write(a.value) : a.property + " " + e[a.type];
                case void 0:
                    if (typeof a === "string")return "'" + a.replace(/'/g,
                            "''") + "'"; else if (typeof a === "number")return String(a);
                default:
                    throw Error("Can't encode: " + a.CLASS_NAME + " " + a);
            }
        }, CLASS_NAME: "GeoGlobe.Format.CQL"
    })
}();
GeoGlobe.Format.Filter = GeoGlobe.Class4OL(GeoGlobe.Format.XML.VersionedOGC, {
    defaultVersion: "1.0.0",
    CLASS_NAME: "GeoGlobe.Format.Filter"
});
GeoGlobe.Format.Filter.v1 = GeoGlobe.Class4OL(GeoGlobe.Format.XML, {
    namespaces: {
        ogc: "http://www.opengis.net/ogc",
        gml: "http://www.opengis.net/gml",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance"
    }, defaultPrefix: "ogc", schemaLocation: null, initialize: function (a) {
        GeoGlobe.Format.XML.prototype.initialize.apply(this, [a])
    }, read: function (a) {
        var b = {};
        this.readers.ogc.Filter.apply(this, [a, b]);
        return b.filter
    }, readers: {
        ogc: {
            _expression: function (a) {
                for (var b = "", c = a.firstChild; c; c =
                    c.nextSibling)switch (c.nodeType) {
                    case 1:
                        a = this.readNode(c);
                        a.property ? b += "${" + a.property + "}" : a.value !== void 0 && (b += a.value);
                        break;
                    case 3:
                    case 4:
                        b += c.nodeValue
                }
                return b
            }, Filter: function (a, b) {
                var c = {fids: [], filters: []};
                this.readChildNodes(a, c);
                if (c.fids.length > 0) b.filter = new GeoGlobe.Filter.FeatureId({fids: c.fids}); else if (c.filters.length > 0) b.filter = c.filters[0]
            }, FeatureId: function (a, b) {
                var c = a.getAttribute("fid");
                c && b.fids.push(c)
            }, And: function (a, b) {
                var c = new GeoGlobe.Filter.Logical({type: GeoGlobe.Filter.Logical.AND});
                this.readChildNodes(a, c);
                b.filters.push(c)
            }, Or: function (a, b) {
                var c = new GeoGlobe.Filter.Logical({type: GeoGlobe.Filter.Logical.OR});
                this.readChildNodes(a, c);
                b.filters.push(c)
            }, Not: function (a, b) {
                var c = new GeoGlobe.Filter.Logical({type: GeoGlobe.Filter.Logical.NOT});
                this.readChildNodes(a, c);
                b.filters.push(c)
            }, PropertyIsLessThan: function (a, b) {
                var c = new GeoGlobe.Filter.Comparison({type: GeoGlobe.Filter.Comparison.LESS_THAN});
                this.readChildNodes(a, c);
                b.filters.push(c)
            }, PropertyIsGreaterThan: function (a, b) {
                var c =
                    new GeoGlobe.Filter.Comparison({type: GeoGlobe.Filter.Comparison.GREATER_THAN});
                this.readChildNodes(a, c);
                b.filters.push(c)
            }, PropertyIsLessThanOrEqualTo: function (a, b) {
                var c = new GeoGlobe.Filter.Comparison({type: GeoGlobe.Filter.Comparison.LESS_THAN_OR_EQUAL_TO});
                this.readChildNodes(a, c);
                b.filters.push(c)
            }, PropertyIsGreaterThanOrEqualTo: function (a, b) {
                var c = new GeoGlobe.Filter.Comparison({type: GeoGlobe.Filter.Comparison.GREATER_THAN_OR_EQUAL_TO});
                this.readChildNodes(a, c);
                b.filters.push(c)
            }, PropertyIsBetween: function (a,
                                            b) {
                var c = new GeoGlobe.Filter.Comparison({type: GeoGlobe.Filter.Comparison.BETWEEN});
                this.readChildNodes(a, c);
                b.filters.push(c)
            }, Literal: function (a, b) {
                b.value = GeoGlobe.String.numericIf(this.getChildValue(a), !0)
            }, PropertyName: function (a, b) {
                b.property = this.getChildValue(a)
            }, LowerBoundary: function (a, b) {
                b.lowerBoundary = GeoGlobe.String.numericIf(this.readers.ogc._expression.call(this, a), !0)
            }, UpperBoundary: function (a, b) {
                b.upperBoundary = GeoGlobe.String.numericIf(this.readers.ogc._expression.call(this, a), !0)
            },
            Intersects: function (a, b) {
                this.readSpatial(a, b, GeoGlobe.Filter.Spatial.INTERSECTS)
            }, Within: function (a, b) {
                this.readSpatial(a, b, GeoGlobe.Filter.Spatial.WITHIN)
            }, Contains: function (a, b) {
                this.readSpatial(a, b, GeoGlobe.Filter.Spatial.CONTAINS)
            }, DWithin: function (a, b) {
                this.readSpatial(a, b, GeoGlobe.Filter.Spatial.DWITHIN)
            }, Distance: function (a, b) {
                b.distance = parseInt(this.getChildValue(a));
                b.distanceUnits = a.getAttribute("units")
            }, Function: function () {
            }, PropertyIsNull: function (a, b) {
                var c = new GeoGlobe.Filter.Comparison({type: GeoGlobe.Filter.Comparison.IS_NULL});
                this.readChildNodes(a, c);
                b.filters.push(c)
            }
        }
    }, readSpatial: function (a, b, c) {
        c = new GeoGlobe.Filter.Spatial({type: c});
        this.readChildNodes(a, c);
        c.value = c.components[0];
        delete c.components;
        b.filters.push(c)
    }, encodeLiteral: function (a) {
        a instanceof Date && (a = GeoGlobe.Date.toISOString(a));
        return a
    }, writeOgcExpression: function (a, b) {
        a instanceof GeoGlobe.Filter.Function ? this.writeNode("Function", a, b) : this.writeNode("Literal", a, b);
        return b
    }, write: function (a) {
        return this.writers.ogc.Filter.apply(this, [a])
    }, writers: {
        ogc: {
            Filter: function (a) {
                var b =
                    this.createElementNSPlus("ogc:Filter");
                this.writeNode(this.getFilterType(a), a, b);
                return b
            }, _featureIds: function (a) {
                for (var b = this.createDocumentFragment(), c = 0, d = a.fids.length; c < d; ++c)this.writeNode("ogc:FeatureId", a.fids[c], b);
                return b
            }, FeatureId: function (a) {
                return this.createElementNSPlus("ogc:FeatureId", {attributes: {fid: a}})
            }, And: function (a) {
                for (var b = this.createElementNSPlus("ogc:And"), c, d = 0, e = a.filters.length; d < e; ++d)c = a.filters[d], this.writeNode(this.getFilterType(c), c, b);
                return b
            }, Or: function (a) {
                for (var b =
                    this.createElementNSPlus("ogc:Or"), c, d = 0, e = a.filters.length; d < e; ++d)c = a.filters[d], this.writeNode(this.getFilterType(c), c, b);
                return b
            }, Not: function (a) {
                var b = this.createElementNSPlus("ogc:Not"), a = a.filters[0];
                this.writeNode(this.getFilterType(a), a, b);
                return b
            }, PropertyIsLessThan: function (a) {
                var b = this.createElementNSPlus("ogc:PropertyIsLessThan");
                this.writeNode("PropertyName", a, b);
                this.writeOgcExpression(a.value, b);
                return b
            }, PropertyIsGreaterThan: function (a) {
                var b = this.createElementNSPlus("ogc:PropertyIsGreaterThan");
                this.writeNode("PropertyName", a, b);
                this.writeOgcExpression(a.value, b);
                return b
            }, PropertyIsLessThanOrEqualTo: function (a) {
                var b = this.createElementNSPlus("ogc:PropertyIsLessThanOrEqualTo");
                this.writeNode("PropertyName", a, b);
                this.writeOgcExpression(a.value, b);
                return b
            }, PropertyIsGreaterThanOrEqualTo: function (a) {
                var b = this.createElementNSPlus("ogc:PropertyIsGreaterThanOrEqualTo");
                this.writeNode("PropertyName", a, b);
                this.writeOgcExpression(a.value, b);
                return b
            }, PropertyIsBetween: function (a) {
                var b = this.createElementNSPlus("ogc:PropertyIsBetween");
                this.writeNode("PropertyName", a, b);
                this.writeNode("LowerBoundary", a, b);
                this.writeNode("UpperBoundary", a, b);
                return b
            }, PropertyName: function (a) {
                return this.createElementNSPlus("ogc:PropertyName", {value: a.property})
            }, Literal: function (a) {
                return this.createElementNSPlus("ogc:Literal", {value: (this.encodeLiteral || GeoGlobe.Format.Filter.v1.prototype.encodeLiteral)(a)})
            }, LowerBoundary: function (a) {
                var b = this.createElementNSPlus("ogc:LowerBoundary");
                this.writeOgcExpression(a.lowerBoundary, b);
                return b
            }, UpperBoundary: function (a) {
                var b =
                    this.createElementNSPlus("ogc:UpperBoundary");
                this.writeNode("Literal", a.upperBoundary, b);
                return b
            }, INTERSECTS: function (a) {
                return this.writeSpatial(a, "Intersects")
            }, WITHIN: function (a) {
                return this.writeSpatial(a, "Within")
            }, CONTAINS: function (a) {
                return this.writeSpatial(a, "Contains")
            }, DWITHIN: function (a) {
                var b = this.writeSpatial(a, "DWithin");
                this.writeNode("Distance", a, b);
                return b
            }, Distance: function (a) {
                return this.createElementNSPlus("ogc:Distance", {
                    attributes: {units: a.distanceUnits},
                    value: a.distance
                })
            },
            Function: function (a) {
                for (var b = this.createElementNSPlus("ogc:Function", {attributes: {name: a.name}}), a = a.params, c = 0, d = a.length; c < d; c++)this.writeOgcExpression(a[c], b);
                return b
            }, PropertyIsNull: function (a) {
                var b = this.createElementNSPlus("ogc:PropertyIsNull");
                this.writeNode("PropertyName", a, b);
                return b
            }, SortBy: function (a) {
                for (var b = this.createElementNSPlus("ogc:SortBy"), c = 0, d = a.length; c < d; c++)this.writeNode("ogc:SortProperty", a[c], b);
                return b
            }, SortProperty: function (a) {
                var b = this.createElementNSPlus("ogc:SortProperty");
                this.writeNode("ogc:PropertyName", a, b);
                this.writeNode("ogc:SortOrder", a.order == "DESC" ? "DESC" : "ASC", b);
                return b
            }, SortOrder: function (a) {
                return this.createElementNSPlus("ogc:SortOrder", {value: a})
            }
        }
    }, getFilterType: function (a) {
        var b = this.filterMap[a.type];
        if (!b)throw"Filter writing not supported for rule type: " + a.type;
        return b
    }, filterMap: {
        "&&": "And",
        "||": "Or",
        "!": "Not",
        "==": "PropertyIsEqualTo",
        "!=": "PropertyIsNotEqualTo",
        "<": "PropertyIsLessThan",
        ">": "PropertyIsGreaterThan",
        "<=": "PropertyIsLessThanOrEqualTo",
        ">=": "PropertyIsGreaterThanOrEqualTo",
        "..": "PropertyIsBetween",
        "~": "PropertyIsLike",
        NULL: "PropertyIsNull",
        BBOX: "BBOX",
        DWITHIN: "DWITHIN",
        WITHIN: "WITHIN",
        CONTAINS: "CONTAINS",
        INTERSECTS: "INTERSECTS",
        FID: "_featureIds"
    }, CLASS_NAME: "GeoGlobe.Format.Filter.v1"
});
GeoGlobe.Format.Filter.v1_0_0 = GeoGlobe.Class4OL(GeoGlobe.Format.GML.v2, GeoGlobe.Format.Filter.v1, {
    VERSION: "1.0.0", schemaLocation: "http://www.opengis.net/ogc/filter/1.0.0/filter.xsd", initialize: function (a) {
        GeoGlobe.Format.GML.v2.prototype.initialize.apply(this, [a])
    }, readers: {
        ogc: GeoGlobe.Util.applyDefaults({
            PropertyIsEqualTo: function (a, b) {
                var c = new GeoGlobe.Filter.Comparison({type: GeoGlobe.Filter.Comparison.EQUAL_TO});
                this.readChildNodes(a, c);
                b.filters.push(c)
            }, PropertyIsNotEqualTo: function (a, b) {
                var c =
                    new GeoGlobe.Filter.Comparison({type: GeoGlobe.Filter.Comparison.NOT_EQUAL_TO});
                this.readChildNodes(a, c);
                b.filters.push(c)
            }, PropertyIsLike: function (a, b) {
                var c = new GeoGlobe.Filter.Comparison({type: GeoGlobe.Filter.Comparison.LIKE});
                this.readChildNodes(a, c);
                var d = a.getAttribute("wildCard"), e = a.getAttribute("singleChar"), f = a.getAttribute("escape");
                c.value2regex(d, e, f);
                b.filters.push(c)
            }
        }, GeoGlobe.Format.Filter.v1.prototype.readers.ogc),
        gml: GeoGlobe.Format.GML.v2.prototype.readers.gml,
        feature: GeoGlobe.Format.GML.v2.prototype.readers.feature
    },
    writers: {
        ogc: GeoGlobe.Util.applyDefaults({
            PropertyIsEqualTo: function (a) {
                var b = this.createElementNSPlus("ogc:PropertyIsEqualTo");
                this.writeNode("PropertyName", a, b);
                this.writeOgcExpression(a.value, b);
                return b
            }, PropertyIsNotEqualTo: function (a) {
                var b = this.createElementNSPlus("ogc:PropertyIsNotEqualTo");
                this.writeNode("PropertyName", a, b);
                this.writeOgcExpression(a.value, b);
                return b
            }, PropertyIsLike: function (a) {
                var b = this.createElementNSPlus("ogc:PropertyIsLike", {
                    attributes: {
                        wildCard: "*",
                        singleChar: ".",
                        escape: "!"
                    }
                });
                this.writeNode("PropertyName", a, b);
                this.writeNode("Literal", a.regex2value(), b);
                return b
            }, BBOX: function (a) {
                var b = this.createElementNSPlus("ogc:BBOX");
                a.property && this.writeNode("PropertyName", a, b);
                var c = this.writeNode("gml:Box", a.value, b);
                a.projection && c.setAttribute("srsName", a.projection);
                return b
            }
        }, GeoGlobe.Format.Filter.v1.prototype.writers.ogc),
        gml: GeoGlobe.Format.GML.v2.prototype.writers.gml,
        feature: GeoGlobe.Format.GML.v2.prototype.writers.feature
    }, writeSpatial: function (a, b) {
        var c = this.createElementNSPlus("ogc:" +
            b);
        this.writeNode("PropertyName", a, c);
        if (a.value instanceof GeoGlobe.Filter.Function) this.writeNode("Function", a.value, c); else {
            var d;
            d = a.value instanceof GeoGlobe.Geometry ? this.writeNode("feature:_geometry", a.value).firstChild : this.writeNode("gml:Box", a.value);
            a.projection && d.setAttribute("srsName", a.projection);
            c.appendChild(d)
        }
        return c
    }, CLASS_NAME: "GeoGlobe.Format.Filter.v1_0_0"
});
GeoGlobe.Format.Filter.v1_1_0 = GeoGlobe.Class4OL(GeoGlobe.Format.GML.v3, GeoGlobe.Format.Filter.v1, {
    VERSION: "1.1.0", schemaLocation: "http://www.opengis.net/ogc/filter/1.1.0/filter.xsd", initialize: function (a) {
        GeoGlobe.Format.GML.v3.prototype.initialize.apply(this, [a])
    }, readers: {
        ogc: GeoGlobe.Util.applyDefaults({
                PropertyIsEqualTo: function (a, b) {
                    var c = a.getAttribute("matchCase"), c = new GeoGlobe.Filter.Comparison({
                        type: GeoGlobe.Filter.Comparison.EQUAL_TO,
                        matchCase: !(c === "false" || c === "0")
                    });
                    this.readChildNodes(a,
                        c);
                    b.filters.push(c)
                }, PropertyIsNotEqualTo: function (a, b) {
                    var c = a.getAttribute("matchCase"), c = new GeoGlobe.Filter.Comparison({
                        type: GeoGlobe.Filter.Comparison.NOT_EQUAL_TO,
                        matchCase: !(c === "false" || c === "0")
                    });
                    this.readChildNodes(a, c);
                    b.filters.push(c)
                }, PropertyIsLike: function (a, b) {
                    var c = new GeoGlobe.Filter.Comparison({type: GeoGlobe.Filter.Comparison.LIKE});
                    this.readChildNodes(a, c);
                    var d = a.getAttribute("wildCard"), e = a.getAttribute("singleChar"), f = a.getAttribute("escapeChar");
                    c.value2regex(d, e, f);
                    b.filters.push(c)
                }
            },
            GeoGlobe.Format.Filter.v1.prototype.readers.ogc),
        gml: GeoGlobe.Format.GML.v3.prototype.readers.gml,
        feature: GeoGlobe.Format.GML.v3.prototype.readers.feature
    }, writers: {
        ogc: GeoGlobe.Util.applyDefaults({
            PropertyIsEqualTo: function (a) {
                var b = this.createElementNSPlus("ogc:PropertyIsEqualTo", {attributes: {matchCase: a.matchCase}});
                this.writeNode("PropertyName", a, b);
                this.writeOgcExpression(a.value, b);
                return b
            }, PropertyIsNotEqualTo: function (a) {
                var b = this.createElementNSPlus("ogc:PropertyIsNotEqualTo", {attributes: {matchCase: a.matchCase}});
                this.writeNode("PropertyName", a, b);
                this.writeOgcExpression(a.value, b);
                return b
            }, PropertyIsLike: function (a) {
                var b = this.createElementNSPlus("ogc:PropertyIsLike", {
                    attributes: {
                        matchCase: a.matchCase,
                        wildCard: "*",
                        singleChar: ".",
                        escapeChar: "!"
                    }
                });
                this.writeNode("PropertyName", a, b);
                this.writeNode("Literal", a.regex2value(), b);
                return b
            }, BBOX: function (a) {
                var b = this.createElementNSPlus("ogc:BBOX");
                a.property && this.writeNode("PropertyName", a, b);
                var c = this.writeNode("gml:Envelope", a.value);
                a.projection && c.setAttribute("srsName",
                    a.projection);
                b.appendChild(c);
                return b
            }, SortBy: function (a) {
                for (var b = this.createElementNSPlus("ogc:SortBy"), c = 0, d = a.length; c < d; c++)this.writeNode("ogc:SortProperty", a[c], b);
                return b
            }, SortProperty: function (a) {
                var b = this.createElementNSPlus("ogc:SortProperty");
                this.writeNode("ogc:PropertyName", a, b);
                this.writeNode("ogc:SortOrder", a.order == "DESC" ? "DESC" : "ASC", b);
                return b
            }, SortOrder: function (a) {
                return this.createElementNSPlus("ogc:SortOrder", {value: a})
            }
        }, GeoGlobe.Format.Filter.v1.prototype.writers.ogc),
        gml: GeoGlobe.Format.GML.v3.prototype.writers.gml, feature: GeoGlobe.Format.GML.v3.prototype.writers.feature
    }, writeSpatial: function (a, b) {
        var c = this.createElementNSPlus("ogc:" + b);
        this.writeNode("PropertyName", a, c);
        if (a.value instanceof GeoGlobe.Filter.Function) this.writeNode("Function", a.value, c); else {
            var d;
            d = a.value instanceof GeoGlobe.Geometry ? this.writeNode("feature:_geometry", a.value).firstChild : this.writeNode("gml:Envelope", a.value);
            a.projection && d.setAttribute("srsName", a.projection);
            c.appendChild(d)
        }
        return c
    },
    CLASS_NAME: "GeoGlobe.Format.Filter.v1_1_0"
});
GeoGlobe.Format.WFST = function (a) {
    var a = GeoGlobe.Util.applyDefaults(a, GeoGlobe.Format.WFST.DEFAULTS),
        b = GeoGlobe.Format.WFST["v" + a.version.replace(/\./g, "_")];
    if (!b)throw"Unsupported WFST version: " + a.version;
    return new b(a)
};
GeoGlobe.Format.WFST.DEFAULTS = {version: "1.0.0"};
GeoGlobe.Format.WFST.v1 = GeoGlobe.Class4OL(GeoGlobe.Format.XML, {
    namespaces: {
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance",
        wfs: "http://www.opengis.net/wfs",
        gml: "http://www.opengis.net/gml",
        ogc: "http://www.opengis.net/ogc",
        ows: "http://www.opengis.net/ows"
    },
    defaultPrefix: "wfs",
    version: null,
    schemaLocations: null,
    srsName: null,
    extractAttributes: !0,
    xy: !0,
    stateName: null,
    initialize: function (a) {
        this.stateName = {};
        this.stateName[GeoGlobe.State.INSERT] = "wfs:Insert";
        this.stateName[GeoGlobe.State.UPDATE] =
            "wfs:Update";
        this.stateName[GeoGlobe.State.DELETE] = "wfs:Delete";
        GeoGlobe.Format.XML.prototype.initialize.apply(this, [a])
    },
    getSrsName: function (a, b) {
        var c = b && b.srsName;
        c || (c = a && a.layer ? a.layer.projection.getCode() : this.srsName);
        return c
    },
    read: function (a, b) {
        b = b || {};
        GeoGlobe.Util.applyDefaults(b, {output: "features"});
        typeof a == "string" && (a = GeoGlobe.Format.XML.prototype.read.apply(this, [a]));
        if (a && a.nodeType == 9) a = a.documentElement;
        var c = {};
        a && this.readNode(a, c, !0);
        if (c.features && b.output === "features") c =
            c.features;
        return c
    },
    readers: {
        wfs: {
            FeatureCollection: function (a, b) {
                b.features = [];
                this.readChildNodes(a, b)
            }
        }
    },
    write: function (a, b) {
        var c = this.writeNode("wfs:Transaction", {features: a, options: b}), d = this.schemaLocationAttr();
        d && this.setAttributeNS(c, this.namespaces.xsi, "xsi:schemaLocation", d);
        return GeoGlobe.Format.XML.prototype.write.apply(this, [c])
    },
    writers: {
        wfs: {
            GetFeature: function (a) {
                var b = this.createElementNSPlus("wfs:GetFeature", {
                    attributes: {
                        service: "WFS",
                        version: this.version,
                        outputFormat: a && a.outputFormat,
                        maxFeatures: a && a.maxFeatures,
                        resultType: a && a.resultType,
                        startPosition: a && a.startPosition,
                        "xsi:schemaLocation": this.schemaLocationAttr(a)
                    }
                });
                if (typeof this.featureType == "string") this.writeNode("Query", a, b); else for (var c = 0, d = this.featureType.length; c < d; c++)a.featureType = this.featureType[c], this.writeNode("Query", a, b);
                return b
            }, Transaction: function (a) {
                var a = a || {}, b = a.options || {}, c = this.createElementNSPlus("wfs:Transaction", {
                    attributes: {
                        service: "WFS",
                        version: this.version,
                        handle: b.handle
                    }
                }), d, e = a.features;
                if (e) {
                    b.multi === !0 && GeoGlobe.Util.extend(this.geometryTypes, {
                        "GeoGlobe.Geometry.Point": "MultiPoint",
                        "GeoGlobe.Geometry.LineString": this.multiCurve === !0 ? "MultiCurve" : "MultiLineString",
                        "GeoGlobe.Geometry.Polygon": this.multiSurface === !0 ? "MultiSurface" : "MultiPolygon"
                    });
                    var f, g, a = 0;
                    for (d = e.length; a < d; ++a)g = e[a], (f = this.stateName[g.state]) && this.writeNode(f, {
                        feature: g,
                        options: b
                    }, c);
                    b.multi === !0 && this.setGeometryTypes()
                }
                if (b.nativeElements) {
                    a = 0;
                    for (d = b.nativeElements.length; a < d; ++a)this.writeNode("wfs:Native",
                        b.nativeElements[a], c)
                }
                return c
            }, Native: function (a) {
                return this.createElementNSPlus("wfs:Native", {
                    attributes: {
                        vendorId: a.vendorId,
                        safeToIgnore: a.safeToIgnore
                    }, value: a.value
                })
            }, Insert: function (a) {
                var b = a.feature, a = a.options,
                    a = this.createElementNSPlus("wfs:Insert", {attributes: {handle: a && a.handle}});
                this.srsName = this.getSrsName(b);
                this.writeNode("feature:_typeName", b, a);
                return a
            }, Update: function (a) {
                var b = a.feature, a = a.options, a = this.createElementNSPlus("wfs:Update", {
                    attributes: {
                        handle: a && a.handle, typeName: (this.featureNS ?
                            this.featurePrefix + ":" : "") + this.featureType
                    }
                });
                this.featureNS && a.setAttribute("xmlns:" + this.featurePrefix, this.featureNS);
                var c = b.modified;
                if (this.geometryName !== null && (!c || c.geometry !== void 0)) this.srsName = this.getSrsName(b), this.writeNode("Property", {
                    name: this.geometryName,
                    value: b.geometry
                }, a);
                for (var d in b.attributes)b.attributes[d] !== void 0 && (!c || !c.attributes || c.attributes && c.attributes[d] !== void 0) && this.writeNode("Property", {
                    name: d,
                    value: b.attributes[d]
                }, a);
                this.writeNode("ogc:Filter", new GeoGlobe.Filter.FeatureId({fids: [b.fid]}),
                    a);
                return a
            }, Property: function (a) {
                var b = this.createElementNSPlus("wfs:Property");
                this.writeNode("Name", a.name, b);
                a.value !== null && this.writeNode("Value", a.value, b);
                return b
            }, Name: function (a) {
                return this.createElementNSPlus("wfs:Name", {value: a})
            }, Value: function (a) {
                var b;
                a instanceof GeoGlobe.Geometry ? (b = this.createElementNSPlus("wfs:Value"), a = this.writeNode("feature:_geometry", a).firstChild, b.appendChild(a)) : b = this.createElementNSPlus("wfs:Value", {value: a});
                return b
            }, Delete: function (a) {
                var b = a.feature,
                    a = a.options, a = this.createElementNSPlus("wfs:Delete", {
                        attributes: {
                            handle: a && a.handle,
                            typeName: (this.featureNS ? this.featurePrefix + ":" : "") + this.featureType
                        }
                    });
                this.featureNS && a.setAttribute("xmlns:" + this.featurePrefix, this.featureNS);
                this.writeNode("ogc:Filter", new GeoGlobe.Filter.FeatureId({fids: [b.fid]}), a);
                return a
            }
        }
    },
    schemaLocationAttr: function (a) {
        var a = GeoGlobe.Util.extend({featurePrefix: this.featurePrefix, schema: this.schema}, a),
            b = GeoGlobe.Util.extend({}, this.schemaLocations);
        if (a.schema) b[a.featurePrefix] =
            a.schema;
        var a = [], c, d;
        for (d in b)(c = this.namespaces[d]) && a.push(c + " " + b[d]);
        return a.join(" ") || void 0
    },
    setFilterProperty: function (a) {
        if (a.filters)for (var b = 0, c = a.filters.length; b < c; ++b)GeoGlobe.Format.WFST.v1.prototype.setFilterProperty.call(this, a.filters[b]); else if (a instanceof GeoGlobe.Filter.Spatial && !a.property) a.property = this.geometryName
    },
    CLASS_NAME: "GeoGlobe.Format.WFST.v1"
});
GeoGlobe.Format.WFST.v1_0_0 = GeoGlobe.Class4OL(GeoGlobe.Format.Filter.v1_0_0, GeoGlobe.Format.WFST.v1, {
    version: "1.0.0",
    srsNameInQuery: !1,
    schemaLocations: {wfs: "http://schemas.opengis.net/wfs/1.0.0/WFS-transaction.xsd"},
    initialize: function (a) {
        GeoGlobe.Format.Filter.v1_0_0.prototype.initialize.apply(this, [a]);
        GeoGlobe.Format.WFST.v1.prototype.initialize.apply(this, [a])
    },
    readNode: function () {
        return GeoGlobe.Format.GML.v2.prototype.readNode.apply(this, arguments)
    },
    readers: {
        wfs: GeoGlobe.Util.applyDefaults({
            WFS_TransactionResponse: function (a,
                                               b) {
                b.insertIds = [];
                b.success = !1;
                this.readChildNodes(a, b)
            }, InsertResult: function (a, b) {
                var c = {fids: []};
                this.readChildNodes(a, c);
                b.insertIds = b.insertIds.concat(c.fids)
            }, TransactionResult: function (a, b) {
                this.readChildNodes(a, b)
            }, Status: function (a, b) {
                this.readChildNodes(a, b)
            }, SUCCESS: function (a, b) {
                b.success = !0
            }
        }, GeoGlobe.Format.WFST.v1.prototype.readers.wfs),
        gml: GeoGlobe.Format.GML.v2.prototype.readers.gml,
        feature: GeoGlobe.Format.GML.v2.prototype.readers.feature,
        ogc: GeoGlobe.Format.Filter.v1_0_0.prototype.readers.ogc
    },
    writers: {
        wfs: GeoGlobe.Util.applyDefaults({
            Query: function (a) {
                var a = GeoGlobe.Util.extend({
                    featureNS: this.featureNS,
                    featurePrefix: this.featurePrefix,
                    featureType: this.featureType,
                    srsName: this.srsName,
                    srsNameInQuery: this.srsNameInQuery
                }, a), b = a.featurePrefix, c = this.createElementNSPlus("wfs:Query", {
                    attributes: {
                        typeName: (a.featureNS ? b + ":" : "") + a.featureType,
                        time: a && a.time,
                        userecent: a && a.userecent
                    }
                });
                a.srsNameInQuery && a.srsName && c.setAttribute("srsName", a.srsName);
                a.featureNS && c.setAttribute("xmlns:" + b, a.featureNS);
                if (a.propertyNames)for (var b = 0, d = a.propertyNames.length; b < d; b++)this.writeNode("ogc:PropertyName", {property: a.propertyNames[b]}, c);
                a.filter && (this.setFilterProperty(a.filter), this.writeNode("ogc:Filter", a.filter, c));
                a.sortBy && this.writeNode("ogc:SortBy", a.sortBy, c);
                a.groupBy && this.writeNode("ogc:GroupBy", a.groupBy, c);
                return c
            }
        }, GeoGlobe.Format.WFST.v1.prototype.writers.wfs),
        gml: GeoGlobe.Format.GML.v2.prototype.writers.gml,
        feature: GeoGlobe.Format.GML.v2.prototype.writers.feature,
        ogc: GeoGlobe.Format.Filter.v1_0_0.prototype.writers.ogc
    },
    CLASS_NAME: "GeoGlobe.Format.WFST.v1_0_0"
});
GeoGlobe.Format.WFST.v1_1_0 = GeoGlobe.Class4OL(GeoGlobe.Format.Filter.v1_1_0, GeoGlobe.Format.WFST.v1, {
    version: "1.1.0", schemaLocations: {wfs: "http://schemas.opengis.net/wfs/1.1.0/wfs.xsd"}, initialize: function (a) {
        GeoGlobe.Format.Filter.v1_1_0.prototype.initialize.apply(this, [a]);
        GeoGlobe.Format.WFST.v1.prototype.initialize.apply(this, [a])
    }, readNode: function () {
        return GeoGlobe.Format.GML.v3.prototype.readNode.apply(this, arguments)
    }, readers: {
        wfs: GeoGlobe.Util.applyDefaults({
            FeatureCollection: function (a, b) {
                b.numberOfFeatures =
                    parseInt(a.getAttribute("numberOfFeatures"));
                GeoGlobe.Format.WFST.v1.prototype.readers.wfs.FeatureCollection.apply(this, arguments)
            }, TransactionResponse: function (a, b) {
                b.insertIds = [];
                b.success = !1;
                this.readChildNodes(a, b)
            }, TransactionSummary: function (a, b) {
                b.success = !0
            }, InsertResults: function (a, b) {
                this.readChildNodes(a, b)
            }, Feature: function (a, b) {
                var c = {fids: []};
                this.readChildNodes(a, c);
                b.insertIds.push(c.fids[0])
            }
        }, GeoGlobe.Format.WFST.v1.prototype.readers.wfs),
        gml: GeoGlobe.Format.GML.v3.prototype.readers.gml,
        feature: GeoGlobe.Format.GML.v3.prototype.readers.feature,
        ogc: GeoGlobe.Format.Filter.v1_1_0.prototype.readers.ogc,
        ows: GeoGlobe.Format.OWSCommon.v1_0_0.prototype.readers.ows
    }, writers: {
        wfs: GeoGlobe.Util.applyDefaults({
            GetFeature: function (a) {
                var b = GeoGlobe.Format.WFST.v1.prototype.writers.wfs.GetFeature.apply(this, arguments);
                a && this.setAttributes(b, {resultType: a.resultType, startIndex: a.startIndex, count: a.count});
                return b
            }, Query: function (a) {
                var a = GeoGlobe.Util.extend({
                    featureNS: this.featureNS, featurePrefix: this.featurePrefix,
                    featureType: this.featureType, srsName: this.srsName
                }, a), b = a.featurePrefix, c = this.createElementNSPlus("wfs:Query", {
                    attributes: {
                        typeName: (a.featureNS ? b + ":" : "") + a.featureType,
                        srsName: a.srsName,
                        time: a && a.time,
                        userecent: a && a.userecent
                    }
                });
                a.featureNS && c.setAttribute("xmlns:" + b, a.featureNS);
                if (a.propertyNames)for (var b = 0, d = a.propertyNames.length; b < d; b++)this.writeNode("wfs:PropertyName", {property: a.propertyNames[b]}, c);
                a.filter && (GeoGlobe.Format.WFST.v1_1_0.prototype.setFilterProperty.call(this, a.filter),
                    this.writeNode("ogc:Filter", a.filter, c));
                a.sortBy && this.writeNode("ogc:SortBy", a.sortBy, c);
                a.groupBy && this.writeNode("ogc:GroupBy", a.groupBy, c);
                return c
            }, PropertyName: function (a) {
                return this.createElementNSPlus("wfs:PropertyName", {value: a.property})
            }
        }, GeoGlobe.Format.WFST.v1.prototype.writers.wfs),
        gml: GeoGlobe.Format.GML.v3.prototype.writers.gml,
        feature: GeoGlobe.Format.GML.v3.prototype.writers.feature,
        ogc: GeoGlobe.Format.Filter.v1_1_0.prototype.writers.ogc
    }, CLASS_NAME: "GeoGlobe.Format.WFST.v1_1_0"
});
GeoGlobe.Format.JSON = GeoGlobe.Class4OL(GeoGlobe.Format, {
    indent: "    ", space: " ", newline: "\n", level: 0, pretty: !1, nativeJSON: function () {
        return !(!window.JSON || !(typeof JSON.parse == "function" && typeof JSON.stringify == "function"))
    }(), read: function (a, b) {
        var c;
        if (this.nativeJSON) c = JSON.parse(a, b); else try {
            if (/^[\],:{}\s]*$/.test(a.replace(/\\["\\\/bfnrtu]/g, "@").replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, "]").replace(/(?:^|:|,)(?:\s*\[)+/g, "")) && (c = eval("(" + a + ")"), typeof b ===
                "function")) {
                var d = function (a, c) {
                    if (c && typeof c === "object")for (var e in c)c.hasOwnProperty(e) && (c[e] = d(e, c[e]));
                    return b(a, c)
                };
                c = d("", c)
            }
        } catch (e) {
        }
        if (this.keepData) this.data = c;
        return c
    }, write: function (a, b) {
        this.pretty = !!b;
        var c = null, d = typeof a;
        if (this.serialize[d])try {
            c = !this.pretty && this.nativeJSON ? JSON.stringify(a) : this.serialize[d].apply(this, [a])
        } catch (e) {
            GeoGlobe.Console.error("Trouble serializing: " + e)
        }
        return c
    }, writeIndent: function () {
        var a = [];
        if (this.pretty)for (var b = 0; b < this.level; ++b)a.push(this.indent);
        return a.join("")
    }, writeNewline: function () {
        return this.pretty ? this.newline : ""
    }, writeSpace: function () {
        return this.pretty ? this.space : ""
    }, serialize: {
        object: function (a) {
            if (a == null)return "null";
            if (a.constructor == Date)return this.serialize.date.apply(this, [a]);
            if (a.constructor == Array)return this.serialize.array.apply(this, [a]);
            var b = ["{"];
            this.level += 1;
            var c, d, e, f = !1;
            for (c in a)a.hasOwnProperty(c) && (d = GeoGlobe.Format.JSON.prototype.write.apply(this, [c, this.pretty]), e = GeoGlobe.Format.JSON.prototype.write.apply(this,
                [a[c], this.pretty]), d != null && e != null && (f && b.push(","), b.push(this.writeNewline(), this.writeIndent(), d, ":", this.writeSpace(), e), f = !0));
            this.level -= 1;
            b.push(this.writeNewline(), this.writeIndent(), "}");
            return b.join("")
        }, array: function (a) {
            var b, c = ["["];
            this.level += 1;
            for (var d = 0, e = a.length; d < e; ++d)b = GeoGlobe.Format.JSON.prototype.write.apply(this, [a[d], this.pretty]), b != null && (d > 0 && c.push(","), c.push(this.writeNewline(), this.writeIndent(), b));
            this.level -= 1;
            c.push(this.writeNewline(), this.writeIndent(),
                "]");
            return c.join("")
        }, string: function (a) {
            var b = {"\u0008": "\\b", "\t": "\\t", "\n": "\\n", "\u000c": "\\f", "\r": "\\r", '"': '\\"', "\\": "\\\\"};
            if (/["\\\x00-\x1f]/.test(a))return '"' + a.replace(/([\x00-\x1f\\"])/g, function (a, d) {
                    var e = b[d];
                    if (e)return e;
                    e = d.charCodeAt();
                    return "\\u00" + Math.floor(e / 16).toString(16) + (e % 16).toString(16)
                }) + '"';
            return '"' + a + '"'
        }, number: function (a) {
            return isFinite(a) ? String(a) : "null"
        }, "boolean": function (a) {
            return String(a)
        }, date: function (a) {
            function b(a) {
                return a < 10 ? "0" + a : a
            }

            return '"' +
                a.getFullYear() + "-" + b(a.getMonth() + 1) + "-" + b(a.getDate()) + "T" + b(a.getHours()) + ":" + b(a.getMinutes()) + ":" + b(a.getSeconds()) + '"'
        }
    }, CLASS_NAME: "GeoGlobe.Format.JSON"
});
GeoGlobe.Format.GeoJSON = GeoGlobe.Class4OL(GeoGlobe.Format.JSON, {
    ignoreExtraDims: !1, read: function (a, b, c) {
        var b = b ? b : "FeatureCollection", d = null, e = null;
        if (e = typeof a == "string" ? GeoGlobe.Format.JSON.prototype.read.apply(this, [a, c]) : a)if (typeof e.type != "string") GeoGlobe.Console.error("Bad GeoJSON - no type: " + a); else {
            if (this.isValidType(e, b))switch (b) {
                case "Geometry":
                    try {
                        d = this.parseGeometry(e)
                    } catch (f) {
                        GeoGlobe.Console.error(f)
                    }
                    break;
                case "Feature":
                    try {
                        d = this.parseFeature(e), d.type = "Feature"
                    } catch (g) {
                        GeoGlobe.Console.error(g)
                    }
                    break;
                case "FeatureCollection":
                    switch (d = [], e.type) {
                        case "Feature":
                            try {
                                d.push(this.parseFeature(e))
                            } catch (h) {
                                d = null, GeoGlobe.Console.error(h)
                            }
                            break;
                        case "FeatureCollection":
                            a = 0;
                            for (b = e.features.length; a < b; ++a)try {
                                d.push(this.parseFeature(e.features[a]))
                            } catch (j) {
                                d = null, GeoGlobe.Console.error(j)
                            }
                            break;
                        default:
                            try {
                                var l = this.parseGeometry(e);
                                d.push(new GeoGlobe.Feature(l))
                            } catch (m) {
                                d = null, GeoGlobe.Console.error(m)
                            }
                    }
            }
        } else GeoGlobe.Console.error("Bad JSON: " + a);
        return d
    }, isValidType: function (a, b) {
        var c = !1;
        switch (b) {
            case "Geometry":
                GeoGlobe.Util.indexOf(["Point", "MultiPoint", "LineString", "MultiLineString", "Polygon", "MultiPolygon", "Box", "GeometryCollection"], a.type) == -1 ? GeoGlobe.Console.error("Unsupported geometry type: " + a.type) : c = !0;
                break;
            case "FeatureCollection":
                c = !0;
                break;
            default:
                a.type == b ? c = !0 : GeoGlobe.Console.error("Cannot convert types from " + a.type + " to " + b)
        }
        return c
    }, parseFeature: function (a) {
        var b, c, d;
        c = a.properties ? a.properties : {};
        d = a.geometry && a.geometry.bbox || a.bbox;
        try {
            b = this.parseGeometry(a.geometry)
        } catch (e) {
            throw e;
        }
        b = new GeoGlobe.Feature(b, c);
        if (d) b.bounds = GeoGlobe.LngLatBounds.fromArray(d);
        if (a.id) b.fid = a.id;
        return b
    }, parseGeometry: function (a) {
        if (a == null)return null;
        var b, c = !1;
        if (a.type == "GeometryCollection") {
            if (!GeoGlobe.Util.isArray(a.geometries))throw"GeometryCollection must have geometries array: " + a;
            b = a.geometries.length;
            for (var c = Array(b), d = 0; d < b; ++d)c[d] = this.parseGeometry.apply(this, [a.geometries[d]]);
            b = new GeoGlobe.Geometry.Collection(c);
            c = !0
        } else {
            if (!GeoGlobe.Util.isArray(a.coordinates))throw"Geometry must have coordinates array: " +
            a;
            if (!this.parseCoords[a.type.toLowerCase()])throw"Unsupported geometry type: " + a.type;
            try {
                b = this.parseCoords[a.type.toLowerCase()].apply(this, [a.coordinates])
            } catch (e) {
                throw e;
            }
        }
        this.internalProjection && this.externalProjection && !c && b.transform(this.externalProjection, this.internalProjection);
        return b
    }, parseCoords: {
        point: function (a) {
            if (this.ignoreExtraDims == !1 && a.length != 2)throw"Only 2D points are supported: " + a;
            return new GeoGlobe.Geometry.Point(a[0], a[1])
        }, multipoint: function (a) {
            for (var b = [], c =
                null, d = 0, e = a.length; d < e; ++d) {
                try {
                    c = this.parseCoords.point.apply(this, [a[d]])
                } catch (f) {
                    throw f;
                }
                b.push(c)
            }
            return new GeoGlobe.Geometry.MultiPoint(b)
        }, linestring: function (a) {
            for (var b = [], c = null, d = 0, e = a.length; d < e; ++d) {
                try {
                    c = this.parseCoords.point.apply(this, [a[d]])
                } catch (f) {
                    throw f;
                }
                b.push(c)
            }
            return new GeoGlobe.Geometry.LineString(b)
        }, multilinestring: function (a) {
            for (var b = [], c = null, d = 0, e = a.length; d < e; ++d) {
                try {
                    c = this.parseCoords.linestring.apply(this, [a[d]])
                } catch (f) {
                    throw f;
                }
                b.push(c)
            }
            return new GeoGlobe.Geometry.MultiLineString(b)
        },
        polygon: function (a) {
            for (var b = [], c, d, e = 0, f = a.length; e < f; ++e) {
                try {
                    d = this.parseCoords.linestring.apply(this, [a[e]])
                } catch (g) {
                    throw g;
                }
                c = new GeoGlobe.Geometry.LinearRing(d.components);
                b.push(c)
            }
            return new GeoGlobe.Geometry.Polygon(b)
        }, multipolygon: function (a) {
            for (var b = [], c = null, d = 0, e = a.length; d < e; ++d) {
                try {
                    c = this.parseCoords.polygon.apply(this, [a[d]])
                } catch (f) {
                    throw f;
                }
                b.push(c)
            }
            return new GeoGlobe.Geometry.MultiPolygon(b)
        }, box: function (a) {
            if (a.length != 2)throw"GeoJSON box coordinates must have 2 elements";
            return new GeoGlobe.Geometry.Polygon([new GeoGlobe.Geometry.LinearRing([new GeoGlobe.Geometry.Point(a[0][0], a[0][1]), new GeoGlobe.Geometry.Point(a[1][0], a[0][1]), new GeoGlobe.Geometry.Point(a[1][0], a[1][1]), new GeoGlobe.Geometry.Point(a[0][0], a[1][1]), new GeoGlobe.Geometry.Point(a[0][0], a[0][1])])])
        }
    }, write: function (a, b) {
        var c = {type: null};
        if (GeoGlobe.Util.isArray(a)) {
            c.type = "FeatureCollection";
            var d = a.length;
            c.features = Array(d);
            for (var e = 0; e < d; ++e) {
                var f = a[e];
                if (!f instanceof GeoGlobe.Feature)throw"FeatureCollection only supports collections of features: " +
                f;
                c.features[e] = this.extract.feature.apply(this, [f])
            }
        } else if (a.CLASS_NAME.indexOf("GeoGlobe.Geometry") == 0) c = this.extract.geometry.apply(this, [a]); else if (a instanceof GeoGlobe.Feature && (c = this.extract.feature.apply(this, [a]), a.layer && a.layer.projection)) c.crs = this.createCRSObject(a);
        return GeoGlobe.Format.JSON.prototype.write.apply(this, [c, b])
    }, createCRSObject: function (a) {
        var a = a.layer.projection.toString(), b = {};
        a.match(/epsg:/i) && (a = parseInt(a.substring(a.indexOf(":") + 1)), b = a == 4326 ? {
            type: "name",
            properties: {name: "urn:ogc:def:crs:OGC:1.3:CRS84"}
        } : {type: "name", properties: {name: "EPSG:" + a}});
        return b
    }, extract: {
        feature: function (a) {
            var b = this.extract.geometry.apply(this, [a.geometry]),
                b = {type: "Feature", properties: a.attributes, geometry: b};
            if (a.fid != null) b.id = a.fid;
            return b
        }, geometry: function (a) {
            if (a == null)return null;
            this.internalProjection && this.externalProjection && (a = a.clone(), a.transform(this.internalProjection, this.externalProjection));
            var b = a.CLASS_NAME.split(".")[2], a = this.extract[b.toLowerCase()].apply(this,
                [a]);
            return b == "Collection" ? {type: "GeometryCollection", geometries: a} : {type: b, coordinates: a}
        }, point: function (a) {
            return [a.x, a.y]
        }, multipoint: function (a) {
            for (var b = [], c = 0, d = a.components.length; c < d; ++c)b.push(this.extract.point.apply(this, [a.components[c]]));
            return b
        }, linestring: function (a) {
            for (var b = [], c = 0, d = a.components.length; c < d; ++c)b.push(this.extract.point.apply(this, [a.components[c]]));
            return b
        }, multilinestring: function (a) {
            for (var b = [], c = 0, d = a.components.length; c < d; ++c)b.push(this.extract.linestring.apply(this,
                [a.components[c]]));
            return b
        }, polygon: function (a) {
            for (var b = [], c = 0, d = a.components.length; c < d; ++c)b.push(this.extract.linestring.apply(this, [a.components[c]]));
            return b
        }, multipolygon: function (a) {
            for (var b = [], c = 0, d = a.components.length; c < d; ++c)b.push(this.extract.polygon.apply(this, [a.components[c]]));
            return b
        }, collection: function (a) {
            for (var b = a.components.length, c = Array(b), d = 0; d < b; ++d)c[d] = this.extract.geometry.apply(this, [a.components[d]]);
            return c
        }
    }, CLASS_NAME: "GeoGlobe.Format.GeoJSON"
});
GeoGlobe.Format.VTS = GeoGlobe.Class4OL({
    initialize: function (a) {
        GeoGlobe.Util.extend(this, a)
    }, getVTSCapabilities: function (a) {
        this.url = a;
        var b = null;
        this.getCapabilities(a, function (a) {
            var d = a.responseXML;
            if (!d || !d.documentElement) d = a.responseText;
            b = (new GeoGlobe.Format.VTSCapabilities.v1_0_0).read(d)
        }, function () {
            alert("VTS\u670d\u52a1\u8bf7\u6c42\u5931\u8d25\uff0c\u8bf7\u68c0\u67e5\u670d\u52a1\u662f\u5426\u6b63\u5e38\u8fd0\u884c\u6216\u8bf7\u6c42\u5730\u5740\u662f\u5426\u6b63\u786e\u3002\n\u8bf7\u6c42\u5730\u5740\uff1a" +
                a + "\n\u64cd\u4f5c\u7c7b\u578b\uff1aGetCapabilities")
        });
        return b
    }, getCapabilities: function (a, b, c) {
        typeof c != "function" && (c = function () {
            alert("VTS\u670d\u52a1\u8bf7\u6c42\u5931\u8d25\uff0c\u8bf7\u68c0\u67e5\u670d\u52a1\u662f\u5426\u6b63\u5e38\u8fd0\u884c\u6216\u8bf7\u6c42\u5730\u5740\u662f\u5426\u6b63\u786e\u3002\n\u8bf7\u6c42\u5730\u5740\uff1a" + a + "\n\u64cd\u4f5c\u7c7b\u578b\uff1aGetCapabilities")
        });
        GeoGlobe.Request.GET({
            url: a,
            params: {REQUEST: "GetCapabilities", SERVICE: "WMTS"},
            scope: this,
            async: !1,
            success: function (a) {
                typeof b ==
                "function" && b(a)
            },
            failure: c
        })
    }, createLayerOption: function (a, b, c) {
        if (!("layer" in c))throw Error("Missing property 'layer' in configuration.");
        for (var d = b.contents, e, f = 0, g = d.layers.length; f < g; ++f)if (d.layers[f].identifier === c.layer) {
            e = d.layers[f];
            break
        }
        if (!e)throw Error("Layer not found");
        f = c.format;
        !f && e.formats && e.formats.length && (f = e.formats[0]);
        var h;
        if (c.matrixSet) h = d.tileMatrixSets[c.matrixSet]; else if (c.projection)for (var f = 0, j = e.tileMatrixSetLinks.length; f < j; f++) {
            if (d.tileMatrixSets[e.tileMatrixSetLinks[f].tileMatrixSet].supportedCRS.replace(/urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/,
                    "$1:$3") === c.projection) {
                h = d.tileMatrixSets[e.tileMatrixSetLinks[f].tileMatrixSet];
                break
            }
        } else e.tileMatrixSetLinks.length >= 1 && (h = d.tileMatrixSets[e.tileMatrixSetLinks[0].tileMatrixSet]);
        if (!h)throw Error("matrixSet not found");
        var l = [];
        c.styleName && c.styleName != "" ? l[0] = c.styleName : this.GetStyleName(function (a) {
            l = a
        });
        (f = c.requestEncoding) || (f = "KVP");
        f = [];
        g = c.params || {};
        delete c.params;
        for (var j = 0, m = e.dimensions.length; j < m; j++) {
            var n = e.dimensions[j];
            f.push(n.identifier);
            g.hasOwnProperty(n.identifier) ||
            (g[n.identifier] = n["default"])
        }
        for (var p = c.projection || h.supportedCRS.replace(/urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, "$1:$3"), q = c.units || (p === "EPSG:4326" ? "degrees" : "m"), o = [], s, r, c = [], m = e.tileMatrixSetLinks, g = function (a) {
            o.push(a * 2.8E-4 / GeoGlobe.METERS_PER_INCH / GeoGlobe.INCHES_PER_UNIT[q]);
            if (!s || s > a) s = a;
            if (!r || r < a) r = a
        }, n = 0, j = m.length; n < j; n++)if (f = m[n], f.tileMatrixSet === h.identifier) {
            if (f.tileMatrixSetLimits) {
                for (var j = {}, n = 0, t = h.matrixIds.length; n < t; n++)j[h.matrixIds[n].identifier] = h.matrixIds[n];
                n =
                    0;
                for (t = f.tileMatrixSetLimits.length; n < t; n++)m = j[f.tileMatrixSetLimits[n].tileMatrix], c.push(m), g(m.scaleDenominator)
            } else {
                n = 0;
                for (t = h.matrixIds.length; n < t; n++)g(h.matrixIds[n].scaleDenominator)
            }
            break
        }
        o.sort(function (a, b) {
            return b - a
        });
        var u = "", v = {layers: [], source: {}, source_id: "", url: "", url_tmpl: "", layerType: "VTS"},
            b = this.getParameterString({
                SERVICE: "WMTS",
                REQUEST: "GetTile",
                VERSION: b.version,
                LAYER: e.identifier,
                TILEMATRIXSET: h.identifier,
                FORMAT: "protobuf",
                TILEMATRIX: "{z}",
                TILEROW: "{y}",
                TILECOL: "{x}"
            });
        v.url = a;
        u = a.endsWith("?") ? GeoGlobe.ProxyHost + a + b : GeoGlobe.ProxyHost + a + "?" + b;
        v.url_tmpl = u;
        GeoGlobe.Util.randomStr(10);
        if (e.bounds)var y = [e.bounds._sw.lng, e.bounds._sw.lat, e.bounds._ne.lng, e.bounds._ne.lat]; else e.BoundingBox && (y = e.BoundingBox[0].bounds.toBBOX());
        var z = d.tileMatrixSets[e.tileMatrixSetLinks[0].tileMatrixSet].matrixIds[0].identifier;
        this.GetStyle(l[0], function (a) {
            var b = {
                name: e.identifier,
                sprite: a.sprite ? GeoGlobe.ProxyHost + a.sprite : "",
                glyphs: a.glyphs ? GeoGlobe.ProxyHost + a.glyphs : "",
                styleName: a.styleName,
                srs: p,
                bbox: y,
                format: e.formats,
                zoomoffset: z
            }, c = "source_vts_" + GeoGlobe.Util.randomStr(6);
            v.source_id = c;
            v.source = {type: "vector", tiles: [u]};
            if (a.styleData)for (var d = 0; d < a.styleData.layers.length; d++)a.styleData.layers[d].metadata = b, a.styleData.layers[d].source = c, v.layers[d] = a.styleData.layers[d]; else for (d = 0; d < a.layers.length; d++)a.layers[d].metadata = b, a.layers[d].source = c, v.layers[d] = a.layers[d]
        }, function () {
            alert("WMTS\u670d\u52a1\u8bf7\u6c42\u5931\u8d25\uff0c\u8bf7\u68c0\u67e5\u670d\u52a1\u662f\u5426\u6b63\u5e38\u8fd0\u884c\u6216\u8bf7\u6c42\u5730\u5740\u662f\u5426\u6b63\u786e\u3002\n\u8bf7\u6c42\u5730\u5740\uff1a" +
                a + "\n\u64cd\u4f5c\u7c7b\u578b\uff1aGetCapabilities")
        });
        return v
    }, createLayer: function (a, b) {
        var c = this.getVTSCapabilities(a), b = b ? b : {};
        b.layer = b.layer ? b.layer : c.contents.layers[0].identifier;
        b.styleName = b.styleName ? b.styleName : "";
        return this.createLayerOption(a, c, b)
    }, createLayers: function (a) {
        for (var b = this.getVTSCapabilities(a), c = b.contents.layers, d = [], e = 0; e < c.length; e++) {
            var f = this.createLayerOption(a, b, {layer: c[e].identifier});
            d.push(f)
        }
        return d
    }, GetStyleName: function (a, b) {
        var c = this.url, d = {
            REQUEST: "GetStyle",
            SERVICE: "WMTS", VERSION: "1.0.0"
        };
        b || (b = function () {
            this.failFn(d.REQUEST)
        });
        GeoGlobe.Request.GET({
            url: c, params: d, scope: this, async: !1, success: function (c) {
                c = c.responseText;
                if (!c)return b(), !1;
                var c = (new GeoGlobe.Format.JSON).read(c), d = [];
                if (c.style)for (var g = 0; g < c.style.length; g++)d.push(c.style[g].styleName); else if (c.styleName)for (g = 0; g < c.styleName.length; g++)d.push(c.styleName[g]);
                a(d)
            }, failure: b
        })
    }, GetStyle: function (a, b, c) {
        var d = this.url;
        if (a == "" || a == void 0) alert("\u8bf7\u67e5\u770b\u6837\u5f0f\u540d\u79f0\u662f\u5426\u5b58\u5728");
        else {
            var e = {REQUEST: "GetStyle", SERVICE: "WMTS", VERSION: "1.0.0", STYLENAME: a};
            c || (c = function () {
                this.failFn(e.REQUEST)
            });
            GeoGlobe.Request.GET({
                url: d, params: e, scope: this, async: !1, success: function (a) {
                    a = a.responseText;
                    if (!a)return c(), !1;
                    a = (new GeoGlobe.Format.JSON).read(a);
                    b(a)
                }, failure: c
            })
        }
    }, getParameterString: function (a) {
        var b = [], c;
        for (c in a) {
            var d = a[c];
            d != null && typeof d != "function" && b.push(c + "=" + d)
        }
        return b.join("&")
    }, CLASS_NAME: "GeoGlobe.Format.VTS"
});
GeoGlobe.Format.WMTS = GeoGlobe.Class4OL({
    initialize: function (a) {
        GeoGlobe.Util.extend(this, a)
    }, getWMTSCapabilities: function (a) {
        var b = null;
        this.getCapabilities(a, function (a) {
            var d = a.responseXML;
            if (!d || !d.documentElement) d = a.responseText;
            b = (new GeoGlobe.Format.WMTSCapabilities.v1_0_0).read(d)
        }, function () {
            alert("WMTS\u670d\u52a1\u8bf7\u6c42\u5931\u8d25\uff0c\u8bf7\u68c0\u67e5\u670d\u52a1\u662f\u5426\u6b63\u5e38\u8fd0\u884c\u6216\u8bf7\u6c42\u5730\u5740\u662f\u5426\u6b63\u786e\u3002\n\u8bf7\u6c42\u5730\u5740\uff1a" +
                a + "\n\u64cd\u4f5c\u7c7b\u578b\uff1aGetCapabilities")
        });
        return b
    }, getCapabilities: function (a, b, c) {
        typeof c != "function" && (c = function () {
            alert("WMTS\u670d\u52a1\u8bf7\u6c42\u5931\u8d25\uff0c\u8bf7\u68c0\u67e5\u670d\u52a1\u662f\u5426\u6b63\u5e38\u8fd0\u884c\u6216\u8bf7\u6c42\u5730\u5740\u662f\u5426\u6b63\u786e\u3002\n\u8bf7\u6c42\u5730\u5740\uff1a" + a + "\n\u64cd\u4f5c\u7c7b\u578b\uff1aGetCapabilities")
        });
        GeoGlobe.Request.GET({
            url: a,
            params: {REQUEST: "GetCapabilities", SERVICE: "WMTS"},
            scope: this,
            async: !1,
            success: function (a) {
                typeof b ==
                "function" && b(a)
            },
            failure: c
        })
    }, createLayerOption: function (a, b, c) {
        if (!("layer" in c))throw Error("Missing property 'layer' in configuration.");
        for (var d = b.contents, e, f = 0, g = d.layers.length; f < g; ++f)if (d.layers[f].identifier === c.layer) {
            e = d.layers[f];
            break
        }
        if (!e)throw Error("Layer not found");
        var h = c.format;
        if (!h && e.formats && e.formats.length) {
            for (f = 0; f < e.formats.length; f++)if (e.formats[f] == "image/png") {
                h = e.formats[f];
                break
            }
            h = h ? h : e.formats[0]
        }
        var j;
        if (c.matrixSet) j = d.tileMatrixSets[c.matrixSet]; else if (c.projection)for (var f =
            0, l = e.tileMatrixSetLinks.length; f < l; f++) {
            if (d.tileMatrixSets[e.tileMatrixSetLinks[f].tileMatrixSet].supportedCRS.replace(/urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, "$1:$3") === c.projection) {
                j = d.tileMatrixSets[e.tileMatrixSetLinks[f].tileMatrixSet];
                break
            }
        } else e.tileMatrixSetLinks.length >= 1 && (j = d.tileMatrixSets[e.tileMatrixSetLinks[0].tileMatrixSet]);
        if (!j)throw Error("matrixSet not found");
        for (var m, f = 0, g = e.styles.length; f < g; ++f)if (m = e.styles[f], m.isDefault)break;
        (f = c.requestEncoding) || (f = "KVP");
        f = [];
        g =
            c.params || {};
        delete c.params;
        for (var n = 0, l = e.dimensions.length; n < l; n++) {
            var p = e.dimensions[n];
            f.push(p.identifier);
            g.hasOwnProperty(p.identifier) || (g[p.identifier] = p["default"])
        }
        for (var f = c.projection || j.supportedCRS.replace(/urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, "$1:$3"), q = c.units || (f === "EPSG:4326" ? "degrees" : "m"), o = [], s, r, c = [], p = e.tileMatrixSetLinks, n = function (a) {
            o.push(a * 2.8E-4 / GeoGlobe.METERS_PER_INCH / GeoGlobe.INCHES_PER_UNIT[q]);
            if (!s || s > a) s = a;
            if (!r || r < a) r = a
        }, t = 0, l = p.length; t < l; t++)if (g = p[t], g.tileMatrixSet ===
            j.identifier) {
            if (g.tileMatrixSetLimits) {
                for (var l = {}, t = 0, u = j.matrixIds.length; t < u; t++)l[j.matrixIds[t].identifier] = j.matrixIds[t];
                t = 0;
                for (u = g.tileMatrixSetLimits.length; t < u; t++)p = l[g.tileMatrixSetLimits[t].tileMatrix], c.push(p), n(p.scaleDenominator)
            } else {
                t = 0;
                for (u = j.matrixIds.length; t < u; t++)n(j.matrixIds[t].scaleDenominator)
            }
            break
        }
        o.sort(function (a, b) {
            return b - a
        });
        c = "";
        b = this.getParameterString({
            SERVICE: "WMTS",
            REQUEST: "GetTile",
            VERSION: b.version,
            LAYER: e.identifier,
            STYLE: m.identifier,
            TILEMATRIXSET: j.identifier,
            FORMAT: h,
            TILEMATRIX: "{z}",
            TILEROW: "{y}",
            TILECOL: "{x}"
        });
        c = a.endsWith("?") ? GeoGlobe.ProxyHost + a + b : GeoGlobe.ProxyHost + a + "?" + b;
        a = GeoGlobe.Util.randomStr(10);
        if (e.bounds)var v = [e.bounds._sw.lng, e.bounds._sw.lat, e.bounds._ne.lng, e.bounds._ne.lat]; else e.BoundingBox && (v = e.BoundingBox[0].bounds.toBBOX());
        return {
            id: "layer_" + e.identifier + "_" + a,
            type: "raster",
            source: {type: "raster", tiles: [c], tileSize: 256},
            metadata: {
                name: e.identifier,
                srs: f,
                bbox: v,
                format: e.formats,
                zoomoffset: d.tileMatrixSets[e.tileMatrixSetLinks[0].tileMatrixSet].matrixIds[0].identifier
            },
            paint: {"raster-opacity": 1}
        }
    }, createLayer: function (a, b) {
        var c = this.getWMTSCapabilities(a), b = b ? b : {};
        b.layer = b.layer ? b.layer : c.contents.layers[0].identifier;
        return this.createLayerOption(a, c, b)
    }, createLayers: function (a) {
        for (var b = this.getWMTSCapabilities(a), c = b.contents.layers, d = [], e = 0; e < c.length; e++) {
            var f = this.createLayerOption(a, b, {layer: c[e].identifier});
            d.push(f)
        }
        return d
    }, getParameterString: function (a) {
        var b = [], c;
        for (c in a) {
            var d = a[c];
            d != null && typeof d != "function" && b.push(c + "=" + d)
        }
        return b.join("&")
    },
    CLASS_NAME: "GeoGlobe.Format.WMTS"
});
GeoGlobe.Format.WMS = GeoGlobe.Class4OL({
    initialize: function (a) {
        GeoGlobe.Util.extend(this, a)
    }, getWMSCapabilities: function (a) {
        var b = null;
        this.getCapabilities(a, function (a) {
            var d = a.responseXML;
            if (!d || !d.documentElement) d = a.responseText;
            b = (new GeoGlobe.Format.WMSCapabilities.v1_1_1).read(d)
        }, function () {
            alert("WMS\u670d\u52a1\u8bf7\u6c42\u5931\u8d25\uff0c\u8bf7\u68c0\u67e5\u670d\u52a1\u662f\u5426\u6b63\u5e38\u8fd0\u884c\u6216\u8bf7\u6c42\u5730\u5740\u662f\u5426\u6b63\u786e\u3002\n\u8bf7\u6c42\u5730\u5740\uff1a" + a +
                "\n\u64cd\u4f5c\u7c7b\u578b\uff1aGetCapabilities")
        });
        return b
    }, getCapabilities: function (a, b, c) {
        typeof c != "function" && (c = function () {
            alert("WMS\u670d\u52a1\u8bf7\u6c42\u5931\u8d25\uff0c\u8bf7\u68c0\u67e5\u670d\u52a1\u662f\u5426\u6b63\u5e38\u8fd0\u884c\u6216\u8bf7\u6c42\u5730\u5740\u662f\u5426\u6b63\u786e\u3002\n\u8bf7\u6c42\u5730\u5740\uff1a" + a + "\n\u64cd\u4f5c\u7c7b\u578b\uff1aGetCapabilities")
        });
        GeoGlobe.Request.GET({
            url: a, params: {REQUEST: "GetCapabilities", SERVICE: "WMS", VERSION: "1.1.1"}, scope: this,
            async: !1, success: function (a) {
                typeof b == "function" && b(a)
            }, failure: c
        })
    }, createLayerOption: function (a, b, c) {
        if (!("layer" in c))throw Error("Missing property 'layer' in configuration.");
        for (var b = b.capability, d, e = 0, f = b.layers.length; e < f; ++e)if (b.layers[e].name === c.layer) {
            d = b.layers[e];
            break
        }
        if (!d)throw Error("Layer not found");
        b = c.format;
        if (!b && d.formats && d.formats.length) {
            for (e = 0; e < d.formats.length; e++)d.formats[e] == "image/png" && (b = d.formats[e]);
            b != "image/png" && (b = d.formats[0])
        }
        e = c.styles;
        if (!e && d.styles &&
            d.styles.length) e = d.styles[0].name;
        var f = eval(d.srs), g, h;
        for (h in f)g = h;
        h = "";
        c.isTile ? (c = this.getParameterString({
            SERVICE: "WMS",
            REQUEST: "GetMap",
            VERSION: "1.1.1",
            LAYERS: d.name,
            styles: e,
            FORMAT: b,
            TRANSPARENT: !0,
            BBOX: "{bbox-epsg-3857}",
            WIDTH: "256",
            HEIGHT: "256",
            SRS: g
        }), h = a.endsWith("?") ? a + c : a + "?" + c, h = GeoGlobe.appendToProxy(h), a = GeoGlobe.Util.randomStr(10), d = {
            id: "layer_" + d.name + "_" + a,
            type: "raster",
            source: {type: "raster", tiles: [h], tileSize: 256},
            metadata: {name: d.name, srs: g, bbox: d.bbox, format: b},
            paint: {"raster-opacity": 1}
        }) :
            d = new GeoGlobe.Layer.WMS({
                url: a,
                layer: d.name,
                format: b,
                version: "1.1.1",
                SRS: g,
                styles: e,
                bbox: d.bbox,
                isTile: !1
            });
        return d
    }, createLayer: function (a, b, c) {
        this.url = a;
        var c = c === void 0 || c ? !0 : !1, d = this.getWMSCapabilities(a);
        return this.createLayerOption(a, d, {layer: b && b.layer ? b.layer : d.capability.layers[0].name, isTile: c})
    }, createLayers: function (a, b) {
        if (b === void 0 || b) {
            for (var c = this.getWMSCapabilities(a), d = c.capability.layers, e = [], f = 0; f < d.length; f++) {
                var g = this.createLayerOption(a, c, {layer: d[f].name});
                e.push(g)
            }
            return e
        }
    },
    getParameterString: function (a) {
        var b = [], c;
        for (c in a) {
            var d = a[c];
            d != null && typeof d != "function" && b.push(c + "=" + d)
        }
        return b.join("&")
    }, CLASS_NAME: "GeoGlobe.Format.WMS"
});
GeoGlobe.Format.WMSCapabilities = GeoGlobe.Class4OL(GeoGlobe.Format.XML.VersionedOGC, {
    defaultVersion: "1.1.1",
    profile: null,
    CLASS_NAME: "GeoGlobe.Format.WMSCapabilities"
});
GeoGlobe.Format.WMSCapabilities.v1 = GeoGlobe.Class4OL(GeoGlobe.Format.XML, {
    namespaces: {
        wms: "http://www.opengis.net/wms",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance"
    }, defaultPrefix: "wms", read: function (a) {
        typeof a == "string" && (a = GeoGlobe.Format.XML.prototype.read.apply(this, [a]));
        var b = a;
        if (a && a.nodeType == 9) a = a.documentElement;
        var c = {};
        this.readNode(a, c);
        if (c.service === void 0) a = new GeoGlobe.Format.OGCExceptionReport, c.error = a.read(b);
        return c
    }, readers: {
        wms: {
            Service: function (a,
                               b) {
                b.service = {};
                this.readChildNodes(a, b.service)
            }, Name: function (a, b) {
                b.name = this.getChildValue(a)
            }, Title: function (a, b) {
                b.title = this.getChildValue(a)
            }, Abstract: function (a, b) {
                b["abstract"] = this.getChildValue(a)
            }, BoundingBox: function (a) {
                var b = {};
                b.bbox = [parseFloat(a.getAttribute("minx")), parseFloat(a.getAttribute("miny")), parseFloat(a.getAttribute("maxx")), parseFloat(a.getAttribute("maxy"))];
                a = {x: parseFloat(a.getAttribute("resx")), y: parseFloat(a.getAttribute("resy"))};
                if (!isNaN(a.x) || !isNaN(a.y)) b.res =
                    a;
                return b
            }, OnlineResource: function (a, b) {
                b.href = this.getAttributeNS(a, this.namespaces.xlink, "href")
            }, ContactInformation: function (a, b) {
                b.contactInformation = {};
                this.readChildNodes(a, b.contactInformation)
            }, ContactPersonPrimary: function (a, b) {
                b.personPrimary = {};
                this.readChildNodes(a, b.personPrimary)
            }, ContactPerson: function (a, b) {
                b.person = this.getChildValue(a)
            }, ContactOrganization: function (a, b) {
                b.organization = this.getChildValue(a)
            }, ContactPosition: function (a, b) {
                b.position = this.getChildValue(a)
            }, ContactAddress: function (a,
                                         b) {
                b.contactAddress = {};
                this.readChildNodes(a, b.contactAddress)
            }, AddressType: function (a, b) {
                b.type = this.getChildValue(a)
            }, Address: function (a, b) {
                b.address = this.getChildValue(a)
            }, City: function (a, b) {
                b.city = this.getChildValue(a)
            }, StateOrProvince: function (a, b) {
                b.stateOrProvince = this.getChildValue(a)
            }, PostCode: function (a, b) {
                b.postcode = this.getChildValue(a)
            }, Country: function (a, b) {
                b.country = this.getChildValue(a)
            }, ContactVoiceTelephone: function (a, b) {
                b.phone = this.getChildValue(a)
            }, ContactFacsimileTelephone: function (a,
                                                    b) {
                b.fax = this.getChildValue(a)
            }, ContactElectronicMailAddress: function (a, b) {
                b.email = this.getChildValue(a)
            }, Fees: function (a, b) {
                var c = this.getChildValue(a);
                if (c && c.toLowerCase() != "none") b.fees = c
            }, AccessConstraints: function (a, b) {
                var c = this.getChildValue(a);
                if (c && c.toLowerCase() != "none") b.accessConstraints = c
            }, Capability: function (a, b) {
                b.capability = {nestedLayers: [], layers: []};
                this.readChildNodes(a, b.capability)
            }, Request: function (a, b) {
                b.request = {};
                this.readChildNodes(a, b.request)
            }, GetCapabilities: function (a,
                                          b) {
                b.getcapabilities = {formats: []};
                this.readChildNodes(a, b.getcapabilities)
            }, Format: function (a, b) {
                GeoGlobe.Util.isArray(b.formats) ? b.formats.push(this.getChildValue(a)) : b.format = this.getChildValue(a)
            }, DCPType: function (a, b) {
                this.readChildNodes(a, b)
            }, HTTP: function (a, b) {
                this.readChildNodes(a, b)
            }, Get: function (a, b) {
                b.get = {};
                this.readChildNodes(a, b.get);
                if (!b.href) b.href = b.get.href
            }, Post: function (a, b) {
                b.post = {};
                this.readChildNodes(a, b.post);
                if (!b.href) b.href = b.get.href
            }, GetMap: function (a, b) {
                b.getmap = {formats: []};
                this.readChildNodes(a, b.getmap)
            }, GetFeatureInfo: function (a, b) {
                b.getfeatureinfo = {formats: []};
                this.readChildNodes(a, b.getfeatureinfo)
            }, Exception: function (a, b) {
                b.exception = {formats: []};
                this.readChildNodes(a, b.exception)
            }, Layer: function (a, b) {
                var c, d;
                b.capability ? (d = b.capability, c = b) : d = b;
                var e = a.getAttributeNode("queryable"), f = e && e.specified ? a.getAttribute("queryable") : null,
                    g = (e = a.getAttributeNode("cascaded")) && e.specified ? a.getAttribute("cascaded") : null,
                    e = (e = a.getAttributeNode("opaque")) && e.specified ?
                        a.getAttribute("opaque") : null, h = a.getAttribute("noSubsets"),
                    j = a.getAttribute("fixedWidth"), l = a.getAttribute("fixedHeight"), m = c || {},
                    n = GeoGlobe.Util.extend;
                c = {
                    nestedLayers: [],
                    styles: c ? [].concat(c.styles) : [],
                    srs: c ? n({}, m.srs) : {},
                    metadataURLs: [],
                    bbox: c ? n({}, m.bbox) : {},
                    llbbox: m.llbbox,
                    dimensions: c ? n({}, m.dimensions) : {},
                    authorityURLs: c ? n({}, m.authorityURLs) : {},
                    identifiers: {},
                    keywords: [],
                    queryable: f && f !== "" ? f === "1" || f === "true" : m.queryable || !1,
                    cascaded: g !== null ? parseInt(g) : m.cascaded || 0,
                    opaque: e ? e === "1" ||
                        e === "true" : m.opaque || !1,
                    noSubsets: h !== null ? h === "1" || h === "true" : m.noSubsets || !1,
                    fixedWidth: j != null ? parseInt(j) : m.fixedWidth || 0,
                    fixedHeight: l != null ? parseInt(l) : m.fixedHeight || 0,
                    minScale: m.minScale,
                    maxScale: m.maxScale,
                    attribution: m.attribution
                };
                b.nestedLayers.push(c);
                c.capability = d;
                this.readChildNodes(a, c);
                delete c.capability;
                if (c.name) {
                    f = c.name.split(":");
                    g = d.request;
                    e = g.getfeatureinfo;
                    if (f.length > 0) c.prefix = f[0];
                    d.layers.push(c);
                    if (c.formats === void 0) c.formats = g.getmap.formats;
                    if (c.infoFormats === void 0 &&
                        e) c.infoFormats = e.formats
                }
            }, Attribution: function (a, b) {
                b.attribution = {};
                this.readChildNodes(a, b.attribution)
            }, LogoURL: function (a, b) {
                b.logo = {width: a.getAttribute("width"), height: a.getAttribute("height")};
                this.readChildNodes(a, b.logo)
            }, Style: function (a, b) {
                var c = {};
                b.styles.push(c);
                this.readChildNodes(a, c)
            }, LegendURL: function (a, b) {
                var c = {width: a.getAttribute("width"), height: a.getAttribute("height")};
                b.legend = c;
                this.readChildNodes(a, c)
            }, MetadataURL: function (a, b) {
                var c = {type: a.getAttribute("type")};
                b.metadataURLs.push(c);
                this.readChildNodes(a, c)
            }, DataURL: function (a, b) {
                b.dataURL = {};
                this.readChildNodes(a, b.dataURL)
            }, FeatureListURL: function (a, b) {
                b.featureListURL = {};
                this.readChildNodes(a, b.featureListURL)
            }, AuthorityURL: function (a, b) {
                var c = a.getAttribute("name"), d = {};
                this.readChildNodes(a, d);
                b.authorityURLs[c] = d.href
            }, Identifier: function (a, b) {
                var c = a.getAttribute("authority");
                b.identifiers[c] = this.getChildValue(a)
            }, KeywordList: function (a, b) {
                this.readChildNodes(a, b)
            }, SRS: function (a, b) {
                b.srs[this.getChildValue(a)] = !0
            }
        }
    },
    CLASS_NAME: "GeoGlobe.Format.WMSCapabilities.v1"
});
GeoGlobe.Format.WMSCapabilities.v1_1 = GeoGlobe.Class4OL(GeoGlobe.Format.WMSCapabilities.v1, {
    readers: {
        wms: GeoGlobe.Util.applyDefaults({
                WMT_MS_Capabilities: function (a, b) {
                    this.readChildNodes(a, b)
                }, Keyword: function (a, b) {
                    b.keywords && b.keywords.push(this.getChildValue(a))
                }, DescribeLayer: function (a, b) {
                    b.describelayer = {formats: []};
                    this.readChildNodes(a, b.describelayer)
                }, GetLegendGraphic: function (a, b) {
                    b.getlegendgraphic = {formats: []};
                    this.readChildNodes(a, b.getlegendgraphic)
                }, GetStyles: function (a, b) {
                    b.getstyles =
                        {formats: []};
                    this.readChildNodes(a, b.getstyles)
                }, PutStyles: function (a, b) {
                    b.putstyles = {formats: []};
                    this.readChildNodes(a, b.putstyles)
                }, UserDefinedSymbolization: function (a, b) {
                    var c = {
                        supportSLD: parseInt(a.getAttribute("SupportSLD")) == 1,
                        userLayer: parseInt(a.getAttribute("UserLayer")) == 1,
                        userStyle: parseInt(a.getAttribute("UserStyle")) == 1,
                        remoteWFS: parseInt(a.getAttribute("RemoteWFS")) == 1
                    };
                    b.userSymbols = c
                }, LatLonBoundingBox: function (a, b) {
                    b.llbbox = [parseFloat(a.getAttribute("minx")), parseFloat(a.getAttribute("miny")),
                        parseFloat(a.getAttribute("maxx")), parseFloat(a.getAttribute("maxy"))]
                }, BoundingBox: function (a, b) {
                    var c = GeoGlobe.Format.WMSCapabilities.v1.prototype.readers.wms.BoundingBox.apply(this, [a, b]);
                    c.srs = a.getAttribute("SRS");
                    b.bbox[c.srs] = c
                }, ScaleHint: function (a, b) {
                    var c = a.getAttribute("min"), d = a.getAttribute("max"), e = Math.pow(2, 0.5),
                        f = GeoGlobe.INCHES_PER_UNIT.m;
                    if (c != 0) b.maxScale = parseFloat((c / e * f * GeoGlobe.DOTS_PER_INCH).toPrecision(13));
                    if (d != Number.POSITIVE_INFINITY) b.minScale = parseFloat((d / e * f * GeoGlobe.DOTS_PER_INCH).toPrecision(13))
                },
                Dimension: function (a, b) {
                    var c = {
                        name: a.getAttribute("name").toLowerCase(),
                        units: a.getAttribute("units"),
                        unitsymbol: a.getAttribute("unitSymbol")
                    };
                    b.dimensions[c.name] = c
                }, Extent: function (a, b) {
                    var c = a.getAttribute("name").toLowerCase();
                    if (c in b.dimensions) {
                        c = b.dimensions[c];
                        c.nearestVal = a.getAttribute("nearestValue") === "1";
                        c.multipleVal = a.getAttribute("multipleValues") === "1";
                        c.current = a.getAttribute("current") === "1";
                        c["default"] = a.getAttribute("default") || "";
                        var d = this.getChildValue(a);
                        c.values = d.split(",")
                    }
                }
            },
            GeoGlobe.Format.WMSCapabilities.v1.prototype.readers.wms)
    }, CLASS_NAME: "GeoGlobe.Format.WMSCapabilities.v1_1"
});
GeoGlobe.Format.WMSCapabilities.v1_1_0 = GeoGlobe.Class4OL(GeoGlobe.Format.WMSCapabilities.v1_1, {
    version: "1.1.0",
    readers: {
        wms: GeoGlobe.Util.applyDefaults({
            SRS: function (a, b) {
                for (var c = this.getChildValue(a).split(/ +/), d = 0, e = c.length; d < e; d++)b.srs[c[d]] = !0
            }
        }, GeoGlobe.Format.WMSCapabilities.v1_1.prototype.readers.wms)
    },
    CLASS_NAME: "GeoGlobe.Format.WMSCapabilities.v1_1_0"
});
GeoGlobe.Format.WMSCapabilities.v1_1_1 = GeoGlobe.Class4OL(GeoGlobe.Format.WMSCapabilities.v1_1, {
    version: "1.1.1",
    readers: {
        wms: GeoGlobe.Util.applyDefaults({
            SRS: function (a, b) {
                b.srs[this.getChildValue(a)] = !0
            }
        }, GeoGlobe.Format.WMSCapabilities.v1_1.prototype.readers.wms)
    },
    CLASS_NAME: "GeoGlobe.Format.WMSCapabilities.v1_1_1"
});
GeoGlobe.Format.WMSCapabilities.v1_1_1_WMSC = GeoGlobe.Class4OL(GeoGlobe.Format.WMSCapabilities.v1_1_1, {
    version: "1.1.1", profile: "WMSC", readers: {
        wms: GeoGlobe.Util.applyDefaults({
            VendorSpecificCapabilities: function (a, b) {
                b.vendorSpecific = {tileSets: []};
                this.readChildNodes(a, b.vendorSpecific)
            }, TileSet: function (a, b) {
                var c = {srs: {}, bbox: {}, resolutions: []};
                this.readChildNodes(a, c);
                b.tileSets.push(c)
            }, Resolutions: function (a, b) {
                for (var c = this.getChildValue(a).split(" "), d = 0, e = c.length; d < e; d++)c[d] != "" && b.resolutions.push(parseFloat(c[d]))
            },
            Width: function (a, b) {
                b.width = parseInt(this.getChildValue(a))
            }, Height: function (a, b) {
                b.height = parseInt(this.getChildValue(a))
            }, Layers: function (a, b) {
                b.layers = this.getChildValue(a)
            }, Styles: function (a, b) {
                b.styles = this.getChildValue(a)
            }
        }, GeoGlobe.Format.WMSCapabilities.v1_1_1.prototype.readers.wms)
    }, CLASS_NAME: "GeoGlobe.Format.WMSCapabilities.v1_1_1_WMSC"
});
GeoGlobe.Format.WMSCapabilities.v1_3 = GeoGlobe.Class4OL(GeoGlobe.Format.WMSCapabilities.v1, {
    readers: {
        wms: GeoGlobe.Util.applyDefaults({
            WMS_Capabilities: function (a, b) {
                this.readChildNodes(a, b)
            }, LayerLimit: function (a, b) {
                b.layerLimit = parseInt(this.getChildValue(a))
            }, MaxWidth: function (a, b) {
                b.maxWidth = parseInt(this.getChildValue(a))
            }, MaxHeight: function (a, b) {
                b.maxHeight = parseInt(this.getChildValue(a))
            }, BoundingBox: function (a, b) {
                var c = GeoGlobe.Format.WMSCapabilities.v1.prototype.readers.wms.BoundingBox.apply(this,
                    [a, b]);
                c.srs = a.getAttribute("CRS");
                b.bbox[c.srs] = c
            }, CRS: function (a, b) {
                this.readers.wms.SRS.apply(this, [a, b])
            }, EX_GeographicBoundingBox: function (a, b) {
                b.llbbox = [];
                this.readChildNodes(a, b.llbbox)
            }, westBoundLongitude: function (a, b) {
                b[0] = this.getChildValue(a)
            }, eastBoundLongitude: function (a, b) {
                b[2] = this.getChildValue(a)
            }, southBoundLatitude: function (a, b) {
                b[1] = this.getChildValue(a)
            }, northBoundLatitude: function (a, b) {
                b[3] = this.getChildValue(a)
            }, MinScaleDenominator: function (a, b) {
                b.maxScale = parseFloat(this.getChildValue(a)).toPrecision(16)
            },
            MaxScaleDenominator: function (a, b) {
                b.minScale = parseFloat(this.getChildValue(a)).toPrecision(16)
            }, Dimension: function (a, b) {
                var c = {
                    name: a.getAttribute("name").toLowerCase(),
                    units: a.getAttribute("units"),
                    unitsymbol: a.getAttribute("unitSymbol"),
                    nearestVal: a.getAttribute("nearestValue") === "1",
                    multipleVal: a.getAttribute("multipleValues") === "1",
                    "default": a.getAttribute("default") || "",
                    current: a.getAttribute("current") === "1",
                    values: this.getChildValue(a).split(",")
                };
                b.dimensions[c.name] = c
            }, Keyword: function (a,
                                  b) {
                var c = {value: this.getChildValue(a), vocabulary: a.getAttribute("vocabulary")};
                b.keywords && b.keywords.push(c)
            }
        }, GeoGlobe.Format.WMSCapabilities.v1.prototype.readers.wms), sld: {
            UserDefinedSymbolization: function (a, b) {
                this.readers.wms.UserDefinedSymbolization.apply(this, [a, b]);
                b.userSymbols.inlineFeature = parseInt(a.getAttribute("InlineFeature")) == 1;
                b.userSymbols.remoteWCS = parseInt(a.getAttribute("RemoteWCS")) == 1
            }, DescribeLayer: function (a, b) {
                this.readers.wms.DescribeLayer.apply(this, [a, b])
            }, GetLegendGraphic: function (a,
                                           b) {
                this.readers.wms.GetLegendGraphic.apply(this, [a, b])
            }
        }
    }, CLASS_NAME: "GeoGlobe.Format.WMSCapabilities.v1_3"
});
GeoGlobe.Format.WMSCapabilities.v1_3_0 = GeoGlobe.Class4OL(GeoGlobe.Format.WMSCapabilities.v1_3, {
    version: "1.3.0",
    CLASS_NAME: "GeoGlobe.Format.WMSCapabilities.v1_3_0"
});
GeoGlobe.Format.WMSUtil = GeoGlobe.Class4OL({
    initialize: function (a) {
        GeoGlobe.Util.extend(this, a)
    }, getWMSCapabilities: function (a, b) {
        var c = !0, d = null;
        this.getCapabilities(a, b, GeoGlobe.Function.bind(function (b) {
            var f = b.responseXML;
            if (!f || !f.documentElement) f = b.responseText;
            f == null || f == "" ? (this.failFn(a), c = !1) : d = (new GeoGlobe.Format.WMSCapabilities).read(f)
        }, this), function () {
            alert("WMS\u670d\u52a1\u8bf7\u6c42\u5931\u8d25\uff0c\u8bf7\u68c0\u67e5\u670d\u52a1\u662f\u5426\u6b63\u5e38\u8fd0\u884c\u6216\u8bf7\u6c42\u5730\u5740\u662f\u5426\u6b63\u786e\u3002\n\u8bf7\u6c42\u5730\u5740\uff1a" +
                a + "\n\u64cd\u4f5c\u7c7b\u578b\uff1aGetCapabilities")
        });
        if (c)return d
    }, createLayer: function (a, b) {
        var c = !0, d = null;
        this.getCapabilities(a, b, GeoGlobe.Function.bind(function (e) {
            var f = e.responseXML;
            if (!f || !f.documentElement) f = e.responseText;
            f == null || f == "" ? (this.failFn(a), c = !1) : (e = (new GeoGlobe.Format.WMSCapabilities).read(f), d = this._createLayer(a, e, b, "2D"))
        }, this), function () {
            alert("WMS\u670d\u52a1\u8bf7\u6c42\u5931\u8d25\uff0c\u8bf7\u68c0\u67e5\u670d\u52a1\u662f\u5426\u6b63\u5e38\u8fd0\u884c\u6216\u8bf7\u6c42\u5730\u5740\u662f\u5426\u6b63\u786e\u3002\n\u8bf7\u6c42\u5730\u5740\uff1a" +
                a + "\n\u64cd\u4f5c\u7c7b\u578b\uff1aGetCapabilities")
        });
        if (c)return d
    }, failFn: function (a) {
        alert("WMS\u670d\u52a1\u8bf7\u6c42\u5931\u8d25\uff0c\u8bf7\u68c0\u67e5\u670d\u52a1\u662f\u5426\u6b63\u5e38\u8fd0\u884c\u6216\u8bf7\u6c42\u5730\u5740\u662f\u5426\u6b63\u786e\u3002\n\u8bf7\u6c42\u5730\u5740\uff1a" + a + "\n\u64cd\u4f5c\u7c7b\u578b\uff1aGetCapabilities")
    }, getCapabilities: function (a, b, c, d) {
        var e = {REQUEST: "GetCapabilities", SERVICE: "WMS", VERSION: b && b.version ? b.version : "1.1.1"};
        typeof d != "function" && (d =
            function () {
                alert("WMS\u670d\u52a1\u8bf7\u6c42\u5931\u8d25\uff0c\u8bf7\u68c0\u67e5\u670d\u52a1\u662f\u5426\u6b63\u5e38\u8fd0\u884c\u6216\u8bf7\u6c42\u5730\u5740\u662f\u5426\u6b63\u786e\u3002\n\u8bf7\u6c42\u5730\u5740\uff1a" + a + "\n\u7248\u672c\u53f7\uff1a" + e[VERSION] + "\n\u64cd\u4f5c\u7c7b\u578b\uff1aGetCapabilities")
            });
        GeoGlobe.Request.GET({
            url: a, params: e, scope: this, async: !1, success: function (a) {
                typeof c == "function" && c(a)
            }, failure: d
        })
    }, _createLayer: function (a, b, c) {
        c || (c = {});
        var d = b.capability, e;
        e = d.layers[0];
        for (var f = 0, g = d.layers.length; f < g; ++f)if (d.layers[f].name === c.layer) {
            e = d.layers[f];
            break
        }
        if (!e)throw Error("Layer not found");
        d = c.format;
        !d && e.formats && e.formats.length > 0 && (d = e.formats[0]);
        f = c.transparent;
        if (!f || f == "") f = !0;
        var h;
        if (e.name) h = e.name;
        g = c.version;
        if (!g && b.version) g = b.version;
        b = c.srs;
        if (!b && e.srs)for (var j in e.srs)b = j;
        b == "EPSG:-9999" && (b = "EPSG:4326");
        e = GeoGlobe.LngLatBounds.fromArray(e.llbbox);
        j = "SERVICE=WMS&REQUEST=GetMap&VERSION=" + g + "&LAYERS=" + h + "&styles=default&CRS=EPSG:3857&BBOX={bbox-epsg-3857}&WIDTH=256&HEIGHT=256&SRS=" +
            b + "&FORMAT=" + d + "&TRANSPARENT=" + f;
        wmts_url = a.endsWith("?") ? a + j : a + "?" + j;
        return {url: wmts_url, version: g, name: h, projection: b, format: d, bounds: e, transparent: f}
    }, CLASS_NAME: "GeoGlobe.Format.WMSUtil"
});
GeoGlobe.Format.VTSCapabilities = GeoGlobe.Class4OL(GeoGlobe.Format.XML.VersionedOGC, {
    defaultVersion: "1.0.0", yx: {"urn:ogc:def:crs:EPSG::4326": !0}, createLayer: function (a, b) {
        if (!("layer" in b))throw Error("Missing property 'layer' in configuration.");
        for (var c = a.contents, d, e = 0, f = c.layers.length; e < f; ++e)if (c.layers[e].identifier === b.layer) {
            d = c.layers[e];
            break
        }
        if (!d)throw Error("Layer not found");
        var g = b.format;
        !g && d.formats && d.formats.length && (g = d.formats[0]);
        var h;
        if (b.matrixSet) h = c.tileMatrixSets[b.matrixSet];
        else if (b.projection)for (var e = 0, j = d.tileMatrixSetLinks.length; e < j; e++) {
            if (c.tileMatrixSets[d.tileMatrixSetLinks[e].tileMatrixSet].supportedCRS.replace(/urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, "$1:$3") === b.projection) {
                h = c.tileMatrixSets[d.tileMatrixSetLinks[e].tileMatrixSet];
                break
            }
        } else d.tileMatrixSetLinks.length >= 1 && (h = c.tileMatrixSets[d.tileMatrixSetLinks[0].tileMatrixSet]);
        if (!h)throw Error("matrixSet not found");
        for (var l, e = 0, f = d.styles.length; e < f; ++e)if (l = d.styles[e], l.isDefault)break;
        (c = b.requestEncoding) ||
        (c = "KVP");
        var m = [], e = b.params || {};
        delete b.params;
        f = 0;
        for (j = d.dimensions.length; f < j; f++) {
            var n = d.dimensions[f];
            m.push(n.identifier);
            e.hasOwnProperty(n.identifier) || (e[n.identifier] = n["default"])
        }
        for (var m = b.projection || h.supportedCRS.replace(/urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, "$1:$3"), p = b.units || (m === "EPSG:4326" ? "degrees" : "m"), q = [], o, s, m = [], n = d.tileMatrixSetLinks, f = function (a) {
            q.push(a * 2.8E-4 / GeoGlobe.METERS_PER_INCH / GeoGlobe.INCHES_PER_UNIT[p]);
            if (!o || o > a) o = a;
            if (!s || s < a) s = a
        }, r = 0, j = n.length; r < j; r++)if (e =
                n[r], e.tileMatrixSet === h.identifier) {
            if (e.tileMatrixSetLimits) {
                for (var j = {}, r = 0, t = h.matrixIds.length; r < t; r++)j[h.matrixIds[r].identifier] = h.matrixIds[r];
                r = 0;
                for (t = e.tileMatrixSetLimits.length; r < t; r++)n = j[e.tileMatrixSetLimits[r].tileMatrix], m.push(n), f(n.scaleDenominator)
            } else {
                r = 0;
                for (t = h.matrixIds.length; r < t; r++)f(h.matrixIds[r].scaleDenominator)
            }
            break
        }
        if (c === "REST" && d.resourceUrls) {
            m = [];
            e = 0;
            for (f = d.resourceUrls.length; e < f; ++e)c = d.resourceUrls[e], c.format === g && c.resourceType === "tile" && m.push(c.template)
        } else {
            j =
                a.operationsMetadata.GetTile.dcp.http.get;
            m = [];
            e = 0;
            for (f = j.length; e < f; e++)n = j[e].constraints, (!n || n && n.GetEncoding.allowedValues[c]) && m.push(j[e].url)
        }
        q.sort(function (a, b) {
            return b - a
        });
        c = "";
        g = "SERVICE=WMTS&REQUEST=GetTile&VERSION=" + a.version + "&LAYER=" + d.identifier + "&STYLE=" + l.identifier + "&TILEMATRIXSET=" + h.identifier + "&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}&FORMAT=" + g;
        c = m[0].endsWith("?") ? m[0] + g : m[0] + "?" + g;
        g = GeoGlobe.Util.applyDefaults(b, {id: d.identifier, url: [c]});
        g = new GeoGlobe.Layer.VTS(g);
        g.matrixSet =
            h;
        g.identifier = d.identifier;
        g.bounds = d.bounds;
        return g
    }, CLASS_NAME: "GeoGlobe.Format.VTSCapabilities"
});
GeoGlobe.Format.VTSCapabilities.v1_0_0 = GeoGlobe.Class4OL(GeoGlobe.Format.OWSCommon.v1_1_0, {
    version: "1.0.0",
    namespaces: {
        ows: "http://www.opengis.net/ows/1.1",
        wmts: "http://www.opengis.net/wmts/1.0",
        xlink: "http://www.w3.org/1999/xlink"
    },
    yx: null,
    defaultPrefix: "wmts",
    initialize: function (a) {
        GeoGlobe.Format.XML.prototype.initialize.apply(this, [a]);
        this.options = a;
        a = GeoGlobe.Util.extend({}, GeoGlobe.Format.VTSCapabilities.prototype.yx);
        this.yx = GeoGlobe.Util.extend(a, this.yx)
    },
    read: function (a) {
        typeof a == "string" &&
        (a = GeoGlobe.Format.XML.prototype.read.apply(this, [a]));
        if (a && a.nodeType == 9) a = a.documentElement;
        var b = {};
        this.readNode(a, b);
        b.version = this.version;
        return b
    },
    readers: {
        wmts: {
            Capabilities: function (a, b) {
                this.readChildNodes(a, b)
            }, Contents: function (a, b) {
                b.contents = {};
                b.contents.layers = [];
                b.contents.tileMatrixSets = {};
                this.readChildNodes(a, b.contents)
            }, Layer: function (a, b) {
                var c = {styles: [], formats: [], dimensions: [], tileMatrixSetLinks: []};
                this.readChildNodes(a, c);
                b.layers.push(c)
            }, Style: function (a, b) {
                var c = {};
                c.isDefault = a.getAttribute("isDefault") === "true";
                this.readChildNodes(a, c);
                b.styles.push(c)
            }, Format: function (a, b) {
                b.formats.push(this.getChildValue(a))
            }, TileMatrixSetLink: function (a, b) {
                var c = {};
                this.readChildNodes(a, c);
                b.tileMatrixSetLinks.push(c)
            }, TileMatrixSet: function (a, b) {
                if (b.layers) {
                    var c = {matrixIds: []};
                    this.readChildNodes(a, c);
                    b.tileMatrixSets[c.identifier] = c
                } else b.tileMatrixSet = this.getChildValue(a)
            }, TileMatrixSetLimits: function (a, b) {
                b.tileMatrixSetLimits = [];
                this.readChildNodes(a, b)
            }, TileMatrixLimits: function (a,
                                           b) {
                var c = {};
                this.readChildNodes(a, c);
                b.tileMatrixSetLimits.push(c)
            }, MinTileRow: function (a, b) {
                b.minTileRow = parseInt(this.getChildValue(a))
            }, MaxTileRow: function (a, b) {
                b.maxTileRow = parseInt(this.getChildValue(a))
            }, MinTileCol: function (a, b) {
                b.minTileCol = parseInt(this.getChildValue(a))
            }, MaxTileCol: function (a, b) {
                b.maxTileCol = parseInt(this.getChildValue(a))
            }, TileMatrix: function (a, b) {
                if (b.identifier) {
                    var c = {supportedCRS: b.supportedCRS};
                    this.readChildNodes(a, c);
                    b.matrixIds.push(c)
                } else b.tileMatrix = this.getChildValue(a)
            },
            ScaleDenominator: function (a, b) {
                b.scaleDenominator = parseFloat(this.getChildValue(a))
            }, TopLeftCorner: function (a, b) {
                var c = this.getChildValue(a).split(" "), d;
                b.supportedCRS && (d = !!this.yx[b.supportedCRS.replace(/urn:ogc:def:crs:(\w+):.+:(\w+)$/, "urn:ogc:def:crs:$1::$2")]);
                b.topLeftCorner = d ? new GeoGlobe.LngLat(c[1], c[0]) : new GeoGlobe.LngLat(c[0], c[1])
            }, TileWidth: function (a, b) {
                b.tileWidth = parseInt(this.getChildValue(a))
            }, TileHeight: function (a, b) {
                b.tileHeight = parseInt(this.getChildValue(a))
            }, MatrixWidth: function (a,
                                      b) {
                b.matrixWidth = parseInt(this.getChildValue(a))
            }, MatrixHeight: function (a, b) {
                b.matrixHeight = parseInt(this.getChildValue(a))
            }, ResourceURL: function (a, b) {
                b.resourceUrl = b.resourceUrl || {};
                var c = a.getAttribute("resourceType");
                if (!b.resourceUrls) b.resourceUrls = [];
                c = b.resourceUrl[c] = {
                    format: a.getAttribute("format"),
                    template: a.getAttribute("template"),
                    resourceType: c
                };
                b.resourceUrls.push(c)
            }, LegendURL: function (a, b) {
                b.legends = b.legends || [];
                var c = {format: a.getAttribute("format"), href: a.getAttribute("xlink:href")},
                    d = a.getAttribute("width"), e = a.getAttribute("height"),
                    f = a.getAttribute("minScaleDenominator"), g = a.getAttribute("maxScaleDenominator");
                if (d !== null) c.width = parseInt(d);
                if (e !== null) c.height = parseInt(e);
                if (f !== null) c.minScaleDenominator = parseInt(f);
                if (g !== null) c.maxScaleDenominator = parseInt(g);
                b.legends.push(c)
            }, InfoFormat: function (a, b) {
                b.infoFormats = b.infoFormats || [];
                b.infoFormats.push(this.getChildValue(a))
            }, WSDL: function (a, b) {
                b.wsdl = {};
                b.wsdl.href = a.getAttribute("xlink:href")
            }, ServiceMetadataURL: function (a,
                                             b) {
                b.serviceMetadataUrl = {};
                b.serviceMetadataUrl.href = a.getAttribute("xlink:href")
            }, Dimension: function (a, b) {
                var c = {values: []};
                this.readChildNodes(a, c);
                b.dimensions.push(c)
            }, Default: function (a, b) {
                b["default"] = this.getChildValue(a)
            }, Value: function (a, b) {
                b.values.push(this.getChildValue(a))
            }
        }, ows: GeoGlobe.Format.OWSCommon.v1_1_0.prototype.readers.ows
    },
    CLASS_NAME: "GeoGlobe.Format.VTSCapabilities.v1_0_0"
});
GeoGlobe.Format.WMTSCapabilities = GeoGlobe.Class4OL(GeoGlobe.Format.XML.VersionedOGC, {
    defaultVersion: "1.0.0", yx: {"urn:ogc:def:crs:EPSG::4326": !0}, createLayer: function (a, b) {
        if (!("layer" in b))throw Error("Missing property 'layer' in configuration.");
        for (var c = a.contents, d, e = 0, f = c.layers.length; e < f; ++e)if (c.layers[e].identifier === b.layer) {
            d = c.layers[e];
            break
        }
        if (!d)throw Error("Layer not found");
        var g = b.format;
        !g && d.formats && d.formats.length && (g = d.formats[0]);
        var h;
        if (b.matrixSet) h = c.tileMatrixSets[b.matrixSet];
        else if (b.projection)for (var e = 0, j = d.tileMatrixSetLinks.length; e < j; e++) {
            if (c.tileMatrixSets[d.tileMatrixSetLinks[e].tileMatrixSet].supportedCRS.replace(/urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, "$1:$3") === b.projection) {
                h = c.tileMatrixSets[d.tileMatrixSetLinks[e].tileMatrixSet];
                break
            }
        } else d.tileMatrixSetLinks.length >= 1 && (h = c.tileMatrixSets[d.tileMatrixSetLinks[0].tileMatrixSet]);
        if (!h)throw Error("matrixSet not found");
        for (var l, e = 0, f = d.styles.length; e < f; ++e)if (l = d.styles[e], l.isDefault)break;
        (c = b.requestEncoding) ||
        (c = "KVP");
        var m = [], e = b.params || {};
        delete b.params;
        f = 0;
        for (j = d.dimensions.length; f < j; f++) {
            var n = d.dimensions[f];
            m.push(n.identifier);
            e.hasOwnProperty(n.identifier) || (e[n.identifier] = n["default"])
        }
        for (var m = b.projection || h.supportedCRS.replace(/urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, "$1:$3"), p = b.units || (m === "EPSG:4326" ? "degrees" : "m"), q = [], o, s, m = [], n = d.tileMatrixSetLinks, f = function (a) {
            q.push(a * 2.8E-4 / GeoGlobe.METERS_PER_INCH / GeoGlobe.INCHES_PER_UNIT[p]);
            if (!o || o > a) o = a;
            if (!s || s < a) s = a
        }, r = 0, j = n.length; r < j; r++)if (e =
                n[r], e.tileMatrixSet === h.identifier) {
            if (e.tileMatrixSetLimits) {
                for (var j = {}, r = 0, t = h.matrixIds.length; r < t; r++)j[h.matrixIds[r].identifier] = h.matrixIds[r];
                r = 0;
                for (t = e.tileMatrixSetLimits.length; r < t; r++)n = j[e.tileMatrixSetLimits[r].tileMatrix], m.push(n), f(n.scaleDenominator)
            } else {
                r = 0;
                for (t = h.matrixIds.length; r < t; r++)f(h.matrixIds[r].scaleDenominator)
            }
            break
        }
        if (c === "REST" && d.resourceUrls) {
            m = [];
            e = 0;
            for (f = d.resourceUrls.length; e < f; ++e)c = d.resourceUrls[e], c.format === g && c.resourceType === "tile" && m.push(c.template)
        } else {
            j =
                a.operationsMetadata.GetTile.dcp.http.get;
            m = [];
            e = 0;
            for (f = j.length; e < f; e++)n = j[e].constraints, (!n || n && n.GetEncoding.allowedValues[c]) && m.push(j[e].url)
        }
        q.sort(function (a, b) {
            return b - a
        });
        c = "";
        g = "SERVICE=WMTS&REQUEST=GetTile&VERSION=" + a.version + "&LAYER=" + d.identifier + "&STYLE=" + l.identifier + "&TILEMATRIXSET=" + h.identifier + "&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}&FORMAT=" + g;
        c = m[0].endsWith("?") ? m[0] + g : m[0] + "?" + g;
        g = GeoGlobe.Util.applyDefaults(b, {id: d.identifier, url: [c]});
        g = {
            id: g.id, layer: {
                id: g.id, type: "raster",
                source: g.id
            }, source: {type: "raster", tiles: g.url, tileSize: 256}
        };
        g.matrixSet = h;
        g.identifier = d.identifier;
        g.boundingBox = d.BoundingBox;
        return g
    }, CLASS_NAME: "GeoGlobe.Format.WMTSCapabilities"
});
GeoGlobe.Format.WMTSCapabilities.v1_0_0 = GeoGlobe.Class4OL(GeoGlobe.Format.OWSCommon.v1_1_0, {
    version: "1.0.0",
    namespaces: {
        ows: "http://www.opengis.net/ows/1.1",
        wmts: "http://www.opengis.net/wmts/1.0",
        xlink: "http://www.w3.org/1999/xlink"
    },
    yx: null,
    defaultPrefix: "wmts",
    initialize: function (a) {
        GeoGlobe.Format.XML.prototype.initialize.apply(this, [a]);
        this.options = a;
        a = GeoGlobe.Util.extend({}, GeoGlobe.Format.WMTSCapabilities.prototype.yx);
        this.yx = GeoGlobe.Util.extend(a, this.yx)
    },
    read: function (a) {
        typeof a == "string" &&
        (a = GeoGlobe.Format.XML.prototype.read.apply(this, [a]));
        if (a && a.nodeType == 9) a = a.documentElement;
        var b = {};
        this.readNode(a, b);
        b.version = this.version;
        return b
    },
    readers: {
        wmts: {
            Capabilities: function (a, b) {
                this.readChildNodes(a, b)
            }, Contents: function (a, b) {
                b.contents = {};
                b.contents.layers = [];
                b.contents.tileMatrixSets = {};
                this.readChildNodes(a, b.contents)
            }, Layer: function (a, b) {
                var c = {styles: [], formats: [], dimensions: [], tileMatrixSetLinks: []};
                this.readChildNodes(a, c);
                b.layers.push(c)
            }, Style: function (a, b) {
                var c = {};
                c.isDefault = a.getAttribute("isDefault") === "true";
                this.readChildNodes(a, c);
                b.styles.push(c)
            }, Format: function (a, b) {
                b.formats.push(this.getChildValue(a))
            }, TileMatrixSetLink: function (a, b) {
                var c = {};
                this.readChildNodes(a, c);
                b.tileMatrixSetLinks.push(c)
            }, TileMatrixSet: function (a, b) {
                if (b.layers) {
                    var c = {matrixIds: []};
                    this.readChildNodes(a, c);
                    b.tileMatrixSets[c.identifier] = c
                } else b.tileMatrixSet = this.getChildValue(a)
            }, TileMatrixSetLimits: function (a, b) {
                b.tileMatrixSetLimits = [];
                this.readChildNodes(a, b)
            }, TileMatrixLimits: function (a,
                                           b) {
                var c = {};
                this.readChildNodes(a, c);
                b.tileMatrixSetLimits.push(c)
            }, MinTileRow: function (a, b) {
                b.minTileRow = parseInt(this.getChildValue(a))
            }, MaxTileRow: function (a, b) {
                b.maxTileRow = parseInt(this.getChildValue(a))
            }, MinTileCol: function (a, b) {
                b.minTileCol = parseInt(this.getChildValue(a))
            }, MaxTileCol: function (a, b) {
                b.maxTileCol = parseInt(this.getChildValue(a))
            }, TileMatrix: function (a, b) {
                if (b.identifier) {
                    var c = {supportedCRS: b.supportedCRS};
                    this.readChildNodes(a, c);
                    b.matrixIds.push(c)
                } else b.tileMatrix = this.getChildValue(a)
            },
            ScaleDenominator: function (a, b) {
                b.scaleDenominator = parseFloat(this.getChildValue(a))
            }, TopLeftCorner: function (a, b) {
                var c = this.getChildValue(a).split(" "), d;
                b.supportedCRS && (d = !!this.yx[b.supportedCRS.replace(/urn:ogc:def:crs:(\w+):.+:(\w+)$/, "urn:ogc:def:crs:$1::$2")]);
                b.topLeftCorner = d ? new GeoGlobe.LngLat(c[1], c[0]) : new GeoGlobe.LngLat(c[0], c[1])
            }, TileWidth: function (a, b) {
                b.tileWidth = parseInt(this.getChildValue(a))
            }, TileHeight: function (a, b) {
                b.tileHeight = parseInt(this.getChildValue(a))
            }, MatrixWidth: function (a,
                                      b) {
                b.matrixWidth = parseInt(this.getChildValue(a))
            }, MatrixHeight: function (a, b) {
                b.matrixHeight = parseInt(this.getChildValue(a))
            }, ResourceURL: function (a, b) {
                b.resourceUrl = b.resourceUrl || {};
                var c = a.getAttribute("resourceType");
                if (!b.resourceUrls) b.resourceUrls = [];
                c = b.resourceUrl[c] = {
                    format: a.getAttribute("format"),
                    template: a.getAttribute("template"),
                    resourceType: c
                };
                b.resourceUrls.push(c)
            }, LegendURL: function (a, b) {
                b.legends = b.legends || [];
                var c = {format: a.getAttribute("format"), href: a.getAttribute("xlink:href")},
                    d = a.getAttribute("width"), e = a.getAttribute("height"),
                    f = a.getAttribute("minScaleDenominator"), g = a.getAttribute("maxScaleDenominator");
                if (d !== null) c.width = parseInt(d);
                if (e !== null) c.height = parseInt(e);
                if (f !== null) c.minScaleDenominator = parseInt(f);
                if (g !== null) c.maxScaleDenominator = parseInt(g);
                b.legends.push(c)
            }, InfoFormat: function (a, b) {
                b.infoFormats = b.infoFormats || [];
                b.infoFormats.push(this.getChildValue(a))
            }, WSDL: function (a, b) {
                b.wsdl = {};
                b.wsdl.href = a.getAttribute("xlink:href")
            }, ServiceMetadataURL: function (a,
                                             b) {
                b.serviceMetadataUrl = {};
                b.serviceMetadataUrl.href = a.getAttribute("xlink:href")
            }, Dimension: function (a, b) {
                var c = {values: []};
                this.readChildNodes(a, c);
                b.dimensions.push(c)
            }, Default: function (a, b) {
                b["default"] = this.getChildValue(a)
            }, Value: function (a, b) {
                b.values.push(this.getChildValue(a))
            }
        }, ows: GeoGlobe.Format.OWSCommon.v1_1_0.prototype.readers.ows
    },
    CLASS_NAME: "GeoGlobe.Format.WMTSCapabilities.v1_0_0"
});
GeoGlobe.Format.WMTSUtil = GeoGlobe.Class4OL({
    initialize: function (a) {
        GeoGlobe.Util.extend(this, a)
    }, getWMTSCapabilities: function (a) {
        var b = null;
        this.getCapabilities(a, function (a) {
            var d = a.responseXML;
            if (!d || !d.documentElement) d = a.responseText;
            b = (new GeoGlobe.Format.WMTSCapabilities.v1_0_0).read(d)
        }, function () {
            alert("WMTS\u670d\u52a1\u8bf7\u6c42\u5931\u8d25\uff0c\u8bf7\u68c0\u67e5\u670d\u52a1\u662f\u5426\u6b63\u5e38\u8fd0\u884c\u6216\u8bf7\u6c42\u5730\u5740\u662f\u5426\u6b63\u786e\u3002\n\u8bf7\u6c42\u5730\u5740\uff1a" +
                a + "\n\u64cd\u4f5c\u7c7b\u578b\uff1aGetCapabilities")
        });
        return b
    }, getCapabilities: function (a, b, c) {
        typeof c != "function" && (c = function () {
            alert("WMTS\u670d\u52a1\u8bf7\u6c42\u5931\u8d25\uff0c\u8bf7\u68c0\u67e5\u670d\u52a1\u662f\u5426\u6b63\u5e38\u8fd0\u884c\u6216\u8bf7\u6c42\u5730\u5740\u662f\u5426\u6b63\u786e\u3002\n\u8bf7\u6c42\u5730\u5740\uff1a" + a + "\n\u64cd\u4f5c\u7c7b\u578b\uff1aGetCapabilities")
        });
        GeoGlobe.Request.GET({
            url: a,
            params: {REQUEST: "GetCapabilities", SERVICE: "WMTS"},
            scope: this,
            async: !1,
            success: function (a) {
                typeof b ==
                "function" && b(a)
            },
            failure: c
        })
    }, createLayerOption: function (a, b, c) {
        if (!("layer" in c))throw Error("Missing property 'layer' in configuration.");
        for (var d = b.contents, e, f = 0, g = d.layers.length; f < g; ++f)if (d.layers[f].identifier === c.layer) {
            e = d.layers[f];
            break
        }
        if (!e)throw Error("Layer not found");
        var h = c.format;
        !h && e.formats && e.formats.length && (h = e.formats[0]);
        var j;
        if (c.matrixSet) j = d.tileMatrixSets[c.matrixSet]; else if (c.projection) {
            f = 0;
            for (g = e.tileMatrixSetLinks.length; f < g; f++)if (d.tileMatrixSets[e.tileMatrixSetLinks[f].tileMatrixSet].supportedCRS.replace(/urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/,
                    "$1:$3") === c.projection) {
                j = d.tileMatrixSets[e.tileMatrixSetLinks[f].tileMatrixSet];
                break
            }
        } else e.tileMatrixSetLinks.length >= 1 && (j = d.tileMatrixSets[e.tileMatrixSetLinks[0].tileMatrixSet]);
        if (!j)throw Error("matrixSet not found");
        for (var l, f = 0, g = e.styles.length; f < g; ++f)if (l = e.styles[f], l.isDefault)break;
        (d = c.requestEncoding) || (d = "KVP");
        d = [];
        f = c.params || {};
        delete c.params;
        for (var g = 0, m = e.dimensions.length; g < m; g++) {
            var n = e.dimensions[g];
            d.push(n.identifier);
            f.hasOwnProperty(n.identifier) || (f[n.identifier] =
                n["default"])
        }
        for (var d = c.projection || j.supportedCRS.replace(/urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, "$1:$3"), p = c.units || (d === "EPSG:4326" ? "degrees" : "m"), q = [], o, s, c = [], m = e.tileMatrixSetLinks, f = function (a) {
            q.push(a * 2.8E-4 / GeoGlobe.METERS_PER_INCH / GeoGlobe.INCHES_PER_UNIT[p]);
            if (!o || o > a) o = a;
            if (!s || s < a) s = a
        }, n = 0, g = m.length; n < g; n++)if (d = m[n], d.tileMatrixSet === j.identifier) {
            if (d.tileMatrixSetLimits) {
                for (var g = {}, n = 0, r = j.matrixIds.length; n < r; n++)g[j.matrixIds[n].identifier] = j.matrixIds[n];
                n = 0;
                for (r = d.tileMatrixSetLimits.length; n <
                r; n++)m = g[d.tileMatrixSetLimits[n].tileMatrix], c.push(m), f(m.scaleDenominator)
            } else {
                n = 0;
                for (r = j.matrixIds.length; n < r; n++)f(j.matrixIds[n].scaleDenominator)
            }
            break
        }
        q.sort(function (a, b) {
            return b - a
        });
        c = "";
        b = this.getParameterString({
            SERVICE: "WMTS",
            REQUEST: "GetTile",
            VERSION: b.version,
            LAYER: e.identifier,
            STYLE: l.identifier,
            TILEMATRIXSET: j.identifier,
            FORMAT: h,
            TILEMATRIX: "{z}",
            TILEROW: "{y}",
            TILECOL: "{x}"
        });
        c = a.endsWith("?") ? GeoGlobe.ProxyHost + a + b : GeoGlobe.ProxyHost + a + "?" + b;
        a = GeoGlobe.Util.randomStr(10);
        return {
            id: "layer_" +
            e.identifier + "_" + a,
            type: "raster",
            source: {type: "raster", tiles: [c], tileSize: 256},
            paint: {"raster-opacity": 1}
        }
    }, createLayer: function (a) {
        var b = this.getWMTSCapabilities(a);
        return this.createLayerOption(a, b, {layer: b.contents.layers[0].identifier})
    }, createLayers: function (a) {
        for (var b = this.getWMTSCapabilities(a), c = b.contents.layers, d = [], e = 0; e < c.length; e++) {
            var f = this.createLayerOption(a, b, {layer: c[e].identifier});
            d.push(f)
        }
        return d
    }, getParameterString: function (a) {
        var b = [], c;
        for (c in a) {
            var d = a[c];
            d != null &&
            typeof d != "function" && b.push(c + "=" + d)
        }
        return b.join("&")
    }, CLASS_NAME: "GeoGlobe.Format.WMTSUtil"
});
GeoGlobe.Format.WPSCapabilities = GeoGlobe.Class4OL(GeoGlobe.Format.XML.VersionedOGC, {
    defaultVersion: "1.0.0",
    CLASS_NAME: "GeoGlobe.Format.WPSCapabilities"
});
GeoGlobe.Format.WPSCapabilities.v1_0_0 = GeoGlobe.Class4OL(GeoGlobe.Format.XML, {
    namespaces: {
        ows: "http://www.opengis.net/ows/1.1",
        wps: "http://www.opengis.net/wps/1.0.0",
        xlink: "http://www.w3.org/1999/xlink"
    },
    regExes: {trimSpace: /^\s*|\s*$/g, removeSpace: /\s*/g, splitSpace: /\s+/, trimComma: /\s*,\s*/g},
    initialize: function (a) {
        GeoGlobe.Format.XML.prototype.initialize.apply(this, [a])
    },
    read: function (a) {
        typeof a == "string" && (a = GeoGlobe.Format.XML.prototype.read.apply(this, [a]));
        if (a && a.nodeType == 9) a = a.documentElement;
        var b = {};
        this.readNode(a, b);
        return b
    },
    readers: {
        wps: {
            Capabilities: function (a, b) {
                this.readChildNodes(a, b)
            }, ProcessOfferings: function (a, b) {
                b.processOfferings = {};
                this.readChildNodes(a, b.processOfferings)
            }, Process: function (a, b) {
                var c = {processVersion: this.getAttributeNS(a, this.namespaces.wps, "processVersion")};
                this.readChildNodes(a, c);
                b[c.identifier] = c
            }, Languages: function (a, b) {
                b.languages = [];
                this.readChildNodes(a, b.languages)
            }, Default: function (a, b) {
                var c = {isDefault: !0};
                this.readChildNodes(a, c);
                b.push(c)
            },
            Supported: function (a, b) {
                var c = {};
                this.readChildNodes(a, c);
                b.push(c)
            }
        }, ows: GeoGlobe.Format.OWSCommon.v1_1_0.prototype.readers.ows
    },
    CLASS_NAME: "GeoGlobe.Format.WPSCapabilities.v1_0_0"
});
GeoGlobe.Format.WCSGetCoverage = GeoGlobe.Class4OL(GeoGlobe.Format.XML, {
    namespaces: {
        ows: "http://www.opengis.net/ows/1.1",
        wcs: "http://www.opengis.net/wcs/1.1",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance"
    },
    regExes: {trimSpace: /^\s*|\s*$/g, removeSpace: /\s*/g, splitSpace: /\s+/, trimComma: /\s*,\s*/g},
    VERSION: "1.1.2",
    schemaLocation: "http://www.opengis.net/wcs/1.1 http://schemas.opengis.net/wcs/1.1/wcsGetCoverage.xsd",
    write: function (a) {
        a = this.writeNode("wcs:GetCoverage",
            a);
        this.setAttributeNS(a, this.namespaces.xsi, "xsi:schemaLocation", this.schemaLocation);
        return GeoGlobe.Format.XML.prototype.write.apply(this, [a])
    },
    writers: {
        wcs: {
            GetCoverage: function (a) {
                var b = this.createElementNSPlus("wcs:GetCoverage", {
                    attributes: {
                        version: a.version || this.VERSION,
                        service: "WCS"
                    }
                });
                this.writeNode("ows:Identifier", a.identifier, b);
                this.writeNode("wcs:DomainSubset", a.domainSubset, b);
                this.writeNode("wcs:Output", a.output, b);
                return b
            }, DomainSubset: function (a) {
                var b = this.createElementNSPlus("wcs:DomainSubset",
                    {});
                this.writeNode("ows:BoundingBox", a.boundingBox, b);
                a.temporalSubset && this.writeNode("wcs:TemporalSubset", a.temporalSubset, b);
                return b
            }, TemporalSubset: function (a) {
                for (var b = this.createElementNSPlus("wcs:TemporalSubset", {}), c = 0, d = a.timePeriods.length; c < d; ++c)this.writeNode("wcs:TimePeriod", a.timePeriods[c], b);
                return b
            }, TimePeriod: function (a) {
                var b = this.createElementNSPlus("wcs:TimePeriod", {});
                this.writeNode("wcs:BeginPosition", a.begin, b);
                this.writeNode("wcs:EndPosition", a.end, b);
                a.resolution && this.writeNode("wcs:TimeResolution",
                    a.resolution, b);
                return b
            }, BeginPosition: function (a) {
                return this.createElementNSPlus("wcs:BeginPosition", {value: a})
            }, EndPosition: function (a) {
                return this.createElementNSPlus("wcs:EndPosition", {value: a})
            }, TimeResolution: function (a) {
                return this.createElementNSPlus("wcs:TimeResolution", {value: a})
            }, Output: function (a) {
                var b = this.createElementNSPlus("wcs:Output", {attributes: {format: a.format, store: a.store}});
                a.gridCRS && this.writeNode("wcs:GridCRS", a.gridCRS, b);
                return b
            }, GridCRS: function (a) {
                var b = this.createElementNSPlus("wcs:GridCRS",
                    {});
                this.writeNode("wcs:GridBaseCRS", a.baseCRS, b);
                a.type && this.writeNode("wcs:GridType", a.type, b);
                a.origin && this.writeNode("wcs:GridOrigin", a.origin, b);
                this.writeNode("wcs:GridOffsets", a.offsets, b);
                a.CS && this.writeNode("wcs:GridCS", a.CS, b);
                return b
            }, GridBaseCRS: function (a) {
                return this.createElementNSPlus("wcs:GridBaseCRS", {value: a})
            }, GridOrigin: function (a) {
                return this.createElementNSPlus("wcs:GridOrigin", {value: a})
            }, GridType: function (a) {
                return this.createElementNSPlus("wcs:GridType", {value: a})
            }, GridOffsets: function (a) {
                return this.createElementNSPlus("wcs:GridOffsets",
                    {value: a})
            }, GridCS: function (a) {
                return this.createElementNSPlus("wcs:GridCS", {value: a})
            }
        }, ows: GeoGlobe.Format.OWSCommon.v1_1_0.prototype.writers.ows
    },
    CLASS_NAME: "GeoGlobe.Format.WCSGetCoverage"
});
GeoGlobe.Format.WPSExecute = GeoGlobe.Class4OL(GeoGlobe.Format.XML, GeoGlobe.Format.Filter.v1_1_0, {
    namespaces: {
        ows: "http://www.opengis.net/ows/1.1",
        gml: "http://www.opengis.net/gml",
        wps: "http://www.opengis.net/wps/1.0.0",
        wfs: "http://www.opengis.net/wfs",
        ogc: "http://www.opengis.net/ogc",
        wcs: "http://www.opengis.net/wcs",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance"
    },
    regExes: {trimSpace: /^\s*|\s*$/g, removeSpace: /\s*/g, splitSpace: /\s+/, trimComma: /\s*,\s*/g},
    VERSION: "1.0.0",
    schemaLocation: "http://www.opengis.net/wps/1.0.0 http://schemas.opengis.net/wps/1.0.0/wpsAll.xsd",
    schemaLocationAttr: function () {
    },
    write: function (a) {
        var b;
        GeoGlobe.Format.XML.supportActiveX ? this.xmldom = b = new ActiveXObject("Microsoft.XMLDOM") : b = document.implementation.createDocument("", "", null);
        a = this.writeNode("wps:Execute", a, b);
        this.setAttributeNS(a, this.namespaces.xsi, "xsi:schemaLocation", this.schemaLocation);
        return GeoGlobe.Format.XML.prototype.write.apply(this, [a])
    },
    read: function (a) {
        typeof a ==
        "string" && (a = GeoGlobe.Format.XML.prototype.read.apply(this, [a]));
        if (a && a.nodeType == 9) a = a.documentElement;
        var b = {};
        this.readNode(a, b);
        return b
    },
    writers: {
        wps: {
            Execute: function (a) {
                var b = this.createElementNSPlus("wps:Execute", {attributes: {version: this.VERSION, service: "WPS"}});
                this.writeNode("ows:Identifier", a.identifier, b);
                this.writeNode("wps:DataInputs", a.dataInputs, b);
                this.writeNode("wps:ResponseForm", a.responseForm, b);
                return b
            }, ResponseForm: function (a) {
                var b = this.createElementNSPlus("wps:ResponseForm",
                    {});
                a.rawDataOutput && this.writeNode("wps:RawDataOutput", a.rawDataOutput, b);
                a.responseDocument && this.writeNode("wps:ResponseDocument", a.responseDocument, b);
                return b
            }, ResponseDocument: function (a) {
                var b = this.createElementNSPlus("wps:ResponseDocument", {
                    attributes: {
                        storeExecuteResponse: a.storeExecuteResponse,
                        lineage: a.lineage,
                        status: a.status
                    }
                });
                if (a.outputs)for (var c = 0, d = a.outputs.length; c < d; c++)this.writeNode("wps:Output", a.outputs[c], b);
                return b
            }, Output: function (a) {
                var b = this.createElementNSPlus("wps:Output",
                    {
                        attributes: {
                            asReference: a.asReference,
                            mimeType: a.mimeType,
                            encoding: a.encoding,
                            schema: a.schema
                        }
                    });
                this.writeNode("ows:Identifier", a.identifier, b);
                this.writeNode("ows:Title", a.title, b);
                this.writeNode("ows:Abstract", a["abstract"], b);
                return b
            }, RawDataOutput: function (a) {
                var b = this.createElementNSPlus("wps:RawDataOutput", {
                    attributes: {
                        mimeType: a.mimeType,
                        encoding: a.encoding,
                        schema: a.schema
                    }
                });
                this.writeNode("ows:Identifier", a.identifier, b);
                return b
            }, DataInputs: function (a) {
                for (var b = this.createElementNSPlus("wps:DataInputs",
                    {}), c = 0, d = a.length; c < d; ++c)this.writeNode("wps:Input", a[c], b);
                return b
            }, Input: function (a) {
                var b = this.createElementNSPlus("wps:Input", {});
                this.writeNode("ows:Identifier", a.identifier, b);
                a.title && this.writeNode("ows:Title", a.title, b);
                a.data && this.writeNode("wps:Data", a.data, b);
                a.reference && this.writeNode("wps:Reference", a.reference, b);
                a.boundingBoxData && this.writeNode("wps:BoundingBoxData", a.boundingBoxData, b);
                return b
            }, Data: function (a) {
                var b = this.createElementNSPlus("wps:Data", {});
                a.literalData ? this.writeNode("wps:LiteralData",
                    a.literalData, b) : a.complexData ? this.writeNode("wps:ComplexData", a.complexData, b) : a.boundingBoxData && this.writeNode("ows:BoundingBox", a.boundingBoxData, b);
                return b
            }, LiteralData: function (a) {
                return this.createElementNSPlus("wps:LiteralData", {attributes: {uom: a.uom}, value: a.value})
            }, ComplexData: function (a) {
                var b = this.createElementNSPlus("wps:ComplexData", {
                    attributes: {
                        mimeType: a.mimeType,
                        encoding: a.encoding,
                        schema: a.schema
                    }
                }), c = a.value;
                typeof c === "string" ? b.appendChild(this.getXMLDoc().createCDATASection(a.value)) :
                    b.appendChild(c);
                return b
            }, Reference: function (a) {
                var b = this.createElementNSPlus("wps:Reference", {
                    attributes: {
                        mimeType: a.mimeType,
                        "xlink:href": a.href,
                        method: a.method,
                        encoding: a.encoding,
                        schema: a.schema
                    }
                });
                a.body && this.writeNode("wps:Body", a.body, b);
                return b
            }, BoundingBoxData: function (a, b) {
                this.writers.ows.BoundingBox.apply(this, [a, b, "wps:BoundingBoxData"])
            }, Body: function (a) {
                var b = this.createElementNSPlus("wps:Body", {});
                a.wcs ? this.writeNode("wcs:GetCoverage", a.wcs, b) : a.wfs ? (this.featureType = a.wfs.featureType,
                    this.version = a.wfs.version, this.writeNode("wfs:GetFeature", a.wfs, b)) : this.writeNode("wps:Execute", a, b);
                return b
            }
        },
        wcs: GeoGlobe.Format.WCSGetCoverage.prototype.writers.wcs,
        wfs: GeoGlobe.Format.WFST.v1_1_0.prototype.writers.wfs,
        ogc: GeoGlobe.Format.Filter.v1_1_0.prototype.writers.ogc,
        ows: GeoGlobe.Format.OWSCommon.v1_1_0.prototype.writers.ows
    },
    readers: {
        wps: {
            ExecuteResponse: function (a, b) {
                b.executeResponse = {
                    lang: a.getAttribute("lang"),
                    statusLocation: a.getAttribute("statusLocation"),
                    serviceInstance: a.getAttribute("serviceInstance"),
                    service: a.getAttribute("service")
                };
                this.readChildNodes(a, b.executeResponse)
            }, Process: function (a, b) {
                b.process = {};
                this.readChildNodes(a, b.process)
            }, Status: function (a, b) {
                b.status = {creationTime: a.getAttribute("creationTime")};
                this.readChildNodes(a, b.status)
            }, ProcessSucceeded: function (a, b) {
                b.processSucceeded = !0
            }, ProcessOutputs: function (a, b) {
                b.processOutputs = [];
                this.readChildNodes(a, b.processOutputs)
            }, Output: function (a, b) {
                var c = {};
                this.readChildNodes(a, c);
                b.push(c)
            }, Reference: function (a, b) {
                b.reference =
                    {
                        href: a.getAttribute("href"),
                        mimeType: a.getAttribute("mimeType"),
                        encoding: a.getAttribute("encoding"),
                        schema: a.getAttribute("schema")
                    }
            }, Data: function (a, b) {
                b.data = {};
                this.readChildNodes(a, b)
            }, LiteralData: function (a, b) {
                b.literalData = {
                    dataType: a.getAttribute("dataType"),
                    uom: a.getAttribute("uom"),
                    value: this.getChildValue(a)
                }
            }, ComplexData: function (a, b) {
                b.complexData = {
                    mimeType: a.getAttribute("mimeType"),
                    schema: a.getAttribute("schema"),
                    encoding: a.getAttribute("encoding"),
                    value: ""
                };
                if (this.isSimpleContent(a)) {
                    var c;
                    for (c = a.firstChild; c; c = c.nextSibling)switch (c.nodeType) {
                        case 3:
                        case 4:
                            b.complexData.value += c.nodeValue
                    }
                } else for (c = a.firstChild; c; c = c.nextSibling)if (c.nodeType == 1) b.complexData.value = c
            }, BoundingBox: function (a, b) {
                b.boundingBoxData = {dimensions: a.getAttribute("dimensions"), crs: a.getAttribute("crs")};
                this.readChildNodes(a, b.boundingBoxData)
            }
        }, ows: GeoGlobe.Format.OWSCommon.v1_1_0.prototype.readers.ows
    },
    CLASS_NAME: "GeoGlobe.Format.WPSExecute"
});
GeoGlobe.Format.OGCExceptionReport = GeoGlobe.Class4OL(GeoGlobe.Format.XML, {
    namespaces: {ogc: "http://www.opengis.net/ogc"},
    regExes: {trimSpace: /^\s*|\s*$/g, removeSpace: /\s*/g, splitSpace: /\s+/, trimComma: /\s*,\s*/g},
    defaultPrefix: "ogc",
    read: function (a) {
        typeof a == "string" && (a = GeoGlobe.Format.XML.prototype.read.apply(this, [a]));
        var b = {exceptionReport: null};
        a.documentElement && (this.readChildNodes(a, b), b.exceptionReport === null && (b = (new GeoGlobe.Format.OWSCommon).read(a)));
        return b
    },
    readers: {
        ogc: {
            ServiceExceptionReport: function (a,
                                              b) {
                b.exceptionReport = {exceptions: []};
                this.readChildNodes(a, b.exceptionReport)
            }, ServiceException: function (a, b) {
                var c = {code: a.getAttribute("code"), locator: a.getAttribute("locator"), text: this.getChildValue(a)};
                b.exceptions.push(c)
            }
        }
    },
    CLASS_NAME: "GeoGlobe.Format.OGCExceptionReport"
});
GeoGlobe.Format.QueryStringFilter = function () {
    function a(a) {
        a = a.replace(/%/g, "\\%");
        a = a.replace(/\\\\\.(\*)?/g, function (a, b) {
            return b ? a : "\\\\_"
        });
        a = a.replace(/\\\\\.\*/g, "\\\\%");
        a = a.replace(/(\\)?\.(\*)?/g, function (a, b, c) {
            return b || c ? a : "_"
        });
        a = a.replace(/(\\)?\.\*/g, function (a, b) {
            return b ? a : "%"
        });
        a = a.replace(/\\\./g, ".");
        return a = a.replace(/(\\)?\\\*/g, function (a, b) {
            return b ? a : "*"
        })
    }

    var b = {};
    b[GeoGlobe.Filter.Comparison.EQUAL_TO] = "eq";
    b[GeoGlobe.Filter.Comparison.NOT_EQUAL_TO] = "ne";
    b[GeoGlobe.Filter.Comparison.LESS_THAN] =
        "lt";
    b[GeoGlobe.Filter.Comparison.LESS_THAN_OR_EQUAL_TO] = "lte";
    b[GeoGlobe.Filter.Comparison.GREATER_THAN] = "gt";
    b[GeoGlobe.Filter.Comparison.GREATER_THAN_OR_EQUAL_TO] = "gte";
    b[GeoGlobe.Filter.Comparison.LIKE] = "ilike";
    return GeoGlobe.Class4OL(GeoGlobe.Format, {
        wildcarded: !1, srsInBBOX: !1, write: function (c, d) {
            var d = d || {}, e = c.CLASS_NAME, e = e.substring(e.lastIndexOf(".") + 1);
            switch (e) {
                case "Spatial":
                    switch (c.type) {
                        case GeoGlobe.Filter.Spatial.BBOX:
                            d.bbox = c.value.toArray();
                            this.srsInBBOX && c.projection && d.bbox.push(c.projection.getCode());
                            break;
                        case GeoGlobe.Filter.Spatial.DWITHIN:
                            d.tolerance = c.distance;
                        case GeoGlobe.Filter.Spatial.WITHIN:
                            d.lon = c.value.x;
                            d.lat = c.value.y;
                            break;
                        default:
                            GeoGlobe.Console.warn("Unknown spatial filter type " + c.type)
                    }
                    break;
                case "Comparison":
                    e = b[c.type];
                    if (e !== void 0) {
                        var f = c.value;
                        c.type == GeoGlobe.Filter.Comparison.LIKE && (f = a(f), this.wildcarded && (f = "%" + f + "%"));
                        d[c.property + "__" + e] = f;
                        d.queryable = d.queryable || [];
                        d.queryable.push(c.property)
                    } else GeoGlobe.Console.warn("Unknown comparison filter type " + c.type);
                    break;
                case "Logical":
                    if (c.type === GeoGlobe.Filter.Logical.AND) {
                        e = 0;
                        for (f = c.filters.length; e < f; e++)d = this.write(c.filters[e], d)
                    } else GeoGlobe.Console.warn("Unsupported logical filter type " + c.type);
                    break;
                default:
                    GeoGlobe.Console.warn("Unknown filter type " + e)
            }
            return d
        }, CLASS_NAME: "GeoGolobe.Format.QueryStringFilter"
    })
}();
GeoGlobe.Format.BusCapabilities = GeoGlobe.Class4OL(GeoGlobe.Format.XML, {
    tagName: "NETWORK_Capabilities", read: function (a) {
        typeof a == "string" && (a = GeoGlobe.Format.XML.prototype.read.apply(this, [a]));
        var a = a.nodeName != this.tagName ? a.getElementsByTagName(this.tagName) : [a], b = {};
        a.length > 0 && this.runChildNodes(b, a[0]);
        return b
    }, runChildNodes: function (a, b, c) {
        for (var b = b.childNodes, d, e, f = 0; f < b.length; ++f)d = b[f], d.nodeType == 1 && (e = c ? this["read_" + c + "_" + d.nodeName] : this["read_" + d.nodeName]) && e.apply(this, [a, d])
    },
    read_Service: function (a, b) {
        var c = {};
        this.runChildNodes(c, b, "Service");
        a.service = c
    }, read_Service_Name: function (a, b) {
        var c = this.getChildValue(b);
        if (c) a.name = c
    }, read_Service_Title: function (a, b) {
        var c = this.getChildValue(b);
        if (c) a.title = c
    }, read_Service_Abstract: function (a, b) {
        var c = this.getChildValue(b);
        if (c) a.serviceAbstract = c
    }, read_Service_KeywordList: function () {
    }, read_Service_OnlineResource: function (a, b) {
        var c = this.getChildValue(b);
        if (a) a.onlineResource = c
    }, read_Capability: function (a, b) {
        var c = {};
        this.runChildNodes(c,
            b, "Capability");
        a.capability = c
    }, read_Capability_Request: function (a, b) {
        var c = {};
        this.runChildNodes(c, b, "Capability_Request");
        a.request = c
    }, read_Capability_Request_GetCapabilities: function (a, b) {
        var c = b.getElementsByTagName("HTTP"), d = {};
        c[0] && this.runChildNodes(d, c[0], "Capability_Request_GetCapabilities_DCPType_HTTP");
        a.getCapabilities = d
    }, read_Capability_Request_GetCapabilities_DCPType_HTTP_Get: function (a, b) {
        var c = b.getAttribute("onlineResource");
        if (c) a.getUrl = c
    }, read_Capability_Request_GetCapabilities_DCPType_HTTP_Post: function (a,
                                                                            b) {
        var c = b.getAttribute("onlineResource");
        if (c) a.postUrl = c
    }, read_Capability_Request_queryStation: function (a, b) {
        var c = b.getElementsByTagName("HTTP"), d = {};
        c[0] && this.runChildNodes(d, c[0], "Capability_Request_queryStation_DCPType_HTTP");
        a.queryStation = d
    }, read_Capability_Request_queryStation_DCPType_HTTP_Get: function (a, b) {
        var c = b.getAttribute("onlineResource");
        if (c) a.getUrl = c
    }, read_Capability_Request_queryStation_DCPType_HTTP_Post: function (a, b) {
        var c = b.getAttribute("onlineResource");
        if (c) a.postUrl = c
    },
    read_Capability_Request_queryLine: function (a, b) {
        var c = b.getElementsByTagName("HTTP"), d = {};
        c[0] && this.runChildNodes(d, c[0], "Capability_Request_queryLine_DCPType_HTTP");
        a.queryLine = d
    }, read_Capability_Request_queryLine_DCPType_HTTP_Get: function (a, b) {
        var c = b.getAttribute("onlineResource");
        if (c) a.getUrl = c
    }, read_Capability_Request_queryLine_DCPType_HTTP_Post: function (a, b) {
        var c = b.getAttribute("onlineResource");
        if (c) a.postUrl = c
    }, read_Capability_Request_queryChange: function (a, b) {
        var c = b.getElementsByTagName("HTTP"),
            d = {};
        c[0] && this.runChildNodes(d, c[0], "Capability_Request_queryChange_DCPType_HTTP")
    }, read_Capability_Request_queryChange_DCPType_HTTP_Get: function (a, b) {
        var c = b.getAttribute("onlineResource");
        if (c) a.getUrl = c
    }, read_Capability_Request_queryChange_DCPType_HTTP_Post: function (a, b) {
        var c = b.getAttribute("onlineResource");
        if (c) a.postUrl = c
    }, read_Capability_Networks: function (a, b) {
        for (var c = b.getElementsByTagName("Name"), d = [], e = 0; e < c.length; e++) {
            var f = this.getChildValue(c[e]);
            f && d.push(f)
        }
        a.networks = d
    }, CLASS_NAME: "GeoGlobe.Format.BusCapabilities"
});
GeoGlobe.Format.XML2JSON = GeoGlobe.Class4OL({
    initialize: function () {
    }, read: function (a, b, c) {
        b || (b = "");
        a = a.replace(/\s*\/>/g, "/>");
        a = a.replace(/<\?[^>]*>/g, "").replace(/<\![^>]*>/g, "");
        b.sort || (b = b.split(","));
        for (var a = this.no_fast_endings(a), a = this.attris_to_tags(a), a = escape(a), a = a.split("%3C").join("<").split("%3E").join(">").split("%3D").join("=").split("%22").join('"'), d = 0; d < b.length; d++)a = a.replace(RegExp("<" + b[d] + ">", "g"), "*$**" + b[d] + "**$*"), a = a.replace(RegExp("</" + b[d] + ">", "g"), "*$***" + b[d] + "**$*");
        this.xmlobject = {};
        b = this.xml_to_object("<JSONTAGWRAPPER>" + a + "</JSONTAGWRAPPER>").JSONTAGWRAPPER;
        c && (b = this.show_json_structure(b, c));
        return b
    }, xml_to_object: function (a) {
        for (var b = a.replace(/<\//g, "?"), b = b.split("<"), a = [], c = 0, d = [], e = 1; e < b.length; e++) {
            var f = b[e].split(">")[0];
            d.push(f);
            c++;
            for (a.push(c + "<" + b[e].split("?")[0]); b[e].indexOf("?" + d[d.length - 1] + ">") >= 0;)c--, d.pop()
        }
        for (var g = -1, b = "this.xmlobject", e = 0; e < a.length; e++) {
            var c = "", d = a[e].split("<")[0], h = a[e].split("<")[1].split(">")[0], h = h.replace(/%3A/,
                "_"), f = a[e].split(">")[1];
            if (d <= g)for (var g = g - d + 1, j = 0; j < g; j++)b = b.substring(0, b.lastIndexOf("."));
            b += "." + h;
            g = b.substring(0, b.lastIndexOf("."));
            eval("typeof " + g) != "object" && (c += g + "={value:" + g + "};\n");
            j = b.substring(b.lastIndexOf(".") + 1);
            h = !1;
            for (k in eval(g))k == j && (h = !0);
            g = !0;
            for (j = 0; j < f.length; j += 3)f.charAt(j) != "%" && (g = !1);
            f != "" && !g ? f / 1 != f && (f = "'" + f.replace(/\'/g, "\\'") + "'", f = f.replace(/\*\$\*\*\*/g, "</"), f = f.replace(/\*\$\*\*/g, "<"), f = f.replace(/\*\*\$\*/g, ">")) : f = "{}";
            f.charAt(0) == "'" && (f = "unescape(" +
                f + ")");
            h && !eval(b + ".sort") && (c += b + "=[" + b + "];\n");
            g = "=";
            after = "";
            h && (g = ".push(", after = ")");
            eval(c + b + g + f + after);
            eval(b + ".sort") && (b += "[" + eval(b + ".length-1") + "]");
            g = d
        }
        return this.xmlobject
    }, show_json_structure: function (a, b, c) {
        var d = "";
        d += a.sort ? "[\n" : "{\n";
        for (var e in a)a.sort || (d += e + ":"), d += typeof a[e] == "object" ? this.show_json_structure(a[e], !1, 1) : typeof a[e] == "function" ? a[e] + "" : typeof a[e] != "string" ? a[e] + ",\n" : "'" + a[e].replace(/\'/g, "\\'").replace(/\n/g, "\\n").replace(/\t/g, "\\t").replace(/\r/g, "\\r") +
            "',\n";
        d += a.sort ? "],\n" : "},\n";
        if (!c) {
            d = d.substring(0, d.lastIndexOf(","));
            d = d.replace(RegExp(",\n}", "g"), "\n}");
            d = d.replace(RegExp(",\n]", "g"), "\n]");
            a = d.split("\n");
            d = "";
            for (e = c = 0; e < a.length; e++) {
                (a[e].indexOf("}") >= 0 || a[e].indexOf("]") >= 0) && c--;
                tabs = "";
                for (var f = 0; f < c; f++)tabs += "\t";
                d += tabs + a[e] + "\n";
                (a[e].indexOf("{") >= 0 || a[e].indexOf("[") >= 0) && c++
            }
            b == "html" && (d = d.replace(/</g, "&lt;").replace(/>/g, "&gt;"), d = d.replace(/\n/g, "<BR>").replace(/\t/g, "&nbsp;&nbsp;&nbsp;&nbsp;"));
            b == "compact" && (d = d.replace(/\n/g,
                "").replace(/\t/g, ""))
        }
        return d
    }, no_fast_endings: function (a) {
        for (var a = a.split("/>"), b = 1; b < a.length; b++) {
            var c = a[b - 1].substring(a[b - 1].lastIndexOf("<") + 1).split(" ")[0];
            a[b] = "></" + c + ">" + a[b]
        }
        return a = a.join("")
    }, attris_to_tags: function (a) {
        for (var b = " =\"'".split(""), a = a.split(">"), c = 0; c < a.length; c++) {
            for (var d = a[c].split("<"), e = 0; e < 4; e++)d[0] = d[0].replace(RegExp(b[e], "g"), "_jsonconvtemp" + e + "_");
            if (d[1]) {
                d[1] = d[1].replace(/'/g, '"');
                d[1] = d[1].split('"');
                for (var f = 1; f < d[1].length; f += 2)for (e = 0; e < 4; e++)d[1][f] =
                    d[1][f].replace(RegExp(b[e], "g"), "_jsonconvtemp" + e + "_");
                d[1] = d[1].join('"')
            }
            a[c] = d.join("<")
        }
        a = a.join(">");
        a = a.replace(/ ([^=]*)=([^ |>]*)/g, "><$1>$2</$1");
        a = a.replace(/>"/g, ">").replace(/"</g, "<");
        for (e = 0; e < 4; e++)a = a.replace(RegExp("_jsonconvtemp" + e + "_", "g"), b[e]);
        return a
    }, CLASS_NAME: "GeoGlobe.Format.XML2JSON"
});
GeoGlobe.Format.CSWGetRecords = function (a) {
    var a = GeoGlobe.Util.applyDefaults(a, GeoGlobe.Format.CSWGetRecords.DEFAULTS),
        b = GeoGlobe.Format.CSWGetRecords["v" + a.version.replace(/\./g, "_")];
    if (!b)throw"Unsupported CSWGetRecords version: " + a.version;
    return new b(a)
};
GeoGlobe.Format.CSWGetRecords.DEFAULTS = {version: "2.0.2"};
GeoGlobe.Format.CSWGetRecords.v2_0_2 = GeoGlobe.Class4OL(GeoGlobe.Format.XML, {
    namespaces: {
        csw: "http://www.opengis.net/cat/csw/2.0.2",
        dc: "http://purl.org/dc/elements/1.1/",
        dct: "http://purl.org/dc/terms/",
        gmd: "http://www.isotc211.org/2005/gmd",
        geonet: "http://www.fao.org/geonetwork",
        ogc: "http://www.opengis.net/ogc",
        ows: "http://www.opengis.net/ows",
        xlink: "http://www.w3.org/1999/xlink",
        xsi: "http://www.w3.org/2001/XMLSchema-instance"
    },
    defaultPrefix: "csw",
    version: "2.0.2",
    schemaLocation: "http://www.opengis.net/cat/csw/2.0.2 http://schemas.opengis.net/csw/2.0.2/CSW-discovery.xsd",
    requestId: null,
    resultType: null,
    outputFormat: null,
    outputSchema: null,
    startPosition: null,
    maxRecords: null,
    DistributedSearch: null,
    ResponseHandler: null,
    Query: null,
    regExes: {trimSpace: /^\s*|\s*$/g, removeSpace: /\s*/g, splitSpace: /\s+/, trimComma: /\s*,\s*/g},
    initialize: function (a) {
        GeoGlobe.Format.XML.prototype.initialize.apply(this, [a])
    },
    read: function (a) {
        typeof a == "string" && (a = GeoGlobe.Format.XML.prototype.read.apply(this, [a]));
        if (a && a.nodeType == 9) a = a.documentElement;
        var b = {};
        this.readNode(a, b);
        return b
    },
    readers: {
        csw: {
            GetRecordsResponse: function (a,
                                          b) {
                b.records = [];
                this.readChildNodes(a, b);
                var c = this.getAttributeNS(a, "", "version");
                if (c != "") b.version = c
            }, RequestId: function (a, b) {
                b.RequestId = this.getChildValue(a)
            }, SearchStatus: function (a, b) {
                b.SearchStatus = {};
                var c = this.getAttributeNS(a, "", "timestamp");
                if (c != "") b.SearchStatus.timestamp = c
            }, SearchResults: function (a, b) {
                this.readChildNodes(a, b);
                for (var c = a.attributes, d = {}, e = 0, f = c.length; e < f; ++e)d[c[e].name] = c[e].name == "numberOfRecordsMatched" || c[e].name == "numberOfRecordsReturned" || c[e].name == "nextRecord" ?
                    parseInt(c[e].nodeValue) : c[e].nodeValue;
                b.SearchResults = d
            }, SummaryRecord: function (a, b) {
                var c = {type: "SummaryRecord"};
                this.readChildNodes(a, c);
                b.records.push(c)
            }, BriefRecord: function (a, b) {
                var c = {type: "BriefRecord"};
                this.readChildNodes(a, c);
                b.records.push(c)
            }, DCMIRecord: function (a, b) {
                var c = {type: "DCMIRecord"};
                this.readChildNodes(a, c);
                b.records.push(c)
            }, Record: function (a, b) {
                var c = {type: "Record"};
                this.readChildNodes(a, c);
                b.records.push(c)
            }, "*": function (a, b) {
                var c = a.localName || a.nodeName.split(":").pop();
                b[c] = this.getChildValue(a)
            }
        }, geonet: {
            info: function (a, b) {
                var c = {};
                this.readChildNodes(a, c);
                b.gninfo = c
            }
        }, dc: {
            "*": function (a, b) {
                var c = a.localName || a.nodeName.split(":").pop();
                GeoGlobe.Util.isArray(b[c]) || (b[c] = []);
                for (var d = {}, e = a.attributes, f = 0, g = e.length; f < g; ++f)d[e[f].name] = e[f].nodeValue;
                d.value = this.getChildValue(a);
                d.value != "" && b[c].push(d)
            }
        }, dct: {
            "*": function (a, b) {
                var c = a.localName || a.nodeName.split(":").pop();
                GeoGlobe.Util.isArray(b[c]) || (b[c] = []);
                b[c].push(this.getChildValue(a))
            }
        }, ows: GeoGlobe.Util.applyDefaults({
            BoundingBox: function (a,
                                   b) {
                if (b.bounds) b.BoundingBox = [{
                    crs: b.projection,
                    value: [b.bounds._sw.lng, b.bounds._sw.lat, b.bounds._ne.lng, b.bounds._ne.lat]
                }], delete b.projection, delete b.bounds;
                GeoGlobe.Format.OWSCommon.v1_0_0.prototype.readers.ows.BoundingBox.apply(this, arguments)
            }
        }, GeoGlobe.Format.OWSCommon.v1_0_0.prototype.readers.ows)
    },
    write: function (a) {
        a = this.writeNode("csw:GetRecords", a);
        a.setAttribute("xmlns:gmd", this.namespaces.gmd);
        return GeoGlobe.Format.XML.prototype.write.apply(this, [a])
    },
    writers: {
        csw: {
            GetRecords: function (a) {
                a ||
                (a = {});
                var b = this.createElementNSPlus("csw:GetRecords", {
                    attributes: {
                        service: "CSW",
                        version: this.version,
                        requestId: a.requestId || this.requestId,
                        resultType: a.resultType || this.resultType,
                        outputFormat: a.outputFormat || this.outputFormat,
                        outputSchema: a.outputSchema || this.outputSchema,
                        startPosition: a.startPosition || this.startPosition,
                        maxRecords: a.maxRecords || this.maxRecords
                    }
                });
                if (a.DistributedSearch || this.DistributedSearch) this.writeNode("csw:DistributedSearch", a.DistributedSearch || this.DistributedSearch, b);
                var c = a.ResponseHandler || this.ResponseHandler;
                if (GeoGlobe.Util.isArray(c) && c.length > 0)for (var d = 0, e = c.length; d < e; d++)this.writeNode("csw:ResponseHandler", c[d], b);
                this.writeNode("Query", a.Query || this.Query, b);
                return b
            }, DistributedSearch: function (a) {
                return this.createElementNSPlus("csw:DistributedSearch", {attributes: {hopCount: a.hopCount}})
            }, ResponseHandler: function (a) {
                return this.createElementNSPlus("csw:ResponseHandler", {value: a.value})
            }, Query: function (a) {
                a || (a = {});
                var b = this.createElementNSPlus("csw:Query",
                    {attributes: {typeNames: a.typeNames || "csw:Record"}}), c = a.ElementName;
                if (GeoGlobe.Util.isArray(c) && c.length > 0)for (var d = 0, e = c.length; d < e; d++)this.writeNode("csw:ElementName", c[d], b); else this.writeNode("csw:ElementSetName", a.ElementSetName || {value: "summary"}, b);
                a.Constraint && this.writeNode("csw:Constraint", a.Constraint, b);
                a.SortBy && this.writeNode("ogc:SortBy", a.SortBy, b);
                return b
            }, ElementName: function (a) {
                return this.createElementNSPlus("csw:ElementName", {value: a.value})
            }, ElementSetName: function (a) {
                return this.createElementNSPlus("csw:ElementSetName",
                    {attributes: {typeNames: a.typeNames}, value: a.value})
            }, Constraint: function (a) {
                var b = this.createElementNSPlus("csw:Constraint", {attributes: {version: a.version}});
                if (a.Filter) {
                    var c = new GeoGlobe.Format.Filter({version: a.version});
                    b.appendChild(c.write(a.Filter))
                } else a.CqlText && (a = this.createElementNSPlus("CqlText", {value: a.CqlText.value}), b.appendChild(a));
                return b
            }
        }, ogc: GeoGlobe.Format.Filter.v1_1_0.prototype.writers.ogc
    },
    CLASS_NAME: "GeoGlobe.Format.CSWGetRecords.v2_0_2"
});
(function (a, b) {
    a.GeoGlobe.Format.X2JS = b();
    a.GeoGlobe.Format.X2JS.CLASS_NAME = "GeoGlobe.Format.X2JS"
})(this, function () {
    return function (a) {
        function b(a) {
            var b = a.localName;
            if (b == null) b = a.baseName;
            if (b == null || b == "") b = a.nodeName;
            return b
        }

        function c(a) {
            return typeof a == "string" ? a.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;") : a
        }

        function d(a, b, c, d) {
            for (var e = 0; e < a.length; e++) {
                var f = a[e];
                if (typeof f === "string") {
                    if (f == d)break
                } else if (f instanceof
                    RegExp) {
                    if (f.test(d))break
                } else if (typeof f === "function" && f(b, c, d))break
            }
            return e != a.length
        }

        function e(b, c, e) {
            switch (a.arrayAccessForm) {
                case "property":
                    b[c + "_asArray"] = b[c] instanceof Array ? b[c] : [b[c]]
            }
            !(b[c] instanceof Array) && a.arrayAccessFormPaths.length > 0 && d(a.arrayAccessFormPaths, b, c, e) && (b[c] = [b[c]])
        }

        function f(a) {
            var b = a.split(/[-T:+Z]/g), c = new Date(b[0], b[1] - 1, b[2]), d = b[5].split(".");
            c.setHours(b[3], b[4], d[0]);
            d.length > 1 && c.setMilliseconds(d[1]);
            b[6] && b[7] ? (b = b[6] * 60 + Number(b[7]), b = 0 + ((/\d\d-\d\d:\d\d$/.test(a) ?
                    "-" : "+") == "-" ? -1 * b : b), c.setMinutes(c.getMinutes() - b - c.getTimezoneOffset())) : a.indexOf("Z", a.length - 1) !== -1 && (c = new Date(Date.UTC(c.getFullYear(), c.getMonth(), c.getDate(), c.getHours(), c.getMinutes(), c.getSeconds(), c.getMilliseconds())));
            return c
        }

        function g(b, c, e) {
            return a.datetimeAccessFormPaths.length > 0 ? (e = e.split(".#")[0], d(a.datetimeAccessFormPaths, b, c, e) ? f(b) : b) : b
        }

        function h(c, f) {
            if (c.nodeType == s.DOCUMENT_NODE) {
                for (var j = {}, l = c.childNodes, m = 0; m < l.length; m++) {
                    var n = l.item(m);
                    if (n.nodeType == s.ELEMENT_NODE) {
                        var o =
                            b(n);
                        j[o] = h(n, o)
                    }
                }
                return j
            } else if (c.nodeType == s.ELEMENT_NODE) {
                j = {};
                j.__cnt = 0;
                l = c.childNodes;
                for (m = 0; m < l.length; m++)if (n = l.item(m), o = b(n), n.nodeType != s.COMMENT_NODE) {
                    var p = f + "." + o;
                    if (n.nodeType == s.ELEMENT_NODE && a.xmlElementsFilter.length > 0 ? d(a.xmlElementsFilter, j, o, p) : 1) j.__cnt++, j[o] == null ? (j[o] = h(n, p), e(j, o, p)) : (j[o] != null && !(j[o] instanceof Array) && (j[o] = [j[o]], e(j, o, p)), j[o][j[o].length] = h(n, p))
                }
                for (l = 0; l < c.attributes.length; l++)m = c.attributes.item(l), j.__cnt++, j[a.attributePrefix + m.name] = m.value;
                l = c.prefix;
                if (l != null && l != "") j.__cnt++, j.__prefix = l;
                if (j["#text"] != null) {
                    j.__text = j["#text"];
                    if (j.__text instanceof Array) j.__text = j.__text.join("\n");
                    if (a.stripWhitespaces) j.__text = j.__text.trim();
                    delete j["#text"];
                    a.arrayAccessForm == "property" && delete j["#text_asArray"];
                    j.__text = g(j.__text, o, f + "." + o)
                }
                if (j["#cdata-section"] != null) j.__cdata = j["#cdata-section"], delete j["#cdata-section"], a.arrayAccessForm == "property" && delete j["#cdata-section_asArray"];
                j.__cnt == 0 && a.emptyNodeForm == "text" ? j = "" : j.__cnt ==
                1 && j.__text != null ? j = j.__text : j.__cnt == 1 && j.__cdata != null && !a.keepCData ? j = j.__cdata : j.__cnt > 1 && j.__text != null && a.skipEmptyTextNodesForObj && (a.stripWhitespaces && j.__text == "" || j.__text.trim() == "") && delete j.__text;
                delete j.__cnt;
                if (a.enableToStringFunc && (j.__text != null || j.__cdata != null)) j.toString = function () {
                    return (this.__text != null ? this.__text : "") + (this.__cdata != null ? this.__cdata : "")
                };
                return j
            } else if (c.nodeType == s.TEXT_NODE || c.nodeType == s.CDATA_SECTION_NODE)return c.nodeValue
        }

        function j(b, d, e, f) {
            d =
                "<" + (b != null && b.__prefix != null ? b.__prefix + ":" : "") + d;
            if (e != null)for (var g = 0; g < e.length; g++) {
                var h = e[g], j = b[h];
                a.escapeMode && (j = c(j));
                d += " " + h.substr(a.attributePrefix.length) + "=";
                d += a.useDoubleQuotes ? '"' + j + '"' : "'" + j + "'"
            }
            d += f ? "/>" : ">";
            return d
        }

        function l(a, b) {
            return "</" + (a.__prefix != null ? a.__prefix + ":" : "") + b + ">"
        }

        function m(b, c) {
            return a.arrayAccessForm == "property" && c.toString().indexOf("_asArray", c.toString().length - 8) !== -1 || c.toString().indexOf(a.attributePrefix) == 0 || c.toString().indexOf("__") == 0 ||
            b[c] instanceof Function ? !0 : !1
        }

        function n(a) {
            var b = 0;
            if (a instanceof Object)for (var c in a)m(a, c) || b++;
            return b
        }

        function p(b) {
            var c = [];
            if (b instanceof Object)for (var d in b)d.toString().indexOf("__") == -1 && d.toString().indexOf(a.attributePrefix) == 0 && c.push(d);
            return c
        }

        function q(b) {
            var d = "";
            if (b instanceof Object) {
                var e = "";
                b.__cdata != null && (e += "<![CDATA[" + b.__cdata + "]]\>");
                b.__text != null && (e += a.escapeMode ? c(b.__text) : b.__text);
                d += e
            } else b != null && (d += a.escapeMode ? c(b) : b);
            return d
        }

        function o(b, c) {
            var e =
                "";
            if (n(b) > 0)for (var f in b) {
                var g;
                if (!(g = m(b, f)))if (g = c != "") g = c === "" ? f : c + "." + f, g = !(a.jsonPropertiesFilter.length == 0 || g == "" || d(a.jsonPropertiesFilter, b, f, g));
                if (!g) {
                    var h = b[f];
                    g = p(h);
                    if (h == null || h == void 0) e += j(h, f, g, !0); else if (h instanceof Object)if (h instanceof Array) {
                        var s = f, x = c, w = "";
                        if (h.length == 0) w += j(h, s, g, !0); else for (g = 0; g < h.length; g++)w += j(h[g], s, p(h[g]), !1), w += o(h[g], x === "" ? s : x + "." + s), w += l(h[g], s);
                        e += w
                    } else h instanceof Date ? (e += j(h, f, g, !1), e += h.toISOString(), e += l(h, f)) : n(h) > 0 || h.__text !=
                    null || h.__cdata != null ? (e += j(h, f, g, !1), e += o(h, c === "" ? f : c + "." + f), e += l(h, f)) : e += j(h, f, g, !0); else e += j(h, f, g, !1), e += q(h), e += l(h, f)
                }
            }
            e += q(b);
            return e
        }

        a = a || {};
        if (a.escapeMode === void 0) a.escapeMode = !0;
        a.attributePrefix = a.attributePrefix || "_";
        a.arrayAccessForm = a.arrayAccessForm || "none";
        a.emptyNodeForm = a.emptyNodeForm || "text";
        if (a.enableToStringFunc === void 0) a.enableToStringFunc = !0;
        a.arrayAccessFormPaths = a.arrayAccessFormPaths || [];
        if (a.skipEmptyTextNodesForObj === void 0) a.skipEmptyTextNodesForObj = !0;
        if (a.stripWhitespaces ===
            void 0) a.stripWhitespaces = !0;
        a.datetimeAccessFormPaths = a.datetimeAccessFormPaths || [];
        if (a.useDoubleQuotes === void 0) a.useDoubleQuotes = !1;
        a.xmlElementsFilter = a.xmlElementsFilter || [];
        a.jsonPropertiesFilter = a.jsonPropertiesFilter || [];
        if (a.keepCData === void 0) a.keepCData = !1;
        var s = {ELEMENT_NODE: 1, TEXT_NODE: 3, CDATA_SECTION_NODE: 4, COMMENT_NODE: 8, DOCUMENT_NODE: 9};
        this.parseXmlString = function (a) {
            var b = window.ActiveXObject || "ActiveXObject" in window;
            if (a === void 0)return null;
            var c;
            if (window.DOMParser) {
                var d = new window.DOMParser,
                    e = null;
                if (!b)try {
                    e = d.parseFromString("INVALID", "text/xml").getElementsByTagName("parsererror")[0].namespaceURI
                } catch (f) {
                    e = null
                }
                try {
                    c = d.parseFromString(a, "text/xml"), e != null && c.getElementsByTagNameNS(e, "parsererror").length > 0 && (c = null)
                } catch (g) {
                    c = null
                }
            } else a.indexOf("<?") == 0 && (a = a.substr(a.indexOf("?>") + 2)), c = new ActiveXObject("Microsoft.XMLDOM"), c.async = "false", c.loadXML(a);
            return c
        };
        this.asArray = function (a) {
            return a === void 0 || a == null ? [] : a instanceof Array ? a : [a]
        };
        this.toXmlDateTime = function (a) {
            return a instanceof
            Date ? a.toISOString() : typeof a === "number" ? (new Date(a)).toISOString() : null
        };
        this.asDateTime = function (a) {
            return typeof a == "string" ? f(a) : a
        };
        this.xml2json = function (a) {
            return h(a)
        };
        this.xml_str2json = function (a) {
            a = this.parseXmlString(a);
            return a != null ? this.xml2json(a) : null
        };
        this.json2xml_str = function (a) {
            return o(a, "")
        };
        this.json2xml = function (a) {
            return this.parseXmlString(this.json2xml_str(a))
        };
        this.getVersion = function () {
            return "1.2.0"
        }
    }
});
GeoGlobe.Analysis.BufferAnalysis = GeoGlobe.Class4OL({
    url: null, type: 1, accuracy: 32, initialize: function (a, b) {
        this.url = a;
        GeoGlobe.Util.extend(this, b)
    }, _buildPostXML: function (a, b) {
        return '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><wps:Execute service="WPS" version="1.0.0" xmlns:gml="http://www.opengis.net/gml" xmlns:wps="http://www.opengis.net/wps/1.0.0" xmlns:ows="http://www.opengis.net/ows/1.1" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.opengis.net/wps/1.0.0 ../wpsExecute_request.xsd"><ows:Identifier>Buffer</ows:Identifier><wps:DataInputs><wps:Input><ows:Identifier>InputPolygon</ows:Identifier><wps:Data><wps:ComplexData schema="http://foo.bar/MyComplexValueSchema.xsd" mimeType="text/xml" encoding="UTF-8">' +
            (new GeoGlobe.Format.GML).write(a) + "</wps:ComplexData></wps:Data></wps:Input><wps:Input><ows:Identifier>BufferDistance</ows:Identifier><wps:Data><wps:LiteralData>" + b + "</wps:LiteralData></wps:Data></wps:Input><wps:Input><ows:Identifier>BufferType</ows:Identifier><wps:Data><wps:LiteralData>" + this.type + "</wps:LiteralData></wps:Data></wps:Input><wps:Input><ows:Identifier>BufferAccuracy</ows:Identifier><wps:Data><wps:LiteralData>" + this.accuracy + "</wps:LiteralData></wps:Data></wps:Input></wps:DataInputs><wps:ResponseForm><wps:RawDataOutput><ows:Identifier>BufferedPolygon</ows:Identifier></wps:RawDataOutput></wps:ResponseForm></wps:Execute>"
    },
    _getFeaturesCenter: function (a) {
        return this._getFeaturesExtent(a).getCenterLonLat()
    }, _getFeaturesExtent: function (a) {
        GeoGlobe.Util.isArray(a) || (a = [a]);
        var b = null;
        if (a && a.length > 0)for (var b = new GeoGlobe.LngLatBounds, c = null, d = 0, e = a.length; d < e; d++)(c = a[d].geometry) && b.extend(c.getBounds());
        return b
    }, startAnalysis: function (a, b, c) {
        var d = ["m", "km", "degree"], a = (new GeoGlobe.Format.GeoJSON).read(a), e = this._getFeaturesCenter(a);
        if (!c || GeoGlobe.Util.indexOf(d, c) == -1) c = "m";
        switch (c) {
            case "km":
                b *= 1E3;
            case "m":
                b =
                    this._meterToDegree(b, e)
        }
        b = this._buildPostXML(a, b);
        new GeoGlobe.Request.POST({
            url: this.url, data: b, scope: this, success: function (a) {
                "" == a.responseText || null == a.responseText ? this.failFn() : (a = this._parserResult(a), a = (new GeoGlobe.Format.GeoJSON).write(a), this.successFn((new GeoGlobe.Format.JSON).read(a)))
            }, failure: this.failFn
        })
    }, _meterToDegree: function (a, b) {
        return a * (8.99E-6 / Math.cos(GeoGlobe.Util.rad(b.lat)))
    }, successFn: function () {
    }, failFn: function () {
        alert("\u7f13\u51b2\u5206\u6790\u64cd\u4f5c\u5931\u8d25\uff0c\u8bf7\u68c0\u6d4b\u670d\u52a1\u662f\u5426\u6b63\u5e38\u8fd0\u884c\u3002")
    },
    _parserResult: function (a) {
        var b = null, b = new GeoGlobe.Format.XML;
        if (!a.responseXML) a.responseXML = b.read(a.responseText);
        return b = (new GeoGlobe.Format.GML).read(a.responseXML)
    }, CLASS_NAME: "GeoGlobe.Analysis.BufferAnalysis"
});
GeoGlobe.Analysis.BufferAnalysis.CAP_ROUND = 1;
GeoGlobe.Analysis.BufferAnalysis.CAP_BUTT = 2;
GeoGlobe.Analysis.BufferAnalysis.CAP_SQUARE = 3;
GeoGlobe.Analysis.GetFeature = GeoGlobe.Class4OL({
    url: null,
    type: "intersection",
    _reqStrTemplate: "{'GetFeature': {'service': 'OverlapService','version': '1.0.0','dataSource':'${sourceInputs}','Query': [{'typeName':'${dataInputs}'}],'maxFeatures': '','startPosition': '','outPutFormat': 'GeoJSON','resultType': ''}}",
    initialize: function (a, b) {
        this.url = a;
        GeoGlobe.Util.extend(this, b)
    },
    _buildReqStr: function () {
        return GeoGlobe.String.format(this._reqStrTemplate, {
            type: this.type,
            dataInputs: this.typeName,
            sourceInputs: this.DataSource
        })
    },
    startAnalysis: function () {
        if (this._checkSet())return !1;
        var a = this._buildReqStr();
        new GeoGlobe.Request.POST({
            url: this.url, data: a, scope: this, success: function (a) {
                "" == a.responseText || null == a.responseText ? this.failFn() : this.successFn(a)
            }, failure: this.failFn
        })
    },
    _checkSet: function () {
        if (!this.url)return !1
    },
    successFn: function () {
    },
    failFn: function () {
        alert("\u670d\u52a1\u8bf7\u6c42\u64cd\u4f5c\u5931\u8d25\uff0c\u8bf7\u68c0\u6d4b\u670d\u52a1\u662f\u5426\u6b63\u5e38\u8fd0\u884c\u3002")
    },
    CLASS_NAME: "GeoGlobe.Analysis.GetFeature"
});
GeoGlobe.Analysis.SpatialAnalysis = GeoGlobe.Class({
    url: null,
    type: "intersection",
    _requestStrTemplate: "{'SpatialAnalysis': {'service': 'OverlapService','version': '1.0.0','origionLayerNames': ['${origionLayerNames}'],'targetLayerNames': ['${targetLayerNames}'],'outPutFormat': 'GeoJSON','operator': '${dataInputs}','isSynchronization': 'true','tolerance': '${tolerance}'}}",
    initialize: function (a, b) {
        this.url = a;
        GeoGlobe.Util.extend(this, b)
    },
    _buildRequestStr: function () {
        return GeoGlobe.String.format(this._requestStrTemplate,
            {
                type: this.type,
                dataInputs: this.operator,
                origionLayerNames: this.origionLayerNames,
                targetLayerNames: this.targetLayerNames,
                tolerance: this.tolerance
            })
    },
    startAnalysis: function (a) {
        if (this._checkSet())return !1;
        var b = this._buildRequestStr();
        new GeoGlobe.Request.POST({
            url: this.url, data: b, scope: this, success: function (b) {
                "" == b.responseText || null == b.responseText ? this.failFn() : this.successFn(b, a)
            }, failure: this.failFn
        })
    },
    _checkSet: function () {
        if (!this.url)return !1
    },
    successFn: function () {
    },
    failFn: function () {
        alert("\u53e0\u7f6e\u5206\u6790\u64cd\u4f5c\u5931\u8d25\uff0c\u8bf7\u68c0\u6d4b\u670d\u52a1\u662f\u5426\u6b63\u5e38\u8fd0\u884c\u3002")
    },
    CLASS_NAME: "GeoGlobe.Analysis.SpatialAnalysis"
});
GeoGlobe.Analysis.CoreBufferAnalysis = GeoGlobe.Class({
    url: null,
    type: "intersection",
    _requestStrTemplate: "{'BufferAnalysis': {'service': 'OverlapService','version': '1.0.0','layerName': '${layerName}','bufferRadius': '${bufferRadius}','bufferStyle':'${bufferStyle}','outPutFormat': 'JSON','bufferType': '${bufferType}','isSynchronization': 'true'}}",
    initialize: function (a, b) {
        this.url = a;
        GeoGlobe.Util.extend(this, b)
    },
    _buildRequestStr: function () {
        return GeoGlobe.String.format(this._requestStrTemplate, {
            type: this.type,
            layerName: this.layerName,
            bufferRadius: this.bufferRadius,
            bufferStyle: this.bufferStyle,
            bufferType: this.bufferType
        })
    },
    startAnalysis: function (a) {
        if (this._checkSet())return !1;
        var b = this._buildRequestStr();
        new GeoGlobe.Request.POST({
            url: this.url, data: b, scope: this, success: function (b) {
                "" == b.responseText || null == b.responseText ? this.failFn() : this.successFn(b, a)
            }, failure: this.failFn
        })
    },
    _checkSet: function () {
        if (!this.url)return !1
    },
    successFn: function () {
    },
    failFn: function () {
        alert("\u7f13\u51b2\u5206\u6790\u64cd\u4f5c\u5931\u8d25\uff0c\u8bf7\u68c0\u6d4b\u670d\u52a1\u662f\u5426\u6b63\u5e38\u8fd0\u884c")
    },
    CLASS_NAME: "GeoGlobe.Analysis.CoreBufferAnalysis"
});
GeoGlobe.Query.Service = GeoGlobe.Class4OL({
    name: null, url: null, version: null, userid: "test@liferay.com", initialize: function (a, b, c) {
        this.name = a;
        this.url = b;
        GeoGlobe.Util.extend(this, c)
    }, getCapabilities: function () {
    }, isExist: function () {
    }, failFn: function (a) {
        alert("\u670d\u52a1\u8bf7\u6c42\u5931\u8d25\uff0c\u8bf7\u68c0\u67e5\u670d\u52a1\u662f\u5426\u6b63\u5e38\u8fd0\u884c\u6216\u8bf7\u6c42\u5730\u5740\u662f\u5426\u6b63\u786e\u3002\n\u8bf7\u6c42\u5730\u5740\uff1a" + this.url + "\n\u64cd\u4f5c\u7c7b\u578b\uff1a" +
            a)
    }, _parseToXML: function (a) {
        var b = a.responseXML;
        if (!b || !b.documentElement) b = a.responseText;
        return (new GeoGlobe.Format.XML).read(b)
    }, _checkIsError: function (a) {
        if ((new GeoGlobe.Format.XML).read(a).selectNodes("ServiceExceptionReport").length > 0)return this._parseToJSON(a);
        return null
    }, _isException: function (a) {
        if (a && a.ServiceExceptionReport)return !0;
        return !1
    }, _parseToJSON: function (a) {
        return (new GeoGlobe.Util.Format.XML2JSON).read(a)
    }, CLASS_NAME: "GeoGlobe.Query.Service"
});
GeoGlobe.Query.RouteQuery = GeoGlobe.Class4OL(GeoGlobe.Query.Service, {
    _format: null, initialize: function (a, b, c) {
        this.name = a;
        this.url = b;
        this._format = new GeoGlobe.Format.RouteQuery;
        GeoGlobe.Util.extend(this, c)
    }, getCapabilities: function (a, b) {
        GeoGlobe.loadURL(this.url, {REQUEST: "GetCapabilities"}, this, a, b)
    }, findRoute: function (a, b, c) {
        var d = {REQUEST: "FindRoute", SERVICE: "ROUTE", VERSION: "1.0.0"}, e = {data: !0, orig: !0, dest: !0}, f;
        for (f in e)if (!(f in a))throw Error("Missing property '" + f + "'");
        d.DATA = a.data;
        d.ORIG =
            a.orig;
        d.DEST = a.dest;
        if (a.service !== null && a.service !== void 0) d.SERVICE = a.service;
        if (a.version !== null && a.version !== void 0) d.VERSION = a.version;
        if (a.radius !== null && a.radius !== void 0) d.RADIUS = a.radius;
        if (a.queryType !== null && a.queryType !== void 0) d.QUERYTYPE = a.queryType;
        if (a.midpos !== null && a.midpos !== void 0) d.MIDPOS = a.midpos;
        if (a.avoidPos !== null && a.avoidPos !== void 0) d.AVOIDPOS = a.avoidPos;
        if (a.filterRoute !== null && a.filterRoute !== void 0) d.FILTERROUTE = a.filterRoute;
        if (a.resultCount !== null && a.resultCount !==
            void 0) d.RESULTCOUNT = a.resultCount;
        GeoGlobe.Request.GET({
            url: this.url, params: d, async: !1, scope: this, success: function (a) {
                a = this._format.read(a.responseText);
                if (typeof a.exceptionInfo !== "string") {
                    var a = new GeoGlobe.Query.RoutesResult(a), c = a.routes,
                        c = (new GeoGlobe.Format.GeoJSON).write(c);
                    geojsonRoute = (new GeoGlobe.Format.JSON).read(c);
                    a.geojsonRoute = geojsonRoute
                }
                b(a)
            }, failure: c
        })
    }, getRouteInfo: function (a, b, c) {
        var d = {REQUEST: "GetRouteInfo", SERVICE: "ROUTE", VERSION: "1.0.0"};
        if (!a.data || !a.id)throw"Error!Not data and id for bus query.";
        d.DATA = a.data;
        d.ID = a.id;
        GeoGlobe.Request.GET({
            url: this.url, params: d, scope: this, success: function (a) {
                a = this._format.read(a.responseText);
                typeof a.exceptionInfo !== "string" && (a = new GeoGlobe.Query.RouteInfoResult(a));
                b(a)
            }, failure: c
        })
    }, CLASS_NAME: "GeoGlobe.Query.RouteQuery"
});
GeoGlobe.Format.RouteQuery = new GeoGlobe.Class4OL(GeoGlobe.Format.XML, {
    initialize: function (a) {
        GeoGlobe.Format.XML.prototype.initialize.apply(this, [a])
    }, read: function (a) {
        var b = {}, c = [];
        typeof a == "string" && (a = GeoGlobe.Format.XML.prototype.read.apply(this, [a]));
        if (a && a.nodeType == 9) {
            var c = [], d = GeoGlobe.Format.XML.prototype.getChildEl.apply(this, [a]).nodeName;
            if ("ServiceExceptionReport" === d)return c = GeoGlobe.Format.XML.prototype.getElementsByTagNameNS(a, "*", "ServiceException")[0], b = GeoGlobe.Format.XML.prototype.getChildValue.apply(this,
                [c]), c = c.getAttribute("code"), {exceptionInfo: b, exceptionCode: c};
            for (var a = a.getElementsByTagName(d)[0].childNodes, e = 0; e < a.length; e++) {
                var f = a[e], g = f.nodeName;
                this._resultPaser[d][g] && this._resultPaser[d][g].apply(this, [f, c])
            }
        }
        d = d.toLowerCase();
        "routeinfo" === d ? b.items = c : b[d] = c;
        return b
    }, _resultPaser: {
        RouteInfo: {
            Item: function (a, b) {
                var c = a.childNodes, d = a.getAttribute("id"), e = {};
                d && (e = {id: d});
                for (d = 0; d < c.length; d++) {
                    var a = c[d], f = a.nodeName;
                    this._resultPaser.RouteInfo[f] && this._resultPaser.RouteInfo[f].apply(this,
                        [a, e])
                }
                b.push(e)
            }, Name: function (a, b) {
                var c = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [a]);
                if (c) b.name = c
            }, Toll: function (a, b) {
                var c = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [a]);
                b.toll = c
            }, Level: function (a, b) {
                var c = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [a]);
                b.level = c
            }, Length: function (a, b) {
                var c = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [a]);
                b.length = c
            }, Geometry: function (a, b) {
                var c = GeoGlobe.Format.XML.prototype.getElementsByTagNameNS(a, "*", "LineString")[0];
                if (c && (c = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [c]), typeof c === "string" && c.length > 0)) {
                    for (var c = c.split(" "), d = [], e = 0, f = c.length; e < f; e++) {
                        var g = c[e].split(",");
                        d.push(new GeoGlobe.Geometry.Point(new Number(g[0]), new Number(g[1])))
                    }
                    c = new GeoGlobe.Geometry.LineString(d);
                    b.geometry = c
                }
            }, Directions: function (a, b) {
                b.directions = [];
                for (var c = a.childNodes, d = 0; d < c.length; d++) {
                    var a = c[d], e = a.nodeName;
                    if (this._resultPaser.RouteInfo[e]) this._resultPaser.RouteInfo[e](a, b.directions)
                }
            }, Direction: function (a,
                                    b) {
                var c = {}, d = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [a]);
                c.direction = d;
                c.nextID = a.getAttribute("nextID");
                c.nextItem = a.getAttribute("nextItem");
                b.push(c)
            }
        }, Routes: {
            Route: function (a, b) {
                for (var c = a.childNodes, d = {}, e = 0; e < c.length; e++) {
                    var a = c[e], f = a.nodeName;
                    this._resultPaser.Routes[f] && this._resultPaser.Routes[f].apply(this, [a, d])
                }
                b.push(d)
            }, Item: function (a, b) {
                if (!GeoGlobe.Util.isArray(b.items)) b.items = [];
                var c = a.childNodes, d = a.getAttribute("id"), e = {};
                d && (e = {id: d});
                for (d = 0; d < c.length; d++) {
                    var a =
                        c[d], f = a.nodeName;
                    this._resultPaser.Routes[f] && this._resultPaser.Routes[f].apply(this, [a, e])
                }
                b.items.push(e)
            }, Distance: function (a, b) {
                var c = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [a]);
                b.distance = c
            }, Name: function (a, b) {
                var c = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [a]);
                if (c) b.name = c
            }, Length: function (a, b) {
                var c = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [a]);
                b.length = c
            }, Direction: function (a, b) {
                var c = {}, d = GeoGlobe.Format.XML.prototype.getChildValue.apply(this,
                    [a]);
                c.direction = d;
                c.nextID = a.getAttribute("nextID");
                c.nextItem = a.getAttribute("nextItem");
                b.direction = c
            }, Geometry: function (a, b) {
                var c = GeoGlobe.Format.XML.prototype.getElementsByTagNameNS(a, "*", "LineString")[0];
                if (c && (c = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [c]), typeof c === "string" && c.length > 0)) {
                    for (var c = c.split(" "), d = [], e = 0, f = c.length; e < f; e++) {
                        var g = c[e].split(",");
                        d.push(new GeoGlobe.Geometry.Point(new Number(g[0]), new Number(g[1])))
                    }
                    c = new GeoGlobe.Geometry.LineString(d);
                    b.geometry =
                        c
                }
            }, Duration: function (a, b) {
                var c = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [a]);
                b.duration = c
            }, BoundingBox: function (a, b) {
                for (var c = a.childNodes, d = 0; d < c.length; d++) {
                    var a = c[d], e = a.nodeName;
                    this._resultPaser.Routes[e] && this._resultPaser.Routes[e].apply(this, [a, b])
                }
            }, LowerCorner: function (a, b) {
                var c = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [a]).replace(/^\s*|\s*$/g, ""),
                    c = c.replace(/\s*,\s*/g, ","), c = c.split(",");
                b.left = c[0];
                b.bottom = c[1]
            }, UpperCorner: function (a, b) {
                var c = GeoGlobe.Format.XML.prototype.getChildValue.apply(this,
                    [a]).replace(/^\s*|\s*$/g, ""), c = c.replace(/\s*,\s*/g, ","), c = c.split(",");
                b.right = c[0];
                b.top = c[1];
                b.bounds = new GeoGlobe.LngLatBounds(new GeoGlobe.LngLat(b.left, b.bottom), new GeoGlobe.LngLat(b.right, b.top));
                delete b.left;
                delete b.bottom;
                delete b.right;
                delete b.top
            }, Count: function (a, b) {
                var c = GeoGlobe.Format.XML.prototype.getChildValue.apply(this, [a]);
                b.count = c
            }
        }
    }
});
GeoGlobe.Query.RoutesResult = GeoGlobe.Class4OL({
    data: null, routes: null, initialize: function (a) {
        this.routes = [];
        var b = null;
        if (a && a.routes) this.data = a, b = a.routes;
        if (GeoGlobe.Util.isArray(b))for (var a = 0, c = b.length; a < c; a++) {
            var d = new GeoGlobe.Query.RouteResult, e;
            for (e in b[a])d[e] = b[a][e];
            this.routes.push(d)
        }
    }, CLASS_NAME: "GeoGlobe.Query.RoutesResult"
});
GeoGlobe.Query.RouteResult = GeoGlobe.Class4OL({
    bounds: null,
    count: null,
    distance: null,
    duration: null,
    geometry: null,
    items: null,
    initialize: function () {
    },
    CLASS_NAME: "GeoGlobe.Query.RouteResult"
});
GeoGlobe.Query.RouteInfoResult = GeoGlobe.Class4OL({
    data: null, items: null, initialize: function (a) {
        this.items = [];
        if (a && a.items) {
            this.data = a;
            var b = a.items
        }
        if (GeoGlobe.Util.isArray(b))for (var a = 0, c = b.length; a < c; a++) {
            var d = new GeoGlobe.Query.RouteInfoItem, e;
            for (e in b[a])d[e] = b[a][e];
            this.items.push(d)
        }
    }, CLASS_NAME: "GeoGlobe.Query.RouteInfoResult"
});
GeoGlobe.Query.RouteInfoItem = GeoGlobe.Class4OL({
    id: null,
    name: null,
    toll: null,
    length: null,
    geometry: null,
    level: null,
    directions: null,
    initialize: function () {
    },
    CLASS_NAME: "GeoGlobe.Query.RouteInfoItem"
});
GeoGlobe.Query.BusQuery = GeoGlobe.Class4OL(GeoGlobe.Query.Service, {
    networkName: null, transferScheme: null, initialize: function (a, b, c) {
        this.name = a;
        this.url = b;
        GeoGlobe.Util.extend(this, c)
    }, getCapabilities: function (a, b) {
        typeof b != "function" && (b = function () {
            alert("\u516c\u4ea4\u670d\u52a1\u8bf7\u6c42\u5931\u8d25\uff0c\u8bf7\u68c0\u67e5\u670d\u52a1\u662f\u5426\u6b63\u5e38\u8fd0\u884c\u6216\u8bf7\u6c42\u5730\u5740\u662f\u5426\u6b63\u786e\u3002\n\u8bf7\u6c42\u5730\u5740\uff1a" + this.url + "\n\u64cd\u4f5c\u7c7b\u578b\uff1aGetCapabilities")
        });
        GeoGlobe.Request.GET({
            url: this.url,
            params: {REQUEST: "GetCapabilities"},
            scope: this,
            async: !1,
            success: function (b) {
                typeof a == "function" && a(b)
            },
            failure: b
        })
    }, isExist: function () {
        var a = !1;
        GeoGlobe.Request.GET({
            url: this.url, scope: this, async: !1, success: function () {
                a = !0
            }
        });
        return a
    }, queryStation: function (a, b, c) {
        var d = {REQUEST: "QueryStation"};
        if (!a.networkName)throw"Error!Not network name for bus query.";
        d.NETWORKNAME = a.networkName;
        if (a.stationId !== null && a.stationId !== void 0) d.STATIONID = a.stationId;
        if (a.stationName !==
            null && a.stationName !== void 0) d.STATIONNAME = a.stationName;
        if (a.lineId !== null && a.lineId !== void 0) d.LINEID = a.lineId;
        if (a.lineName !== null && a.lineName !== void 0) d.LINENAME = a.lineName;
        if (a.coordinate !== null && a.coordinate !== void 0) d.COORDINATE = a.coordinate;
        if (a.bbox !== null && a.bbox !== void 0) d.BOX = a.bbox;
        GeoGlobe.Request.GET({
            url: this.url, params: d, scope: this, success: function (a) {
                a = this._parserFeatures(a.responseText);
                b(a)
            }, failure: c
        })
    }, queryLine: function (a, b, c) {
        var d = {REQUEST: "QueryLine"};
        if (!a.networkName)throw"Error!Not network name for bus query.";
        d.NETWORKNAME = a.networkName;
        if (a.lineName !== null && a.lineName !== void 0) d.LINENAME = a.lineName;
        if (a.lineId !== null && a.lineId !== void 0) d.LINEID = a.lineId;
        if (a.stationName !== null && a.stationName !== void 0) d.STATIONNAME = a.stationName;
        if (a.stationId !== null && a.stationId !== void 0) d.STATIONID = a.stationId;
        if (a.coordinate !== null && a.coordinate !== void 0) d.COORDINATE = a.coordinate;
        if (a.bbox !== null && a.bbox !== void 0) d.BOX = a.bbox;
        GeoGlobe.Request.GET({
            url: this.url, params: d, scope: this, success: function (a) {
                a = this._parserFeatures(a.responseText);
                b(a)
            }, failure: c
        })
    }, queryChange: function (a, b, c) {
        var d = {REQUEST: "QueryChange"};
        if (!a.networkName)throw"Error!Not network name for bus query.";
        d.NETWORKNAME = a.networkName;
        if (a.startStationId !== null && a.startStationId !== void 0) d.STARTSTATIONID = a.startStationId;
        if (a.endStationId !== null && a.endStationId !== void 0) d.ENDSTATIONID = a.endStationId;
        if (a.orderType !== null && a.orderType !== void 0) d.ORDERTYPE = a.orderType;
        if (a.startCoordinate !== null && a.startCoordinate !== void 0) d.STARTCOORDINATE = a.startCoordinate;
        if (a.endCoordinate !==
            null && a.endCoordinate !== void 0) d.ENDCOORDINATE = a.endCoordinate;
        if (a.maxDepth !== null && a.maxDepth !== void 0) d.MAXDEPTH = a.maxDepth;
        if (a.maxCost !== null && a.maxCost !== void 0) d.MAXCOST = a.maxCost;
        if (a.maxSolutions !== null && a.maxSolutions !== void 0) d.MAXSOLUTIONS = a.maxSolutions;
        if (a.ChangeCount !== null && a.ChangeCount !== void 0) d.CHANGECOUNT = a.ChangeCount;
        GeoGlobe.Request.GET({
            url: this.url, params: d, scope: this, success: function (a) {
                for (var c = [], a = (a.responseXML.documentElement ? a.responseXML : format.read(a.responseText)).selectNodes("/Features/FeatureCollection"),
                         d = new GeoGlobe.Format.XML, h = 0; h < a.length; h++) {
                    var j = a[h],
                        l = this._getAttibutionOfNode(j, ["cost", "price", "walkingDistance", "transferTimes"]),
                        m = this._parserFeatures(d.write(a[h]));
                    m.attributes = l;
                    j = j.selectNodes("featureMember");
                    for (l = 0; l < j.length; l++) {
                        var n = j[l].selectNodes("Road");
                        m[l].isOnFoot = n[0].getAttribute("isOnFoot")
                    }
                    c.push(m)
                }
                b(c)
            }, failure: c
        })
    }, _getAttibutionOfNode: function (a, b) {
        var c = {};
        if (a.tagName)for (var d = 0; d < b.length; d++)c[b[d]] = a.getAttribute(b[d]);
        return c
    }, _getGeometryType: function () {
        return "polygon"
    },
    _pagingToString: function (a, b) {
        b = b || this.maxPerPage;
        return "<numPerPage>" + b + "</numPerPage><curPage>" + (a || 1) + "</curPage>"
    }, _orderByToString: function (a) {
        return a ? "<orderBy><PropertyName>" + a + "</PropertyName></orderBy>" : ""
    }, _geometryToString: function () {
        return '<geometry><Polygon><outerBoundaryIs><LinearRing><coordinates decimal="." cs="," ts=" ">20,30 21,41 52,42 53,33 20,30</coordinates></LinearRing></outerBoundaryIs></Polygon></geometry>'
    }, _stringToGeometry: function () {
        return GeoGlobe.Geometry.Polygon.createRegularPolygon(new GeoGlobe.Geometry.Point(Math.random() *
            360 - 160, Math.random() * 90 - 70), Math.round(Math.random() * 20), Math.round(Math.random() * 10))
    }, _parserFeatures: function (a) {
        var b = new GeoGlobe.Format.GML;
        b.gmlns = "*";
        return b.read(a)
    }, _parserResponseText: function (a, b) {
        if (b)var c = RegExp("</" + b + ">", ["g"]),
            a = a.replace(RegExp("<" + b + ">", ["g"]), "<featureMember><" + b + ">"),
            a = a.replace(c, "</" + b + "></featureMember>");
        a = a.replace(/<gml:LineString>/g, "<gml:LineString><gml:coordinates>");
        a = a.replace(/<\/gml:LineString>/g, "</gml:coordinates></gml:LineString>");
        a = a.replace(/<gml:Point>/g,
            "<gml:Point><gml:coordinates>");
        return a = a.replace(/<\/gml:Point>/g, "</gml:coordinates></gml:Point>")
    }, _parserFeaturesNew: function (a, b) {
        var c = new GeoGlobe.Format.GML;
        c.gmlns = "*";
        if (b) c.featureName = b;
        return c.read(a)
    }, _parserSuccessResult: function (a) {
        return (new GeoGlobe.Util.Format.XML2JSON).read(a)
    }, _parseToXML: function (a) {
        var b = a.responseXML;
        if (!b || !b.documentElement) b = a.responseText;
        return (new GeoGlobe.Format.XML).read(b)
    }, _parseToJSON: function (a) {
        return (new GeoGlobe.Format.XML2JSON).read(a)
    }, queryTransferScheme: function (a,
                                      b, c) {
        var d = {request: "QueryTransferScheme", SERVICE: "BUS", VERSION: "1.0.0"},
            e = {networkName: !0, transferMode: !0, startInput: !0, endInput: !0}, f;
        for (f in e)if (!(f in a))throw Error("\u7f3a\u5c11\u5fc5\u9009\u5c5e\u6027\uff1a'" + f + "'\u3002");
        d.networkName = a.networkName;
        if (a.service !== null && a.service !== void 0) d.SERVICE = a.service;
        if (a.version !== null && a.version !== void 0) d.VERSION = a.version;
        if (a.transferMode !== null && a.transferMode !== void 0) d.TRANSFERMODE = a.transferMode;
        if (a.startInput !== null && a.startInput !== void 0) d.STARTINPUT =
            a.startInput;
        if (a.endInput !== null && a.endInput !== void 0) d.ENDINPUT = a.endInput;
        if (a.inputMode !== null && a.inputMode !== void 0) d.INPUTMODEL = a.inputMode;
        if (a.ExistGoTime !== null && a.ExistGoTime !== void 0) d.EXISTGOTIME = a.ExistGoTime;
        if (a.StartTime !== null && a.StartTime !== void 0) d.STARTTIME = a.StartTime;
        if (a.MaxSearchDistance !== null && a.MaxSearchDistance !== void 0) d.MAXSEARCHDISTANCE = a.MaxSearchDistance;
        if (a.PrioritySubset !== null && a.PrioritySubset !== void 0) d.PRIORITYSUBSET = a.PrioritySubset;
        if (a.ExistAbsolutePriority !==
            null && a.ExistAbsolutePriority !== void 0) d.EXISTABSOLUTEPRIORITY = a.ExistAbsolutePriority;
        if (a.LagSubset !== null && a.LagSubset !== void 0) d.LAGSUBSET = a.LagSubset;
        if (a.OutputPage !== null && a.OutputPage !== void 0) d.OUTPUTPAGE = a.OutputPage;
        if (a.PageSize !== null && a.PageSize !== void 0) d.PAGESIZE = a.PageSize;
        if (a.ChangeCount !== null && a.ChangeCount !== void 0) d.CHANGECOUNT = a.ChangeCount;
        GeoGlobe.Request.GET({
            url: this.url, params: d, async: !1, scope: this, success: GeoGlobe.Function.bind(function (a) {
                var c = a.responseXML, d = {
                    startPoint: [],
                    transferScheme: [], endPoint: []
                };
                if (!c)return b(d), d;
                var a = new GeoGlobe.Format.XML, e = c.selectNodes("/ServiceExceptionReport/ServiceExceptionMessage");
                if (e && e.length > 0)return b(d), d;
                c = c.selectNodes("/QueryTransferSchemeResponse");
                a = this._parseToJSON(a.write(c[0]));
                d = a.QueryTransferSchemeResponse.StartPoint;
                GeoGlobe.Util.isArray(d) || (d = [d]);
                c = a.QueryTransferSchemeResponse.EndPoint;
                GeoGlobe.Util.isArray(c) || (c = [c]);
                a = a.QueryTransferSchemeResponse.TransferScheme;
                d = this._getPointGeometryByGMLPointStr(d[0].Geometry.gml_Point);
                d = new GeoGlobe.Feature(d);
                c = this._getPointGeometryByGMLPointStr(c[0].Geometry.gml_Point);
                c = new GeoGlobe.Feature(c);
                a = this._parserTransferScheme(a);
                d = {startPoint: d, transferScheme: a, endPoint: c};
                b(d)
            }, this), failure: c
        })
    }, _parserTransferScheme: function (a) {
        GeoGlobe.Util.isArray(a) || (a = [a]);
        for (var b = [], c = 0; c < a.length; c++) {
            var d = a[c], e = this._parserSectionInfo(d.SectionInfo), d = this._parserSectionRouting(d.SectionRouting);
            b.push({
                Cost: a[c].Cost, SectionInfo: e, SectionRouting: d, TotalDistance: a[c].TotalDistance,
                TransferCount: a[c].TransferCount
            })
        }
        return b
    }, _parserSectionInfo: function (a) {
        GeoGlobe.Util.isArray(a) || (a = [a]);
        for (var b = [], c = 0; c < a.length; c++) {
            var d = this._getPointFeatureByObj(a[c].FromStation);
            if (a[c].FromStation.PassagewayRouting) {
                var e = this._getPointFeatureByObj(a[c].FromStation.PassagewayRouting);
                if (e.SectionRouting) e.attributes.SectionRouting = e.data.SectionRouting = this._parserSectionRouting(e.SectionRouting);
                d.attributes.PassagewayRouting = d.data.PassagewayRouting = e
            }
            var f = this._getPointFeatureByObj(a[c].ToStation);
            if (a[c].ToStation.PassagewayRouting) {
                e = this._getPointFeatureByObj(a[c].ToStation.PassagewayRouting);
                if (e.SectionRouting) e.attributes.SectionRouting = e.data.SectionRouting = this._parserSectionRouting(e.SectionRouting);
                f.attributes.PassagewayRouting = f.data.PassagewayRouting = e
            }
            var e = this._parserSectionLines(a[c].SectionLines.SectionLine),
                g = this._parserSectionRouting(a[c].SectionRouting);
            b.push({FromStation: d, SectionLine: e, ToStation: f, SectionRouting: g})
        }
        return b
    }, _parserSectionLines: function (a) {
        GeoGlobe.Util.isArray(a) ||
        (a = [a]);
        for (var b = [], c = 0; c < a.length; c++) {
            var d = new GeoGlobe.Feature(null, a[c]);
            b.push(d)
        }
        return b
    }, _parserSectionRouting: function (a) {
        GeoGlobe.Util.isArray(a) || (a = [a]);
        for (var b = [], c = 0; c < a.length; c++)b.push(a[c]);
        return b
    }, _getPointGeometryByGMLPointStr: function (a) {
        a = a.split(",");
        return new GeoGlobe.Geometry.Point(parseFloat(a[0]), parseFloat(a[1]))
    }, _getPointFeatureByObj: function (a) {
        var b = null;
        a.Geometry && a.Geometry.gml_Point && (b = this._getPointGeometryByGMLPointStr(a.Geometry.gml_Point));
        return new GeoGlobe.Feature(b,
            a)
    }, _getLineGeometryByGMLLineStr: function (a) {
        if (!a)return null;
        for (var a = a.split(" "), b = [], c = 0, d = a.length; c < d; c++) {
            var e = this._getPointGeometryByGMLPointStr(a[c]);
            b.push(e)
        }
        return new GeoGlobe.Geometry.LineString(b)
    }, queryTransferGeometry: function (a, b, c) {
        var d = {request: "QueryTransferGeometry", SERVICE: "BUS", VERSION: "1.0.0"};
        if (!a.networkName)throw"Error!Not network name for bus query.";
        if (a.parameterInfo === null || a.parameterInfo === void 0 || a.parameterInfo === "")throw"Error!Not parameterInfo for bus query.";
        d.networkName = a.networkName;
        d.PARAMETERINFO = "";
        for (var e = 0; e < a.parameterInfo.length; e++)d.PARAMETERINFO += a.parameterInfo[e].toString(), e != a.parameterInfo.length - 1 && (d.PARAMETERINFO += "_");
        if (a.service !== null && a.service !== void 0) d.SERVICE = a.service;
        if (a.version !== null && a.version !== void 0) d.VERSION = a.version;
        GeoGlobe.Request.GET({
            url: this.url,
            params: d,
            scope: this,
            async: !1,
            success: GeoGlobe.Function.bind(function (a) {
                a = this._parseQueryTransferGeometryResult(a);
                b(a)
            }, this),
            failure: c
        })
    }, _parseQueryTransferGeometryResult: function (a) {
        resXML =
            a.responseXML;
        a = [];
        if (!resXML)return a;
        var b = new GeoGlobe.Format.XML, c = resXML.selectNodes("/QueryTransferGeometryResponse");
        if (c && c.length <= 0)return a;
        if (b = this._parseToJSON(b.write(c[0])).QueryTransferGeometryResponse.SectionGeometry) {
            GeoGlobe.Util.isArray(b) || (b = [b]);
            for (c = 0; c < b.length; c++) {
                var d = this._getLineGeometryByGMLLineStr(b[c].Geometry.gml_LineString),
                    d = new GeoGlobe.Feature(d, {ID: b[c].ID});
                a.push(d)
            }
        }
        return a
    }, queryKeyWord: function (a, b, c) {
        var d = {
            REQUEST: "QueryKeyWord", SERVICE: "BUS", VERSION: "1.0.0",
            SEARCHTYPE: 2
        };
        if (!a.networkName)throw"Error!Not network name for bus query.";
        if (a.keyWord === null || a.keyWord === void 0 || a.keyWord === "")throw"Error!Not keyWord for bus query.";
        d.NETWORKNAME = a.networkName;
        d.KEYWORD = a.keyWord;
        if (a.service !== null && a.service !== void 0) d.SERVICE = a.service;
        if (a.version !== null && a.version !== void 0) d.VERSION = a.version;
        if (a.searchType !== null && a.searchType !== void 0) d.SEARCHTYPE = a.searchType;
        if (a.keyWordType !== null && a.keyWordType !== void 0) d.KEYWORDTYPE = a.keyWordType;
        GeoGlobe.Request.GET({
            url: this.url,
            params: d, async: !1, scope: this, success: GeoGlobe.Function.bind(function (c) {
                c = this._parserQueryKeyWordResult(c, a.keyWordType);
                b(c)
            }, this), failure: c
        })
    }, _parserQueryKeyWordResult: function (a, b) {
        var c = a.responseXML, d = [];
        if (!c)return d;
        var e = new GeoGlobe.Format.XML, f = c.selectNodes("/ServiceExceptionReport/ServiceExceptionMessage");
        if (f && f.length > 0)return d;
        c = c.selectNodes("/QueryKeyWordResponse");
        e = this._parseToJSON(e.write(c[0]));
        if (b === 1) {
            (f = e.QueryKeyWordResponse.Stations.Station) && !GeoGlobe.Util.isArray(f) &&
            (f = [f]);
            for (e = 0; e < f.length; e++)c = this._getPointFeatureByObj(f[e]), d.push(c)
        } else if (b === 2) {
            (f = e.QueryKeyWordResponse.Passageways.Passageway) && !GeoGlobe.Util.isArray(f) && (f = [f]);
            for (e = 0; e < f.length; e++)c = this._getPointFeatureByObj(f[e]), d.push(c)
        } else {
            (c = e.QueryKeyWordResponse.Lines.Line) && !GeoGlobe.Util.isArray(c) && (c = [c]);
            for (e = 0; e < c.length; e++)f = new GeoGlobe.Feature(null, c[e]), d.push(f)
        }
        return d
    }, queryStationInfo: function (a, b, c) {
        var d = {REQUEST: "QueryStationInfo", SERVICE: "BUS", VERSION: "1.0.0"};
        if (!a.networkName)throw"Error!Not network name for bus query.";
        if (a.stationId === null || a.stationId === void 0 || a.stationId === "")throw"Error!Not stationId for bus query.";
        d.NETWORKNAME = a.networkName;
        if (a.service !== null && a.service !== void 0) d.SERVICE = a.service;
        if (a.version !== null && a.version !== void 0) d.VERSION = a.version;
        if (a.stationId !== null && a.stationId !== void 0) d.STATIONID = a.stationId;
        GeoGlobe.Request.GET({
            url: this.url, params: d, scope: this, success: function (a) {
                if (resXML = a.responseXML) {
                    for (var c = new GeoGlobe.Format.XML, a = this._parserQueryStationInfoNode("Lines", c, resXML),
                             c = this._parserQueryStationInfoNode("Passageways", c, resXML), d = [], h = 0; h < c.length; h++) {
                        var j = this._getPointFeatureByObj(c[h]);
                        d.push(j)
                    }
                    a = {lines: a, passageways: d}
                } else a = {lines: [], passageways: []};
                b(a)
            }, failure: c
        })
    }, _parserQueryStationInfoNode: function (a, b, c) {
        switch (a) {
            case "Lines":
                c = c.selectNodes("/QueryStationInfoResponse/StationInfo/Lines");
                a = [];
                if (c.length > 0) b = b.write(c[0]), b = this._parseToJSON(b), a = b.Lines.Line, GeoGlobe.Util.isArray(a) || (a = [a]);
                return a;
            case "Passageways":
                c = c.selectNodes("/QueryStationInfoResponse");
                a = [];
                if (c.length > 0 && (b = b.write(c[0]), b = this._parseToJSON(b), b = b.QueryStationInfoResponse.StationInfo.Passageways)) a = b.Passageway, GeoGlobe.Util.isArray(a) || (a = [a]);
                return a;
            default:
                return []
        }
    }, queryLineInfo: function (a, b, c) {
        var d = {REQUEST: "QueryLineInfo", SERVICE: "BUS", VERSION: "1.0.0"};
        if (!a.networkName)throw"Error!Not network name for bus query.";
        if (a.lineId === null || a.lineId === void 0 || a.lineId === "")throw"Error!Not lineId for bus query.";
        d.NETWORKNAME = a.networkName;
        if (a.service !== null && a.service !== void 0) d.SERVICE =
            a.service;
        if (a.version !== null && a.version !== void 0) d.VERSION = a.version;
        if (a.lineId !== null && a.lineId !== void 0) d.LINEID = a.lineId;
        if (a.startNodeNumber !== null && a.startNodeNumber !== void 0) d.STARTNODENUMBER = a.startNodeNumber;
        if (a.endNodeNumber !== null && a.endNodeNumber !== void 0) d.ENDNODENUMBER = a.endNodeNumber;
        GeoGlobe.Request.GET({
            url: this.url, params: d, scope: this, success: function (a) {
                var c = [], d = null;
                if (a.responseXML) {
                    d = a.responseXML;
                    if ((a = d.selectNodes("/ServiceExceptionReport/ServiceExceptionMessage")) && a.length >
                        0) {
                        b(c);
                        return
                    }
                    c = this._parserQueryLineInfoNode("Line", new GeoGlobe.Format.XML, d);
                    d = [];
                    for (a = 0; a < c.length; a++) {
                        for (var h = [], j = 0; j < c[a].VIAStations.Station.length; j++) {
                            var l = this._getPointFeatureByObj(c[a].VIAStations.Station[j]);
                            h.push(l)
                        }
                        c[a].Stations = h;
                        h = this._getLineGeometryByGMLLineStr(c[a].Geometry.gml_LineString);
                        h = new GeoGlobe.Feature(h, c[a]);
                        d.push(h)
                    }
                    c = d
                }
                b(c)
            }, failure: c
        })
    }, _parserQueryLineInfoNode: function (a, b, c) {
        switch (a) {
            case "Line":
                return a = c.selectNodes("/QueryLineInfoResponse"), b = this._parseToJSON(b.write(a[0])).QueryLineInfoResponse.Line,
                    a = [], a = b && !GeoGlobe.Util.isArray(b) ? [b] : b;
            default:
                return []
        }
    }, queryPassagewayInfo: function (a, b) {
        var c = {REQUEST: "QueryPassagewayInfo", SERVICE: "BUS", VERSION: "1.0.0"};
        if (!a.networkName)throw"Error!Not network name for bus query.";
        if (a.passagewayId === null || a.passagewayId === void 0 || a.passagewayId === "")throw"Error!Not passagewayId for bus query.";
        c.NETWORKNAME = a.networkName;
        if (a.service !== null && a.service !== void 0) c.SERVICE = a.service;
        if (a.version !== null && a.version !== void 0) c.VERSION = a.version;
        if (a.passagewayId !==
            null && a.passagewayId !== void 0) c.PASSAGEWAYID = a.passagewayId;
        GeoGlobe.Request.GET({
            url: this.url, params: c, scope: this, success: function (a) {
                var c = a.responseXML, f = [];
                if (!c)return b(f), f;
                new GeoGlobe.Format.XML;
                if ((c = c.selectNodes("/ServiceExceptionReport/ServiceExceptionMessage")) && c.length > 0)return b(f), f;
                f = this._parserFeaturesNew(this._parserResponseText(a.responseText), "Stations");
                b(f)
            }
        })
    }, _queryByName: function (a, b, c) {
        var d = this, e = null;
        d.queryKeyWord({
            networkName: d.networkName, keyWord: a, keyWordType: 1,
            SEARCHTYPE: 2
        }, function (a) {
            if (a.length == 0) alert("\u6ca1\u6709\u67e5\u8be2\u5230\u8d77\u70b9"); else {
                var g = a[0].geometry.x + " " + a[0].geometry.y;
                d.queryKeyWord({networkName: d.networkName, keyWord: b, keyWordType: 1, SEARCHTYPE: 2}, function (a) {
                    a.length == 0 ? alert("\u6ca1\u6709\u67e5\u8be2\u5230\u7ec8\u70b9") : e = d._queryTransferScheme(g, a[0].geometry.x + " " + a[0].geometry.y, c)
                })
            }
        });
        return e
    }, queryBus: function (a, b, c) {
        var d = this, e = null;
        d.getCapabilities(GeoGlobe.Function.bind(function (f) {
                var g = f.responseXML;
                if (!g || !g.documentElement) g =
                    f.responseText;
                f = (new GeoGlobe.Format.BusCapabilities).read(g);
                f.capability ? (d.networkName = f.capability.networks[0], e = typeof a == "string" && typeof b == "string" ? d._queryByName(a, b, c) : d._queryTransferScheme(a.lng + " " + a.lat, b.lng + " " + b.lat, c)) : alert("\u516c\u4ea4\u670d\u52a1\u8bf7\u6c42\u5931\u8d25\uff0c\u8bf7\u68c0\u67e5\u670d\u52a1\u662f\u5426\u6b63\u5e38\u8fd0\u884c\u6216\u8bf7\u6c42\u5730\u5740\u662f\u5426\u6b63\u786e\u3002\n\u8bf7\u6c42\u5730\u5740\uff1a" + url + "\n\u64cd\u4f5c\u7c7b\u578b\uff1aGetCapabilities")
            },
            this), function () {
            alert("\u516c\u4ea4\u670d\u52a1\u8bf7\u6c42\u5931\u8d25\uff0c\u8bf7\u68c0\u67e5\u670d\u52a1\u662f\u5426\u6b63\u5e38\u8fd0\u884c\u6216\u8bf7\u6c42\u5730\u5740\u662f\u5426\u6b63\u786e\u3002\n\u8bf7\u6c42\u5730\u5740\uff1a" + url + "\n\u64cd\u4f5c\u7c7b\u578b\uff1aGetCapabilities")
        });
        return {flag: e ? !0 : !1, featuresInfo: e}
    }, failFn: function () {
        alert("\u516c\u4ea4\u670d\u52a1\u8bf7\u6c42\u5931\u8d25\uff0c\u8bf7\u68c0\u67e5\u670d\u52a1\u662f\u5426\u6b63\u5e38\u8fd0\u884c\u6216\u8bf7\u6c42\u5730\u5740\u662f\u5426\u6b63\u786e\u3002\n\u8bf7\u6c42\u5730\u5740\uff1a" +
            url + "\n\u64cd\u4f5c\u7c7b\u578b\uff1aGetCapabilities")
    }, _queryTransferScheme: function (a, b, c) {
        this.queryTransferScheme({
            networkName: this.networkName,
            transferMode: c ? c : 0,
            inputMode: 0,
            startInput: a,
            endInput: b
        }, function (a) {
            featuresInfo = a
        });
        this.transferScheme = featuresInfo.transferScheme;
        return featuresInfo
    }, queryBusTransferSchemeByIndex: function (a) {
        var b = null, a = this.transferScheme[parseInt(a)].SectionInfo, c = [], d = [];
        for (i = 0; i < a.length; i++) {
            var e = a[i].SectionLine[0];
            c.push([0, e.data.ID, e.data.FromOrdinal,
                e.data.ToOrdinal]);
            d.push(a[i].FromStation);
            d.push(a[i].ToStation)
        }
        this.queryTransferGeometry({networkName: this.networkName, parameterInfo: c}, function (a) {
            var c = new GeoGlobe.Format.GeoJSON, e = c.write(a), c = c.write(d), j = new GeoGlobe.Format.JSON,
                e = j.read(e), c = j.read(c);
            b = {lineFeatures: a, geojsonRoute: e, stationFeatures: d, geojsonStation: c}
        });
        return b
    }, CLASS_NAME: "GeoGlobe.Query.BusQuery"
});
(function () {
    if (document.implementation.hasFeature("XPath", "3.0")) XMLDocument.prototype.selectNodes = function (a, b) {
        b || (b = this);
        for (var c = this.evaluate(a, b, function (a) {
            return {
                    csw: "http://www.opengis.net/cat/csw",
                    smmd: "http://data.sbsm.gov.cn/smmd/2007",
                    wfs: "http://www.opengis.net/wfs",
                    gml: "http://www.opengis.net/gml",
                    geoglobe: "http://www.geostar.com.cn/geoglobe"
                }[a] || null
        }, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null), d = [], e = 0; e < c.snapshotLength; e++)d[e] = c.snapshotItem(e);
        return d
    }, Element.prototype.selectNodes =
        function (a) {
            if (this.ownerDocument.selectNodes)return this.ownerDocument.selectNodes(a, this); else throw"For XML Elements Only";
        };
    if (document.implementation.hasFeature("XPath", "3.0")) XMLDocument.prototype.selectSingleNode = function (a, b) {
        b || (b = this);
        var c = this.selectNodes(a, b);
        return c.length > 0 ? c[0] : null
    }, Element.prototype.selectSingleNode = function (a) {
        if (this.ownerDocument.selectSingleNode)return this.ownerDocument.selectSingleNode(a, this); else throw"For XML Elements Only";
    }
})();
GeoGlobe.Query.WFSQuery = GeoGlobe.Class4OL({
    url: null,
    version: "1.0.0",
    featureNS: null,
    isReverse: !1,
    featurePrefix: "",
    featureType: "",
    maxFeatures: 10,
    filter: null,
    geometryName: "the_geom",
    protocol: null,
    format: null,
    formatOptions: null,
    isSeparate: !1,
    srsName: "EPSG:4326",
    time: null,
    userecent: !0,
    sortBy: null,
    groupBy: null,
    resultType: "Results",
    startPosition: null,
    initialize: function (a, b, c) {
        this.url = a;
        this.featureType = b;
        a = null;
        if (c) c.isReverse === !0 ? (this.isReverse = c.isReverse, a = !c.isReverse) : c.isReverse === !1 ? (this.isReverse =
            c.isReverse, a = !c.isReverse) : a = !this.isReverse, c.format ? (c.format instanceof GeoGlobe.Format.GML.v2 || c.format instanceof GeoGlobe.Format.GML.v3) && c.format.setFeatureType_(b) : this.format = new GeoGlobe.Format.GML({xy: a});
        GeoGlobe.Util.extend(this, c)
    },
    query: function (a, b, c) {
        this.protocol = new GeoGlobe.Protocol.WFS({
            readFormat: this.format,
            formatOptions: this.formatOptions,
            propertyNames: this.propertyNames,
            maxFeatures: this.maxFeatures,
            featurePrefix: this.featurePrefix,
            featureNS: this.featureNS,
            url: this.url,
            version: this.version,
            geometryName: this.geometryName,
            featureType: this.featureType,
            time: this.time,
            userecent: this.userecent,
            srsName: this.srsName
        });
        var a = a || this.filter, d = b || this.successFn, e = c || this.failFn,
            b = GeoGlobe.Function.bind(function (a) {
                if (a.success()) {
                    var b = a.features;
                    this.isSeparate && (b = this._separateFeatures(b));
                    (a = this._read_trueName(a)) && (b.trueNames = a);
                    a = (new GeoGlobe.Format.GeoJSON).write(b);
                    a = (new GeoGlobe.Format.JSON).read(a);
                    d({features: b, geojson: a})
                } else e()
            }, this);
        this.response = this.protocol.read({
            sortBy: this.sortBy,
            filter: a, callback: b
        })
    },
    queryPage: function (a, b, c, d) {
        var e = d && d.perPageNumber || 15;
        this.protocol = new GeoGlobe.Protocol.WFS({
            readFormat: this.format,
            multi: !0,
            formatOptions: this.formatOptions,
            propertyNames: this.propertyNames,
            maxFeatures: e,
            startPosition: ((d && d.pageNumber || 1) - 1) * e + 1,
            featurePrefix: this.featurePrefix,
            url: this.url,
            featureNS: this.featureNS,
            version: this.version,
            geometryName: this.geometryName,
            featureType: this.featureType,
            time: this.time,
            userecent: this.userecent,
            srsName: this.srsName
        });
        var a = a || this.filter,
            f = b || this.successFn, g = c || this.failFn, b = GeoGlobe.Function.bind(function (a) {
                if (a.success()) {
                    var b = a.features;
                    this.isSeparate && (b = this._separateFeatures(b));
                    a = this._read_trueName(a);
                    b.trueNames = a;
                    a = (new GeoGlobe.Format.GeoJSON).write(b);
                    a = (new GeoGlobe.Format.JSON).read(a);
                    f({features: b, geojson: a})
                } else g()
            }, this);
        this.response = this.protocol.read({sortBy: this.sortBy, filter: a, callback: b})
    },
    queryTotalNumber: function (a, b, c) {
        var d = new GeoGlobe.Format.WFSHits;
        this.protocol = new GeoGlobe.Protocol.WFS({
            readFormat: d,
            propertyNames: this.propertyNames,
            resultType: "hits",
            maxFeatures: this.maxFeatures,
            featurePrefix: this.featurePrefix,
            featureNS: this.featureNS,
            url: this.url,
            version: this.version,
            geometryName: this.geometryName,
            featureType: this.featureType,
            time: this.time,
            userecent: this.userecent
        });
        var a = a || this.filter, e = b || this.successFn, f = c || this.failFn,
            b = GeoGlobe.Function.bind(function (a) {
                a.success() ? e(a.features) : f()
            }, this);
        this.response = this.protocol.read({filter: a, callback: b})
    },
    _read_trueName: function (a) {
        var b = [];
        if (a.priv &&
            a.priv.responseText) {
            if (null == this.format)return null;
            a = this.format.getXMLDoc().getElementsByTagName("trueName");
            if (a == null || a.length == 0)return null;
            for (var c = 0; c < a.length; c++)b.push(a[c].text)
        }
        return b
    },
    getBufferRegion: function (a, b, c) {
        var d = this._getFeaturesCenter(a);
        switch (c) {
            case "km":
                b *= 1E3;
            case "m":
                b = this._meterToDegree(b, d)
        }
        return GeoGlobe.Geometry.Polygon.createRegularPolygon(a.geometry, b, 40, 360)
    },
    _getFeaturesCenter: function (a) {
        return this._getFeaturesExtent(a).getCenterLonLat()
    },
    _getFeaturesExtent: function (a) {
        GeoGlobe.Util.isArray(a) ||
        (a = [a]);
        var b = null;
        if (a && a.length > 0)for (var b = new GeoGlobe.LngLatBounds, c = null, d = 0, e = a.length; d < e; d++)(c = a[d].geometry) && b.extend(c.getBounds());
        return b
    },
    _meterToDegree: function (a, b) {
        return a * (8.99E-6 / Math.cos(GeoGlobe.Util.rad(b.lat)))
    },
    pointQuery: function (a, b, c, d, e) {
        this.query(new GeoGlobe.Filter.Spatial({
            type: GeoGlobe.Filter.Spatial.DWITHIN,
            property: this.geometryName,
            distance: b || 0,
            distanceUnits: c || "degree",
            value: a
        }), d, e)
    },
    pathQuery: function (a, b, c, d, e) {
        this.query(new GeoGlobe.Filter.Spatial({
            type: GeoGlobe.Filter.Spatial.DWITHIN,
            property: this.geometryName, distance: b || 0, distanceUnits: c || "degree", value: a
        }), d, e)
    },
    polygonQuery: function (a, b, c, d) {
        this.query(new GeoGlobe.Filter.Spatial({
            type: b ? GeoGlobe.Filter.Spatial.CONTAINS : GeoGlobe.Filter.Spatial.INTERSECTS,
            property: this.geometryName,
            value: a
        }), c, d)
    },
    bboxQuery: function (a, b, c) {
        this.query(new GeoGlobe.Filter.Spatial({
            type: GeoGlobe.Filter.Spatial.BBOX,
            property: this.geometryName,
            value: a
        }), b, c)
    },
    attributeQuery: function (a, b, c, d, e, f) {
        this.query(new GeoGlobe.Filter.Comparison({
            type: a,
            property: b,
            value: c,
            matchCase: d && d.matchCase,
            lowerBoundary: d ? d.lowerBoundary : null,
            upperBoundary: d ? d.upperBoundary : null
        }), e, f)
    },
    statisticsQuery: function (a, b, c) {
        this.protocol = new GeoGlobe.Protocol.WFS({
            readFormat: this.format,
            formatOptions: this.formatOptions,
            propertyNames: this.propertyNames,
            resultType: "statistics",
            maxFeatures: this.maxFeatures,
            featurePrefix: this.featurePrefix,
            featureNS: this.featureNS,
            url: this.url,
            version: this.version,
            geometryName: this.geometryName,
            featureType: this.featureType,
            time: this.time,
            userecent: this.userecent
        });
        var a = a || this.filter, d = b || this.successFn, e = c || this.failFn,
            b = GeoGlobe.Function.bind(function (a) {
                if (a.success()) {
                    try {
                        var b = this._analysis_StatisticsResult(a.priv.responseXML)
                    } catch (c) {
                        d(a.priv.responseText);
                        return
                    }
                    d(b)
                } else e()
            }, this);
        this.response = this.protocol.read({sortBy: this.sortBy, groupBy: this.groupBy, filter: a, callback: b})
    },
    _analysis_StatisticsResult: function (a) {
        var b = {}, a = a.documentElement.firstChild.childNodes;
        if (0 < a.length) b.layers = this._analysis_StatisticsResult_results(a);
        return b
    },
    _analysis_StatisticsResult_results: function (a) {
        for (var b = [], c = 0; c < a.length; c++) {
            for (var d = {}, e = [], f = a[c].childNodes, g = 0; g < f.length; g++) {
                var h = {};
                h.layerName = f[g].parentNode.nodeName;
                h.result = navigator.appName == "Microsoft Internet Explorer" ? this._analysis_StatisticsResult_results_result_IE(f[g]) : this._analysis_StatisticsResult_results_result_google(f[g]);
                e.push(h)
            }
            d.results = e;
            b.push(d)
        }
        return b
    },
    _analysis_StatisticsResult_results_result_IE: function (a) {
        var b = {}, c = 0;
        if ("Key" == a.childNodes[0].nodeName) b.Key =
            a.childNodes[0].text, c = 1;
        for (var d = [], e = []; c < a.childNodes.length; c++) {
            var f = {}, g = {};
            f.name = a.childNodes[c].getAttribute("name");
            g.Value = a.childNodes[c].text;
            d.push(f);
            e.push(g)
        }
        b.name = d;
        b.values = e;
        return b
    },
    _analysis_StatisticsResult_results_result_google: function (a) {
        var b = {}, c = 0;
        if ("Key" == a.childNodes[0].nodeName) b.Key = a.childNodes[0].innerHTML, c = 1;
        for (var d = [], e = []; c < a.childNodes.length; c++) {
            var f = {}, g = {};
            f.name = a.childNodes[c].getAttribute("name");
            g.Value = a.childNodes[c].innerHTML;
            d.push(f);
            e.push(g)
        }
        b.name =
            d;
        b.values = e;
        return b
    },
    successFn: function () {
    },
    failFn: function () {
        alert("\u5bf9\u4e0d\u8d77,\u67e5\u8be2\u5931\u8d25,\u8bf7\u67e5\u8be2\u670d\u52a1\u662f\u5426\u6b63\u5e38\u3002")
    },
    _separateFeatures: function (a) {
        for (var b = {}, c = 0; c < a.length; c++) {
            var d = a[c], e;
            e = d.gml ? d.gml.featureType : d.type;
            b[e] || (b[e] = []);
            b[e].push(d)
        }
        return b
    },
    setTime: function (a) {
        this.time = a
    },
    setUserecent: function (a) {
        this.userecent = a
    },
    CLASS_NAME: "GeoGlobe.Query.WFSQuery"
});
GeoGlobe.Query.WFSQuery.reverseGeometryXY = function (a) {
    var b = {
        Point: function (a) {
            var b = a.x, e = a.y, a = a.clone(a);
            a.x = e;
            a.y = b;
            return a
        }, LineString: function (a, b) {
            for (var e = a.clone(a), f = 0; f < e.components.length; f++) {
                var g = b.Point(e.components[f]);
                e.components[f] = g
            }
            return e
        }, Polygon: function (a, b) {
            for (var e = a.clone(a), f = 0; f < e.components.length; f++)for (var g = 0; g < e.components[f].components.length - 1; g++) {
                var h = b.Point(e.components[f].components[g]);
                e.components[f].components[g] = h
            }
            return e
        }
    };
    return b[{
        "GeoGlobe.Geometry.Point": "Point",
        "GeoGlobe.Geometry.MultiPoint": "MultiPoint",
        "GeoGlobe.Geometry.LineString": "LineString",
        "GeoGlobe.Geometry.MultiLineString": "MultiLineString",
        "GeoGlobe.Geometry.Polygon": "Polygon",
        "GeoGlobe.Geometry.MultiPolygon": "MultiPolygon",
        "GeoGlobe.Geometry.Collection": "GeometryCollection"
    }[a.CLASS_NAME]](a, b)
};
GeoGlobe.Format.WFSHits = GeoGlobe.Class4OL(GeoGlobe.Format.XML, {
    wfsns: "http://www.opengis.net/wfs",
    featureCollection: "FeatureCollection",
    read: function (a) {
        typeof a == "string" && (a = GeoGlobe.Format.XML.prototype.read.apply(this, [a]));
        return {numberOfFeatures: parseInt(a.documentElement.getAttribute("numberOfFeatures"))}
    }
});
GeoGlobe.Query.GeoCodingQuery = function (a, b) {
    var b = GeoGlobe.Util.applyDefaults(b, GeoGlobe.Query.GeoCodingQuery.DEFAULTS),
        c = GeoGlobe.Query.GeoCodingQuery["v" + b.version.replace(/\./g, "_")];
    if (!c)throw"\u4e0d\u652f\u6301\u7684\u5730\u5740\u5339\u914d\u670d\u52a1\u7248\u672c: " + b.version;
    return new c(a, b)
};
GeoGlobe.Query.GeoCodingQuery.DEFAULTS = {version: "1.0.0"};
GeoGlobe.Query.GeoCodingQuery.v1 = GeoGlobe.Class4OL({
    version: "1.0.0", url: null, initialize: function (a, b) {
        this.url = a;
        GeoGlobe.Util.extend(this, b);
        this.format = new GeoGlobe.Format.JSON
    }, getCommonParams: function (a) {
        var b = {request: "GetCategory", service: "GeoCoding", version: this.version, output: "json"};
        GeoGlobe.Util.extend(b, a);
        return b
    }, getCategoryByName: function (a, b, c) {
        var d = this.getCommonParams();
        if (typeof a === "string" && a.length !== 0) d.categoryName = a;
        c = c || this.failFn;
        GeoGlobe.Function.bind(this._requestCategory,
            this)(d, b, c)
    }, getCategoryByCode: function (a, b, c) {
        var d = this.getCommonParams();
        if (typeof a === "number") d.categoryCode = a;
        GeoGlobe.Function.bind(this._requestCategory, this)(d, b, c)
    }, getAllCategory: function (a, b) {
        var c = this.getCommonParams();
        GeoGlobe.Function.bind(this._requestCategory, this)(c, a, b)
    }, _requestCategory: function (a, b, c) {
        c = c || this.failFn;
        GeoGlobe.loadURL(this.url, a, this, function (a) {
            try {
                var c = this.format.read(a.responseText)
            } catch (f) {
                b(a.responseText);
                return
            }
            b(c)
        }, c)
    }, _analysis_GeoCodeResult: function (a) {
        var b =
            {status: a.status};
        switch (a.status) {
            case "OK":
                if (a = a.results) b.results = this._analysis_GeoCodeResult_results(a);
                break;
            case "INVALID_REQUEST":
                break;
            case "NO_RESULTS":
                break;
            case "UNKNOWN_ERROR":
                break;
            default:
                if (b = {
                        requestKeyWord: a.requestKeyWord,
                        count: a.count,
                        statisticsLevel: a.statisticsLevel,
                        statisticsLevelName: a.statisticsLevelName
                    }, a && a.count > 0 && (a = a.results)) b.results = this._analysis_GeoCodeResult_statistics(a)
        }
        return b
    }, _analysis_GeoCodeResult_results: function (a) {
        var b = [];
        if (GeoGlobe.Util.isArray(a)) {
            for (var c =
                0, d = a.length; c < d; c++) {
                var e = {};
                e.requestKeyWord = a[c].requestKeyWord;
                if (a[c].errorCorrectionTips) e.errorCorrectionTips = a[c].errorCorrectionTips;
                e.count = a[c].count;
                if (a[c].result) e.result = this._analysis_GeoCodeResult_results_result(a[c].result);
                b.push(e)
            }
            return b
        }
    }, _analysis_GeoCodeResult_statistics: function (a) {
        var b = [];
        if (GeoGlobe.Util.isArray(a)) {
            for (var c = 0, d = a.length; c < d; c++) {
                var e = {};
                if (a[c].errorCorrectionTips) e.errorCorrectionTips = a[c].errorCorrectionTips;
                if (a[c]) e.name = a[c].name, e.value = a[c].value,
                    e.remark = a[c].remark;
                b.push(e)
            }
            return b
        }
    }, _analysis_GeoCodeResult_results_result: function (a) {
        for (var b = [], c = 0, d = a.length; c < d; c++) {
            var e = {}, f = {};
            e.resultType = a[c].resultType;
            e.precise = a[c].precise;
            e.isBrief = a[c].isBrief;
            e.score = a[c].score;
            if (a[c].addressComponent.street) f = a[c].addressComponent.street;
            if (e.isBrief == !1) e.addressComponent = this._analysis_GeoCodeResult_results_result_address(a[c].addressComponent, e.resultType);
            e.poiArray = this._analysispoiArray(a[c].poiArray);
            if (a[c].location) e.location =
                a[c].location;
            if (e.precise == 0) e.referenceAddressArray = a[c].referenceAddressArray;
            if (f) e.street_path = f;
            b.push(e)
        }
        return b
    }, _analysis_GeoCodeResult_results_result_address: function (a, b) {
        var c = {country: a.country};
        if (a.province) c.province = a.province;
        if (a.city) c.city = a.city;
        if (a.district) c.district = a.district;
        if (a.town) c.town = a.town;
        if (a.street && (c.street = {name: a.street.name}, b === "street" && a.street.geometry)) {
            var d = this.format.read(a.street.geometry), e = null;
            if (d.paths) e = this._getGeometry(d), c.street.geometry =
                e; else if (d.rings) e = this._getGeometry(d), c.street.geometry = e; else if (d.x && d.y) e = this._getGeometry(d), c.street.geometry = e
        }
        if (a.streetNumber) c.streetNumber = a.streetNumber;
        if (a.buildingNumber) c.buildingNumber = a.buildingNumber;
        if (b === "adminArea") {
            if (a.geometry)if (d = this.format.read(a.geometry), e = null, d.rings) e = this._getGeometry(d), c.geometry = e; else if (d.paths) e = this._getGeometry(d), c.geometry = e; else if (typeof d.x === "number" && typeof d.y === "number") c.geometry = this._getGeometry(d);
            if (a.subordinate) c.subordinate =
                a.subordinate;
            if (a.zipCode) c.zipCode = a.zipCode;
            if (a.callingCode) c.callingCode = a.callingCode
        }
        return c
    }, _analysispoiArray: function (a) {
        for (var b = [], c = 0, d = a.length; c < d; c++) {
            var e = {}, f;
            for (f in a[c])e[f] = a[c][f];
            if ("" != e.geometry && void 0 != e.geometry) {
                var g = this.format.read(e.geometry);
                e.geometry = this._getGeometry(g)
            }
            b.push(e)
        }
        return b
    }, _analysisLocation: function () {
    }, _getGeometry: function (a) {
        for (var b in a) {
            if ("spatialReference" == b)break;
            return a = a.hasOwnProperty("x") && a.hasOwnProperty("y") ? new GeoGlobe.Geometry.Point(a.x,
                a.y) : a.hasOwnProperty("xmin") && a.hasOwnProperty("ymin") && a.hasOwnProperty("xmax") && a.hasOwnProperty("ymax") ? (new GeoGlobe.Bounds(a.xmin, a.ymin, a.xmax, a.ymax)).toGeometry() : this._geometryType[b](a[b])
        }
    }, _geometryType: {
        points: function (a) {
            var b = [];
            if (GeoGlobe.Util.isArray(a))for (var c = 0, d = a.length; c < d; c++) {
                var e = new GeoGlobe.Geometry.Point(a[c][0], a[c][1]);
                b.push(e)
            }
            return b
        }, paths: function (a) {
            var b = [];
            if (GeoGlobe.Util.isArray(a)) {
                for (var c = 0, d = a.length; c < d; c++) {
                    for (var e = [], f = 0, g = a[c].length; f < g; f++)e.push(new GeoGlobe.Geometry.Point(a[c][f][0],
                        a[c][f][1]));
                    e = new GeoGlobe.Geometry.LineString(e);
                    b.push(e)
                }
                c = new GeoGlobe.Geometry.MultiLineString(b)
            }
            return c
        }, rings: function (a) {
            var b = [];
            if (GeoGlobe.Util.isArray(a)) {
                for (var c = 0, d = a.length; c < d; c++) {
                    for (var e = [], f = 0, g = a[c].length; f < g; f++)e.push(new GeoGlobe.Geometry.Point(a[c][f][0], a[c][f][1]));
                    e = new GeoGlobe.Geometry.LinearRing(e);
                    b.push(e)
                }
                c = new GeoGlobe.Geometry.Polygon(b)
            }
            return c
        }
    }, failFn: function (a) {
        typeof a == "string" && alert(a);
        alert("\u5bf9\u4e0d\u8d77\uff0c\u67e5\u8be2\u8bf7\u6c42\u5931\u8d25\uff01\u8bf7\u68c0\u67e5\u5730\u5740\u5339\u914d\u670d\u52a1\u662f\u5426\u6b63\u5e38\u8fd0\u884c\u3002\n\u5f53\u524d\u670d\u52a1\u5730\u5740\u4e3a\uff1a" +
            this.url)
    }, CLASS_NAME: "GeoGlobe.Query.GeoCodingQuery.v1"
});
GeoGlobe.Query.GeoCodingQuery.v1_0_0 = GeoGlobe.Class4OL(GeoGlobe.Query.GeoCodingQuery.v1, {
    addressesToLocations: function (a, b) {
        var c = this.getCommonParams({request: "GeoCoder"});
        if (typeof a.address === "string") c.address = a.address; else if (GeoGlobe.Util.isArray(a.address)) {
            for (var d = "", e = 0; e < a.address.length; e++)d += a.address[e] + ",";
            d = d.substr(0, d.length - 1);
            c.address = d
        } else if (a.address == void 0 || a.address == null)throw"address\u662f\u5fc5\u9009\u53c2\u6570\uff01";
        if (typeof a.categoryCode === "number") c.categoryCode =
            a.categoryCode;
        if (a.extent instanceof mapboxgl.LngLatBounds) c.bbox = a.extent.toBBOX(null, !0); else if (a.extent instanceof GeoGlobe.Geometry.Polygon) {
            for (var d = a.extent, f = [], e = 0, g = d.components.length; e < g; e++)for (var h = d.components[e].components, j = 0; j < h.length; j++)f.push(h[j].toShortString());
            c.bbox = f.join(",")
        } else c.bbox = a.extent;
        if (typeof a.fuzzyMatch === "boolean") c.fuzzyMatch = a.fuzzyMatch;
        if (typeof a.resultType === "string") c.resultType = a.resultType;
        if (typeof a.maxCount === "number") c.maxCount = a.maxCount;
        if (typeof a.startPosition === "number") c.startPosition = a.startPosition;
        GeoGlobe.loadURL(this.url, c, this, function (a) {
            try {
                var d = this.format.read(a.responseText),
                    e = c.resultType == "result" ? this._parseQueryResultToFeature(d) : this._analysis_GeoCodeResult(d)
            } catch (f) {
                b(a.responseText);
                return
            }
            b(e)
        }, this.failFn)
    }, locationToAddresses: function (a, b) {
        var c = this.getCommonParams({request: "GeoCoder"});
        if (a.lonlat) c.latlng = a.lonlat.lat + "," + a.lonlat.lng; else throw"address\u662f\u5fc5\u9009\u53c2\u6570\uff01\u8bf7\u586b\u5199\u6b63\u786e\u7684\u6570\u636e\u7c7b\u578b\uff01";
        if (typeof a.tolerance === "number") c.tolerance = a.tolerance;
        if (typeof a.unit === "string") c.unit = a.unit;
        if (typeof a.resultType === "string") c.resultType = a.resultType;
        if (typeof a.maxCount === "number") c.maxCount = a.maxCount;
        if (typeof a.startPosition === "number") c.startPosition = a.startPosition;
        GeoGlobe.loadURL(this.url, c, this, function (a) {
                try {
                    var e = this.format.read(a.responseText),
                        f = c.resultType == "result" ? this._parseQueryResultToFeature(e) : this._analysis_GeoCodeResult(e)
                } catch (g) {
                    b(a.responseText);
                    return
                }
                b(f, e)
            },
            this.failFn)
    }, getLocations: function (a, b, c) {
        this.addressesToLocations(a, GeoGlobe.Function.bind(function (a) {
            b(this._parseQueryResultToFeature(a, total))
        }, this), c)
    }, getLocationsByPage: function (a, b, c) {
        a.resultType = "hits";
        this.addressesToLocations(a, GeoGlobe.Function.bind(function (d) {
            if (d.status == "OK") {
                a.resultType = "result";
                var e = d.results[0].count;
                if (a.maxCount == void 0 || a.maxCount == null) a.maxCount = 3;
                a.startPosition = (a.startPosition - 1) * a.maxCount + 1;
                this.addressesToLocations(a, GeoGlobe.Function.bind(function (a) {
                    b(this._parseQueryResultToFeature(a,
                        e))
                }, this), c)
            } else alert("\u6ca1\u6709\u67e5\u8be2\u5230\u4efb\u4f55\u6570\u636e")
        }, this), c)
    }, getAddresses: function (a, b, c) {
        this.locationToAddresses(a, GeoGlobe.Function.bind(function (a) {
            b(this._parseQueryResultToFeature(a, total))
        }, this), c)
    }, getAddressesByPage: function (a, b, c) {
        a.resultType = "hits";
        this.locationToAddresses(a, GeoGlobe.Function.bind(function (d) {
            if (d.status == "OK") {
                a.resultType = "result";
                var e = d.results[0].count;
                if (a.maxCount == void 0 || a.maxCount == null) a.maxCount = 3;
                a.startPosition = (a.startPosition -
                    1) * a.maxCount + 1;
                this.locationToAddresses(a, GeoGlobe.Function.bind(function (a) {
                    b(this._parseQueryResultToFeature(a, e))
                }, this), c)
            } else alert("\u6ca1\u6709\u67e5\u8be2\u5230\u4efb\u4f55\u6570\u636e")
        }, this), c)
    }, _parseQueryResultToFeature: function (a) {
        var b = [];
        if (a.status == "OK" && a.results)for (var c = 0; c < a.results.length; c++) {
            var d = a.results[c].result;
            if (d)for (var e = 0; e < d.length; e++) {
                var f = {}, g = null;
                f.requestKeyWord = a.results[c].requestKeyWord;
                if (GeoGlobe.Util.isArray(d[e].poiArray))for (var h = 0; h < d[e].poiArray.length; h++)f.CONTINENT =
                    d[e].poiArray[h].CONTINENT, f.GBCODE = d[e].poiArray[h].GBCODE, f.STANDARDNAME = d[e].poiArray[h].STANDARDNAME, f.name = d[e].poiArray[h].name, f.category = d[e].poiArray[h].category;
                if (d[e].addressComponent) f.address = this._getAddress(d[e].addressComponent, f.name), f.country = d[e].addressComponent.country, f.province = d[e].addressComponent.province, f.city = d[e].addressComponent.city, f.district = d[e].addressComponent.district, d[e].addressComponent.street ? (f.streetName = d[e].addressComponent.street.name, f.streetgeometry =
                    d[e].addressComponent.street.geometry) : f.streetName = "", f.streetNumber = d[e].addressComponent.streetNumber;
                if (d[e].location) {
                    if (d[e].location.lng) f.lng = d[e].location.lng;
                    if (d[e].location.lat) f.lat = d[e].location.lat;
                    g = new GeoGlobe.Geometry.Point(d[e].location.lng, d[e].location.lat)
                }
                f.isBrief = d[e].isBrief;
                f.precise = d[e].precise;
                f.resultType = d[e].resultType;
                f.score = d[e].score;
                f = new GeoGlobe.Feature(g, f);
                b.push(f)
            }
        }
        c = (new GeoGlobe.Format.GeoJSON).write(b);
        c = (new GeoGlobe.Format.JSON).read(c);
        return {
            status: a.status,
            features: b, geojsonFeatures: c
        }
    }, _getAddress: function (a, b) {
        var c = "";
        a.country && (c += a.country);
        a.province && (c += a.province);
        a.city && (c += a.city);
        a.district && (c += a.district);
        a.street && (a.street.name && (c += a.street.name), a.streetNumber && (c += a.streetNumber + "\u53f7"));
        b && (c += b);
        return c
    }, CLASS_NAME: "GeoGlobe.Query.GeoCodingQuery.v1_0_0"
});
GeoGlobe.Query.GeoCodingQuery.v1_1_0 = GeoGlobe.Class4OL(GeoGlobe.Query.GeoCodingQuery.v1, {
    method: "get", initialize: function (a, b) {
        GeoGlobe.Util.extend(this, b);
        this.filterFormat = new GeoGlobe.Format.Filter;
        GeoGlobe.Query.GeoCodingQuery.v1.prototype.initialize.apply(this, arguments)
    }, addressesToLocations: function (a, b, c) {
        var d = this.getCommonParams({request: "GeoCoder"});
        d.reverseMatch = !1;
        if (typeof a.address === "string") d.keyword = a.address;
        if (typeof a.categoryCode === "number") d.categoryCode = a.categoryCode;
        if ((a.address ==
            void 0 || a.address == null) && (a.categoryCode == void 0 || a.categoryCode == null))throw"address\u662f\u5fc5\u9009\u53c2\u6570\uff01";
        if (a.extent instanceof mapboxgl.LngLatBounds) d.bbox = a.extent.toBBOX(null, !0); else if (a.extent instanceof GeoGlobe.Geometry.Polygon) {
            for (var e = a.extent, f = [], g = 0, h = e.components.length; g < h; g++)for (var j = e.components[g].components, l = 0; l < j.length; l++)f.push(j[l].toShortString());
            d.bbox = f.join(",")
        } else d.bbox = a.extent;
        if (a.filter instanceof GeoGlobe.Filter) e = this.filterFormat.write(a.filter),
            e = GeoGlobe.Format.XML.prototype.write.apply(this.filterFormat, [e]), d.filter = e;
        if (typeof a.resultType === "string") d.resultType = a.resultType;
        if (a.resultType == "statistics") d.statisticsLevel = a.statisticsLevel;
        if (typeof a.maxCount === "number") d.maxCount = a.maxCount;
        if (typeof a.startPosition === "number") d.startPosition = a.startPosition;
        if (typeof a.semanticAnalysis === "boolean") d.semanticAnalysis = a.semanticAnalysis;
        if (typeof a.customWeight === "boolean") d.customWeight = a.customWeight;
        this._setGeoCoderCommonProperty(d,
            a);
        this._getCodingRequest(d, b, c)
    }, _getCodingRequest: function (a, b) {
        if (this.method == "get") GeoGlobe.loadURL(this.url, a, this, function (c) {
            try {
                var e = this.format.read(c.responseText),
                    f = a.resultType == "result" ? this._parseQueryResultToFeature(e) : this._analysis_GeoCodeResult(e)
            } catch (g) {
                b(c.responseText);
                return
            }
            b(f)
        }, this.failFn); else {
            var c = GeoGlobe.Util.getParameterString(a);
            GeoGlobe.Request.POST({
                url: this.url, data: c, success: function (a) {
                    try {
                        var c = this._analysis_GeoCodeResult(this.format.read(a.responseText))
                    } catch (f) {
                        b(a.responseText);
                        return
                    }
                    b(c)
                }, failure: this.failFn, scope: this
            })
        }
    }, _setGeoCoderCommonProperty: function (a, b) {
        if (typeof b.sortFields === "string") a.sortFields = b.sortFields;
        if (typeof b.scoreFilter === "string") a.scoreFilter = b.scoreFilter
    }, locationToAddresses: function (a, b, c) {
        var d = this.getCommonParams({request: "GeoCoder"});
        d.reverseMatch = !0;
        if (a.lonlat) d.keyword = a.lonlat.lat + "," + a.lonlat.lng; else throw"address\u662f\u5fc5\u9009\u53c2\u6570\uff01\u8bf7\u586b\u5199\u6b63\u786e\u7684\u6570\u636e\u7c7b\u578b\uff01";
        if (typeof a.tolerance ===
            "number") d.tolerance = a.tolerance;
        if (typeof a.unit === "string") d.unit = a.unit;
        if (typeof a.resultType === "string") d.resultType = a.resultType;
        if (a.resultType == "statistics") d.statisticsLevel = a.statisticsLevel;
        if (typeof a.maxCount === "number") d.maxCount = a.maxCount;
        if (typeof a.startPosition === "number") d.startPosition = a.startPosition;
        if (typeof a.customWeight === "boolean") d.customWeight = a.customWeight;
        this._setGeoCoderCommonProperty(d, a);
        this._getCodingRequest(d, b, c)
    }, batchAddressesToLocations: function (a, b, c) {
        var d =
            this.getCommonParams({request: "BatchGeoCoder", service: "GeoCoding"});
        d.reverseMatch = !1;
        if (GeoGlobe.Util.isArray(a.address)) {
            for (var e = "", f = 0; f < a.address.length; f++)e += a.address[f] + ",";
            e = e.substr(0, e.length - 1);
            d.keywords = e
        } else if (a.address == void 0 || a.address == null)throw"address\u662f\u5fc5\u9009\u53c2\u6570\uff01";
        if (typeof a.singleKeywordResultCount === "number") d.singleKeywordResultCount = a.singleKeywordResultCount;
        if (a.filter instanceof GeoGlobe.Filter) e = this.filterFormat.write(a.filter), e = GeoGlobe.Format.XML.prototype.write.apply(this.filterFormat,
            [e]), d.filter = e;
        this._setGeoCoderCommonProperty(d, a);
        this._getCodingRequest(d, b, c)
    }, batchLocationToAddresses: function (a, b, c) {
        var d = this.getCommonParams({request: "BatchGeoCoder", service: "GeoCoding"});
        d.reverseMatch = !0;
        if (a.lonlats instanceof GeoGlobe.LonLat) a.lonlats = [a.lonlats]; else if (!GeoGlobe.Util.isArray(a.lonlats))throw"address\u662f\u5fc5\u9009\u53c2\u6570\uff01\u8bf7\u586b\u5199\u6b63\u786e\u7684\u6570\u636e\u7c7b\u578b\uff01";
        if (GeoGlobe.Util.isArray(a.lonlats)) {
            for (var e = "", f = 0; f < a.lonlats.length; f++)e +=
                a.lonlats[f].lat + "," + a.lonlats[f].lng + ";";
            e = e.substr(0, e.length - 1);
            d.keywords = e
        }
        if (typeof a.tolerance === "number") d.tolerance = a.tolerance;
        if (typeof a.unit === "string") d.unit = a.unit;
        if (typeof a.singleKeywordResultCount === "number") d.singleKeywordResultCount = a.singleKeywordResultCount;
        this._setGeoCoderCommonProperty(d, a);
        this._getCodingRequest(d, b, c)
    }, _getAddress: function (a, b) {
        var c = "";
        a.country && (c += a.country);
        a.province && (c += a.province);
        a.city && (c += a.city);
        a.district && (c += a.district);
        a.street && (a.street.name &&
        (c += a.street.name), a.streetNumber && (c += a.streetNumber + "\u53f7"));
        b && (c += b);
        return c
    }, getLocations: function (a, b, c) {
        this.addressesToLocations(a, GeoGlobe.Function.bind(function (a) {
            b(this._parseQueryResultToFeature(a, total))
        }, this), c)
    }, getLocationsByPage: function (a, b, c) {
        a.resultType = "hits";
        this.addressesToLocations(a, GeoGlobe.Function.bind(function (d) {
            if (d.status == "OK") {
                a.resultType = "result";
                var e = d.results[0].count;
                if (a.maxCount == void 0 || a.maxCount == null) a.maxCount = 3;
                a.startPosition = (a.startPosition -
                    1) * a.maxCount + 1;
                this.addressesToLocations(a, GeoGlobe.Function.bind(function (a) {
                    b(this._parseQueryResultToFeature(a, e))
                }, this), c)
            } else alert("\u6ca1\u6709\u67e5\u8be2\u5230\u4efb\u4f55\u6570\u636e")
        }, this), c)
    }, getAddresses: function (a, b, c) {
        this.locationToAddresses(a, GeoGlobe.Function.bind(function (a) {
            b(this._parseQueryResultToFeature(a, total))
        }, this), c)
    }, getAddressesByPage: function (a, b, c) {
        a.resultType = "hits";
        this.locationToAddresses(a, GeoGlobe.Function.bind(function (d) {
            if (d.status == "OK") {
                a.resultType =
                    "result";
                var e = d.results[0].count;
                if (a.maxCount == void 0 || a.maxCount == null) a.maxCount = 3;
                a.startPosition = (a.startPosition - 1) * a.maxCount + 1;
                this.locationToAddresses(a, GeoGlobe.Function.bind(function (a) {
                    b(this._parseQueryResultToFeature(a, e))
                }, this), c)
            } else alert("\u6ca1\u6709\u67e5\u8be2\u5230\u4efb\u4f55\u6570\u636e")
        }, this), c)
    }, batchGetAddresses: function (a, b, c) {
        this.batchLocationToAddresses(a, GeoGlobe.Function.bind(function (a) {
            b(this._parseQueryResultToFeature(a))
        }, this), c)
    }, batchGetLocations: function (a,
                                    b, c) {
        this.batchAddressesToLocations(a, GeoGlobe.Function.bind(function (a) {
            b(this._parseQueryResultToFeature(a))
        }, this), c)
    }, _parseQueryResultToFeature: function (a) {
        var b = [];
        if (a.status == "OK" && a.results)for (var c = 0; c < a.results.length; c++) {
            var d = a.results[c].result;
            if (d)for (var e = 0; e < d.length; e++) {
                var f = {}, g = null;
                f.requestKeyWord = a.results[c].requestKeyWord;
                if (GeoGlobe.Util.isArray(d[e].poiArray))for (var h = 0; h < d[e].poiArray.length; h++)f.CONTINENT = d[e].poiArray[h].CONTINENT, f.GBCODE = d[e].poiArray[h].GBCODE,
                    f.STANDARDNAME = d[e].poiArray[h].STANDARDNAME, f.name = d[e].poiArray[h].name, f.category = d[e].poiArray[h].category;
                if (d[e].addressComponent) f.address = this._getAddress(d[e].addressComponent, f.name), f.country = d[e].addressComponent.country, f.province = d[e].addressComponent.province, f.city = d[e].addressComponent.city, f.district = d[e].addressComponent.district, d[e].addressComponent.street ? (f.streetName = d[e].addressComponent.street.name, f.streetgeometry = d[e].addressComponent.street.geometry) : f.streetName = "", f.streetNumber =
                    d[e].addressComponent.streetNumber;
                if (d[e].location) {
                    if (d[e].location.lng) f.lng = d[e].location.lng;
                    if (d[e].location.lat) f.lat = d[e].location.lat;
                    g = new GeoGlobe.Geometry.Point(d[e].location.lng, d[e].location.lat)
                }
                f.isBrief = d[e].isBrief;
                f.precise = d[e].precise;
                f.resultType = d[e].resultType;
                f.score = d[e].score;
                f = new GeoGlobe.Feature(g, f);
                b.push(f)
            }
        }
        c = (new GeoGlobe.Format.GeoJSON).write(b);
        c = (new GeoGlobe.Format.JSON).read(c);
        return {status: a.status, features: b, geojsonFeatures: c}
    }, CLASS_NAME: "GeoGlobe.Query.GeoCodingQuery.v1_1_0"
});
GeoGlobe.HeatMap = GeoGlobe.Class4OL({
    map: null, size: 25, intensity: 0.5, initialize: function (a, b) {
        this.heatmap = new mapboxgl.heatmap(a);
        a = this.map = a;
        b ? (this.datas = b, this.setData(b)) : this.datas = [];
        this._updataLayer = GeoGlobe.Function.bind(this.updateLayer, this);
        a.on("zoom", this._updataLayer);
        a.on("move", this._updataLayer)
    }, addPoint: function (a, b, c) {
        a = this.map.project([a[0], a[1]]);
        this.heatmap.heatmap.addPoint(a.x, a.y, b, c)
    }, update: function () {
        this.heatmap.heatmap.update()
    }, updateLayer: function () {
        this.setData(this.datas)
    },
    setData: function (a) {
        this.clear();
        if (this.datas = a)for (a = 0; a < this.datas.length; a++)this.addPoint(this.datas[a], this.size, this.intensity)
    }, display: function () {
        return this.heatmap.heatmap.display()
    }, multiply: function (a) {
        this.heatmap.heatmap.multiply(a)
    }, clamp: function (a) {
        this.heatmap.heatmap.clamp(a, a)
    }, blur: function () {
        this.heatmap.heatmap.blur()
    }, clear: function () {
        this.heatmap.heatmap.clear();
        this.datas = []
    }, remove: function () {
        this.clear();
        map.off("zoom", this._updataLayer);
        map.off("move", this._updataLayer);
        this.heatmap.heatmap_canvas.parentNode.removeChild(this.heatmap.heatmap_canvas);
        this.map = this.heatmap = this.heatmap.heatmap_canvas = null
    }, CLASS_NAME: "GeoGlobe.HeatMap"
});
GeoGlobe.LayerGroup = GeoGlobe.Class4OL({
    map: null, initialize: function () {
    }, addGroup: function (a, b, c, d) {
        mapboxgl.LayerGroup.addGroup(a, b, c, d)
    }, addLayerToGroup: function (a, b, c, d) {
        mapboxgl.LayerGroup.addLayerToGroup(a, b, c, d)
    }, removeLayerFromGroup: function (a, b, c) {
        for (var d = a.getStyle().layers, e = 0; e < d.length; e++)d[e].metadata && d[e].metadata.group === c && d[e].id == b && a.removeLayer(d[e].id)
    }, removeGroup: function (a, b) {
        mapboxgl.LayerGroup.removeGroup(a, b)
    }, moveGroup: function (a, b, c) {
        mapboxgl.LayerGroup.moveGroup(a,
            b, c)
    }, getGroupFirstLayerId: function (a, b) {
        return mapboxgl.LayerGroup.getGroupFirstLayerId(a, b)
    }, getGroupLastLayerId: function (a, b) {
        return mapboxgl.LayerGroup.getGroupLastLayerId(a, b)
    }, CLASS_NAME: "GeoGlobe.LayerGroup"
});
GeoGlobe.Service = GeoGlobe.Class({
    name: null, url: null, version: null, userid: "test@liferay.com", initialize: function (a, b, c) {
        this.name = a;
        this.url = b;
        GeoGlobe.Util.extend(this, c)
    }, getCapabilities: function () {
    }, isExist: function () {
    }, failFn: function (a) {
        alert("\u670d\u52a1\u8bf7\u6c42\u5931\u8d25\uff0c\u8bf7\u68c0\u67e5\u670d\u52a1\u662f\u5426\u6b63\u5e38\u8fd0\u884c\u6216\u8bf7\u6c42\u5730\u5740\u662f\u5426\u6b63\u786e\u3002\n\u8bf7\u6c42\u5730\u5740\uff1a" + this.url + "\n\u64cd\u4f5c\u7c7b\u578b\uff1a" + a)
    }, _parseToXML: function (a) {
        var b =
            a.responseXML;
        if (!b || !b.documentElement) b = a.responseText;
        return (new GeoGlobe.Format.XML).read(b)
    }, _checkIsError: function (a) {
        if ((new GeoGlobe.Format.XML).read(a).selectNodes("ServiceExceptionReport").length > 0)return this._parseToJSON(a);
        return null
    }, _isException: function (a) {
        if (a && a.ServiceExceptionReport)return !0;
        return !1
    }, _parseToJSON: function (a) {
        return (new GeoGlobe.Util.Format.XML2JSON).read(a)
    }, CLASS_NAME: "GeoGlobe.Service"
});
GeoGlobe.Service.WFST = GeoGlobe.Class4OL(GeoGlobe.Service, {
    xy: !0, initialize: function () {
        GeoGlobe.Service.prototype.initialize.apply(this, arguments)
    }, getCapabilities: function (a, b) {
        var c = this.url, d = {REQUEST: "GetCapabilities", SERVICE: "WFS", VERSION: "1.0.0"};
        b || (b = function () {
            this.failFn(d.REQUEST)
        });
        GeoGlobe.loadURL(c, d, this, function (b) {
            a(b)
        }, b)
    }, isExist: function () {
        var a = !1;
        GeoGlobe.Request.GET({
            url: this.url,
            params: {REQUEST: "GetCapabilities", SERVICE: "WFS"},
            scope: this,
            async: !1,
            success: function () {
                a = !0
            }
        });
        return a
    }, describeFeatureType: function (a, b, c) {
        var d = this.url;
        GeoGlobe.Util.applyDefaults(a, {SERVICE: "WFS", VERSION: "1.0.0", REQUEST: "DescribeFeatureType"});
        c || (c = function () {
            this.failFn(a.REQUEST)
        });
        GeoGlobe.loadURL(d, a, this, function (a) {
            b(a)
        }, c)
    }, getFeature: function (a, b, c) {
        var d = this.url;
        GeoGlobe.Util.applyDefaults(a, {SERVICE: "WFS", VERSION: "1.0.0", REQUEST: "GetFeature"});
        c || (c = function () {
            this.failFn(a.REQUEST)
        });
        GeoGlobe.loadURL(d, a, this, function (a) {
            b(a)
        }, c)
    }, lockFeature: function (a, b, c) {
        GeoGlobe.Util.applyDefaults(a,
            {service: "WFS", version: "1.0.0", request: "LockFeature", expiry: 1, lockAction: "ALL"});
        var d = this._parserFilterToString(a.filter),
            d = GeoGlobe.String.format('<?xml version="1.0" encoding="UTF-8"?><LockFeature version="${version}" service="${service}" lockAction="${lockAction}" expiry="${expiry}" xmlns:wfs=" http://www.opengis.net/wfs" xmlns:gml=" http://www.opengis.net/gml" xmlns:myns=" http://www.someserver.com/myns" xmlns:ogc=" http://www.opengis.net/ogc" xmlns:xsi=" http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.opengis.net/wfs ../wfs/1.1.0/WFS.xsd"><Lock typeName="${typeName}">${filterXMLString}</Lock></LockFeature>',
                {
                    version: a.version,
                    service: a.service,
                    lockAction: a.lockAction,
                    expiry: a.expiry,
                    typeName: a.typeName,
                    filterXMLString: d
                });
        c || (c = function () {
            this.failFn(a.request)
        });
        new GeoGlobe.Request.POST({url: this.url, data: d, scope: this, success: b, failure: c})
    }, transaction: function (a, b, c, d, e, f) {
        var g = this.url;
        GeoGlobe.Util.applyDefaults(a, {
            service: "WFS",
            version: "1.0.0",
            request: "Transaction",
            releaseAction: "ALL"
        });
        var h = a.lockId, j = "";
        h && (j += "<LockId>" + h + "</LockId>");
        h = "";
        b && (h += this._getInsertString(b));
        c && (h += this._getUpdateString(c));
        d && (h += this._getDeleteString(d));
        b = GeoGlobe.String.format('<?xml version="1.0" encoding="UTF-8"?><wfs:Transaction releaseAction="${releaseAction}" handle="Transaction 01" version="${version}" service="${service}" xmlns="http://www.someserver.com/myns" xmlns:gml="http://www.opengis.net/gml" xmlns:ogc="http://www.opengis.net/ogc" xmlns:wfs="http://www.opengis.net/wfs" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">${lockIdString}${transactionString}</wfs:Transaction>', {
            releaseAction: a.releaseAction,
            version: a.version, service: a.service, lockIdString: j, transactionString: h
        });
        f || (f = function () {
            this.failFn(a.request)
        });
        new GeoGlobe.Request.POST({url: g, data: b, scope: this, success: e, failure: f})
    }, parseTransactionResult: function (a) {
        var b = (new GeoGlobe.Format.XML2JSON).read(a.responseText), a = [],
            c = this._objToArray(b.wfs_WFS_TransactionResponse.wfs_TransactionResult.wfs_Status),
            b = this._objToArray(b.wfs_WFS_TransactionResponse.wfs_InsertResults);
        if (!c)return a;
        for (var d = 0; d < c.length; d++)c[d].wfs_SUCCESS !== void 0 ?
            a.push({status: "SUCCESS", fid: b && b[d] ? b[d].ogc_FeatureId.fid : null}) : a.push({
                status: "FAILED",
                fid: null
            });
        return a
    }, _objToArray: function (a) {
        a && !(a instanceof Array) && (a = [a]);
        return a
    }, _getInsertString: function (a) {
        for (var b = a.features, a = a.typeName, c = "", d = 0; d < b.length; d++)c += '<wfs:Insert handle="Insert ' + d + '">' + this._getInsertFeatureString(b[d], a) + "</wfs:Insert>";
        return c
    }, _getInsertFeatureString: function (a, b) {
        var c = "", d;
        for (d in a.attributes)d != "OID" && (c += GeoGlobe.String.format("<${tag}><![CDATA[${value}]]\></${tag}>",
            {value: a.attributes[d] ? a.attributes[d] : "", tag: d}));
        c += GeoGlobe.String.format("<GEOMETRY>${geometry}</GEOMETRY>", {geometry: this._getGeometryStringByFeature(a)});
        return c = GeoGlobe.String.format("<${typeName}>${content}</${typeName}>", {typeName: b, content: c})
    }, _getUpdateString: function (a) {
        for (var b = a.typeName, a = a.features, c = "", d = 0; d < a.length; d++)if (a[d].geometry) {
            var e = this._getUpdatePropertyString(a[d]),
                f = this._parserFilterToString(new GeoGlobe.Filter.FeatureId({fids: [b + "." + a[d].attributes.OID]}));
            c +=
                '<wfs:Update typeName="' + b + '" handle="Update ' + d + '">' + e + f + "</wfs:Update>"
        }
        return c
    }, _getUpdatePropertyString: function (a) {
        var b = "", c;
        for (c in a.data)c != "OID" && (b += "<wfs:Property><wfs:Name><![CDATA[" + c + "]]\></wfs:Name><wfs:Value><![CDATA[" + (a.data[c] ? a.data[c] : "") + "]]\></wfs:Value></wfs:Property>");
        b += "<wfs:Property><wfs:Name>Geometry</wfs:Name><wfs:Value>" + this._getGeometryStringByFeature(a) + "</wfs:Value></wfs:Property>";
        return b
    }, _getGeometryStringByFeature: function (a) {
        var b = new GeoGlobe.Format.GML({xy: this.xy});
        b.buildCoordinatesNode = GeoGlobe.Function.bind(function (a) {
            var b = this.createElementNS(this.gmlns, "gml:coordinates");
            b.setAttribute("decimal", ".");
            b.setAttribute("cs", ",");
            b.setAttribute("ts", " ");
            var e = [];
            if (a instanceof GeoGlobe.LngLatBounds) this.xy ? (e.push(a.left + "," + a.bottom), e.push(a.right + "," + a.top)) : (e.push(a.bottom + "," + a.left), e.push(a.top + "," + a.right)); else for (var a = a.components ? a.components : [a], f = 0; f < a.length; f++)this.xy ? e.push(a[f].x + "," + a[f].y) : e.push(a[f].y + "," + a[f].x);
            e = this.createTextNode(e.join(" "));
            b.appendChild(e);
            return b
        }, b);
        a = b.buildGeometryNode(a.geometry);
        return (new GeoGlobe.Format.XML).write(a)
    }, _getDeleteString: function (a) {
        for (var b = a.filter, a = a.typeName, c = "", d = 0; d < b.fids.length; d++) {
            c += '<wfs:Delete typeName="' + a + '" handle="Delete ' + d + '">';
            var e = new GeoGlobe.Filter.FeatureId({fids: [b.fids[d]]});
            c += this._parserFilterToString(e);
            c += "</wfs:Delete>"
        }
        return c
    }, _parserFilterToString: function (a) {
        var b = "";
        a && (a = (new GeoGlobe.Format.Filter.v1).write(a), b = (new GeoGlobe.Format.XML).write(a));
        return b
    },
    CLASS_NAME: "GeoGlobe.Service.WFST"
});
GeoGlobe.Service.CTS = GeoGlobe.Class4OL(GeoGlobe.Service, {
    initialize: function () {
        GeoGlobe.Service.prototype.initialize.apply(this, arguments)
    }, getCapabilities: function (a, b) {
        var c = this.url, d = {REQUEST: "GetCapabilities", SERVICE: "CTS"};
        b || (b = function () {
            this.failFn(d.REQUEST)
        });
        GeoGlobe.loadURL(c, d, this, function (b) {
            a(b)
        }, b)
    }, isExist: function () {
        var a = !1;
        GeoGlobe.Request.GET({
            url: this.url,
            params: {REQUEST: "GetCapabilities", SERVICE: "CTS"},
            scope: this,
            async: !1,
            success: function () {
                a = !0
            }
        });
        return a
    }, TransCoords: function (a,
                              b, c) {
        var d = this.url;
        GeoGlobe.Util.applyDefaults(a, {SERVICE: "CTS", REQUEST: "TransCoords"});
        c || (c = function () {
            this.failFn(a.REQUEST)
        });
        GeoGlobe.loadURL(d, a, this, function (c) {
            if (a.FORMAT == "xml") {
                var d = {}, c = c.responseXML;
                GeoGlobe.Function.bind(this.xmltoJson, this);
                c = this.xmltoJson(c);
                d.attributes = c.CTS_TransResult["cts:Coordinate"].attributes.dim;
                for (var c = c.CTS_TransResult["cts:Coordinate"].text.split(","), g = [], h = 0; h < c.length; h++)g.push(c[h]);
                d.coordvalue = g
            } else if (a.FORMAT == "json") d = {}, c = c.responseText,
                c = (new GeoGlobe.Format.JSON).read(c), d.attributes = c.CTS_TransResult.dim, d.coordvalue = c.CTS_TransResult.Coordinate;
            b(d)
        }, c)
    }, xmltoJson: function (a) {
        var b = {};
        if (a.nodeType == 1) {
            if (a.attributes.length > 0) {
                b.attributes = {};
                for (var c = 0; c < a.attributes.length; c++) {
                    var d = a.attributes.item(c);
                    b.attributes[d.nodeName] = d.nodeValue
                }
            }
        } else if (a.nodeType == 3) b = a.nodeValue;
        if (a.hasChildNodes())for (c = 0; c < a.childNodes.length; c++) {
            var d = a.childNodes.item(c), e = d.nodeName.replace("ows:", ""), e = e.replace("#", "");
            if (typeof b[e] ==
                "undefined") b[e] = this.xmltoJson(d); else {
                if (typeof b[e].push == "undefined") {
                    var f = b[e];
                    b[e] = [];
                    b[e].push(f)
                }
                b[e].push(this.xmltoJson(d))
            }
        }
        return b
    }, AffineTransform: function (a, b, c) {
        var d = this.url;
        GeoGlobe.Util.applyDefaults(a, {SERVICE: "CTS", REQUEST: "AffineTransform"});
        c || (c = function () {
            this.failFn(a.REQUEST)
        });
        GeoGlobe.loadURL(d, a, this, function (c) {
            if (a.FORMAT == "xml") {
                var d = {}, c = c.responseXML;
                GeoGlobe.Function.bind(this.xmltoJson, this);
                c = this.xmltoJson(c);
                d.attributes = c.CTS_AffineTransResult["cts:Coordinate"].attributes.dim;
                for (var c = c.CTS_AffineTransResult["cts:Coordinate"].text.split(","), g = [], h = 0; h < c.length; h++)g.push(c[h]);
                d.coordvalue = g
            } else if (a.FORMAT == "json") d = {}, c = c.responseText, c = (new GeoGlobe.Format.JSON).read(c), d.attributes = c.CTS_AffineTransResult.dim, d.coordvalue = c.CTS_AffineTransResult.Coordinate;
            b(d)
        }, c)
    }, CLASS_NAME: "GeoGlobe.Service.CTS"
});
GeoGlobe.Service.VTS = GeoGlobe.Class4OL(GeoGlobe.Service, {
    initialize: function () {
        GeoGlobe.Service.prototype.initialize.apply(this, arguments)
    }, getCapabilities: function (a, b) {
        var c = this.url, d = {REQUEST: "GetCapabilities", SERVICE: "WMTS", VERSION: "1.0.0"};
        b || (b = function () {
            this.failFn(d.REQUEST)
        });
        GeoGlobe.loadURL(c, d, this, function (b) {
            b = b.responseXML;
            GeoGlobe.Function.bind(this.xmlToJson, this);
            var b = this.xmlToJson(b), c = [], d, h = [], b = b.Capabilities;
            if (b.Contents.Layer.length)for (var j = 0; j < b.Contents.Layer.length; j++)h.push(b.Contents.Layer[j]);
            else h.push(b.Contents.Layer);
            for (var l = 0; l < h.length; l++) {
                d = {};
                d.version = b.attributes.version;
                d.format = h[l].Format[4].text;
                d.LayerIdentifier = h[l].Identifier.text;
                d.StyleIdentifier = h[l].Style.Identifier.text;
                d.MatrixSet = h[l].TileMatrixSetLink[0].TileMatrixSet.text;
                if (h[l].BoundingBox) d.Bounding = h[l].BoundingBox;
                for (var m = "", n = "", j = 0; j < b.Contents.TileMatrixSet.length; j++)if (b.Contents.TileMatrixSet[j].Identifier.text == d.MatrixSet)var p = b.Contents.TileMatrixSet[j];
                d.mapCRS = p.SupportedCRS.text;
                var q =
                    p.TileMatrix;
                if (q.length > 0) {
                    for (var j = 0, o = q.length; j < o; j++) {
                        if (j == o)break;
                        n += q[j].Identifier.text + ",";
                        m += q[j].ScaleDenominator.text + ","
                    }
                    d.zoomLevel = n.substr(0, n.length - 1);
                    d.Scales = m.substr(0, m.length - 1);
                    d.zoomOffset = q[0].Identifier.text;
                    d.initZoom = q[0].Identifier.text
                }
                c[l] = d
            }
            a(c, b)
        }, b)
    }, xmlToJson: function (a) {
        var b = {};
        if (a.nodeType == 1) {
            if (a.attributes.length > 0) {
                b.attributes = {};
                for (var c = 0; c < a.attributes.length; c++) {
                    var d = a.attributes.item(c);
                    b.attributes[d.nodeName] = d.nodeValue
                }
            }
        } else if (a.nodeType ==
            3) b = a.nodeValue;
        if (a.hasChildNodes())for (c = 0; c < a.childNodes.length; c++) {
            var d = a.childNodes.item(c), e = d.nodeName.replace("ows:", ""), e = e.replace("#", "");
            if (typeof b[e] == "undefined") b[e] = this.xmlToJson(d); else {
                if (typeof b[e].push == "undefined") {
                    var f = b[e];
                    b[e] = [];
                    b[e].push(f)
                }
                b[e].push(this.xmlToJson(d))
            }
        }
        return b
    }, GetTile: function (a) {
        var b = {REQUEST: "GetTile", SERVICE: "WMTS", VERSION: "1.0.0"};
        if (a.layer) b.LAYER = a.layer;
        if (a.format) b.FORMAT = a.format;
        if (a.tileMatrixSet) b.TILEMATRIXSET = a.tileMatrixSet;
        if (a.width) b.WIDTH =
            a.width;
        if (a.height) b.HEIGHT = a.height;
        if (a.TILEMATRIX) b.TILEMATRIX = a.TILEMATRIX;
        if (a.TILEROW) b.TILEROW = a.TILEROW;
        if (a.TILECOL) b.TILECOL = a.TILECOL;
        a = {};
        a.url = this.url;
        a.param = b;
        return this.urlAppend(a.url, this.getParameterString(a.param || {}))
    }, getParameterString: function (a) {
        var b = [], c;
        for (c in a) {
            var d = a[c];
            if (d != null && typeof d != "function") {
                if (typeof d == "object" && d.constructor == Array) {
                    for (var e = [], f, g = 0, h = d.length; g < h; g++)f = d[g], e.push(encodeURIComponent(f === null || f === void 0 ? "" : f));
                    d = e.join(",")
                }
                b.push(encodeURIComponent(c) +
                    "=" + d)
            }
        }
        return b.join("&")
    }, urlAppend: function (a, b) {
        var c = a;
        if (b) {
            var d = (a + " ").split(/[?&]/);
            c += d.pop() === " " ? b : d.length ? "&" + b : "?" + b
        }
        return c
    }, GetStyleName: function (a, b) {
        var c = this.url, d = {REQUEST: "GetStyle", SERVICE: "WMTS", VERSION: "1.0.0"};
        b || (b = function () {
            this.failFn(d.REQUEST)
        });
        GeoGlobe.Request.GET({
            url: c, params: d, scope: this, async: this.async, success: function (c) {
                c = c.responseText;
                if (!c)return b(), !1;
                var c = (new GeoGlobe.Format.JSON).read(c), d = [];
                if (c.style)for (var g = 0; g < c.style.length; g++)d.push(c.style[g].styleName);
                else if (c.styleName)for (g = 0; g < c.styleName.length; g++)d.push(c.styleName[g]);
                a(d)
            }, failure: b
        })
    }, GetStyle: function (a, b, c) {
        var d = this.url;
        if (a == "" || a == void 0) alert("\u8bf7\u67e5\u770b\u6837\u5f0f\u540d\u79f0\u662f\u5426\u5b58\u5728"); else {
            var e = {REQUEST: "GetStyle", SERVICE: "WMTS", VERSION: "1.0.0", STYLENAME: a};
            c || (c = function () {
                this.failFn(e.REQUEST)
            });
            GeoGlobe.Request.GET({
                url: d, params: e, scope: this, async: this.async, success: function (a) {
                    a = a.responseText;
                    if (!a)return c(), !1;
                    a = (new GeoGlobe.Format.JSON).read(a);
                    b(a)
                }, failure: c
            })
        }
    }, isExist: function () {
        var a = !1;
        GeoGlobe.Request.GET({
            url: this.url,
            params: {REQUEST: "GetCapabilities", SERVICE: "WFS"},
            scope: this,
            async: !1,
            success: function () {
                a = !0
            }
        });
        return a
    }, CLASS_NAME: "GeoGlobe.Service.VTS"
});
GeoGlobe.Service.WMS = GeoGlobe.Class4OL(GeoGlobe.Service, {
    initialize: function () {
        GeoGlobe.Service.prototype.initialize.apply(this, arguments)
    }, getCapabilities: function (a, b) {
        var c = this.url, d = {REQUEST: "GetCapabilities", SERVICE: "WMS"};
        b || (b = function () {
            this.failFn(d.REQUEST)
        });
        GeoGlobe.loadURL(c, d, this, function (b) {
            b = b.responseXML;
            GeoGlobe.Function.bind(this.xmlToJson, this);
            var b = this.xmlToJson(b), c = {}, d = b.WMT_MS_Capabilities, h = d.Capability.Layer.Layer,
                j = d.Capability.Request, h = h.length ? h[0] : h;
            c.version = d.attributes.version;
            c.format = j.GetMap.Format[1].text;
            c.layer = h.Title.text;
            c.bbox = h.BoundingBox.attributes.SRS;
            c.maxExtent = d.Capability.Layer.LatLonBoundingBox.attributes;
            a(c, b)
        }, b)
    }, isExist: function () {
        var a = !1;
        GeoGlobe.Request.GET({
            url: this.url,
            params: {REQUEST: "GetCapabilities", SERVICE: "WMS"},
            scope: this,
            async: !1,
            success: function () {
                a = !0
            }
        });
        return a
    }, xmlToJson: function (a) {
        var b = {};
        if (a.nodeType == 1) {
            if (a.attributes.length > 0) {
                b.attributes = {};
                for (var c = 0; c < a.attributes.length; c++) {
                    var d = a.attributes.item(c);
                    b.attributes[d.nodeName] =
                        d.nodeValue
                }
            }
        } else if (a.nodeType == 3) b = a.nodeValue;
        if (a.hasChildNodes())for (c = 0; c < a.childNodes.length; c++) {
            var d = a.childNodes.item(c), e = d.nodeName.replace("ows:", ""), e = e.replace("#", "");
            if (typeof b[e] == "undefined") b[e] = this.xmlToJson(d); else {
                if (typeof b[e].push == "undefined") {
                    var f = b[e];
                    b[e] = [];
                    b[e].push(f)
                }
                b[e].push(this.xmlToJson(d))
            }
        }
        return b
    }, getMap: function (a) {
        var b = this.url, b = {};
        if (a.layers) b.LAYERS = a.layers;
        if (a.format) b.FORMAT = a.format;
        if (a.bbox) b.BBOX = "{bbox-epsg-3857}";
        if (a.width) b.WIDTH =
            a.width;
        if (a.height) b.HEIGHT = a.height;
        if (a.version) b.VERSION = a.version;
        if (a.SRS) b.SRS = a.SRS;
        if (a.styles) b.STYLES = a.styles;
        GeoGlobe.Util.applyDefaults(b, {service: "WMS", request: "GetMap", TRANSPARENT: !0});
        return b = this.urlAppend(this.url, this.getParameterString(b || {}))
    }, getParameterString: function (a) {
        var b = [], c;
        for (c in a) {
            var d = a[c];
            if (d != null && typeof d != "function") {
                if (typeof d == "object" && d.constructor == Array) {
                    for (var e = [], f, g = 0, h = d.length; g < h; g++)f = d[g], e.push(encodeURIComponent(f === null || f === void 0 ?
                        "" : f));
                    d = e.join(",")
                }
                b.push(encodeURIComponent(c) + "=" + d)
            }
        }
        return b.join("&")
    }, urlAppend: function (a, b) {
        var c = a;
        if (b) {
            var d = (a + " ").split(/[?&]/);
            c += d.pop() === " " ? b : d.length ? "&" + b : "?" + b
        }
        return c
    }, CLASS_NAME: "GeoGlobe.Service.WMS"
});
GeoGlobe.Service.WMTS = GeoGlobe.Class4OL(GeoGlobe.Service, {
    initialize: function () {
        GeoGlobe.Service.prototype.initialize.apply(this, arguments)
    }, getCapabilities: function (a, b) {
        var c = this.url, d = {REQUEST: "GetCapabilities", SERVICE: "WMTS"};
        b || (b = function () {
            this.failFn(d.REQUEST)
        });
        GeoGlobe.loadURL(c, d, this, function (b) {
            b = b.responseXML;
            GeoGlobe.Function.bind(this.xmlToJson, this);
            var b = this.xmlToJson(b), c = b.Capabilities, d = {}, h = c.Contents.Layer;
            h.length && (h = h[0]);
            d.version = c.attributes.version;
            c = c.Contents;
            d.layer =
                h.Title.text;
            d.LayerIdentifier = h.Identifier.text;
            d.StyleIdentifier = h.Style.Identifier.text;
            d.MatrixSet = h.TileMatrixSetLink[0].TileMatrixSet.text;
            d.Format = h.Format[1].text;
            d.Bounding = h.BoundingBox;
            h = "";
            c = c.TileMatrixSet[0].TileMatrix;
            if (c.length > 0)for (var j = 0, l = c.length; j < l; j++) {
                if (j == l)break;
                h += c[j].ScaleDenominator.text + ","
            }
            d.Scales = h.substr(0, h.length - 1);
            d.zoomOffset = c[0].Identifier.text;
            a(d, b)
        }, b)
    }, xmlToJson: function (a) {
        var b = {};
        if (a.nodeType == 1) {
            if (a.attributes.length > 0) {
                b.attributes = {};
                for (var c =
                    0; c < a.attributes.length; c++) {
                    var d = a.attributes.item(c);
                    b.attributes[d.nodeName] = d.nodeValue
                }
            }
        } else if (a.nodeType == 3) b = a.nodeValue;
        if (a.hasChildNodes())for (c = 0; c < a.childNodes.length; c++) {
            var d = a.childNodes.item(c), e = d.nodeName.replace("ows:", ""), e = e.replace("#", "");
            if (typeof b[e] == "undefined") b[e] = this.xmlToJson(d); else {
                if (typeof b[e].push == "undefined") {
                    var f = b[e];
                    b[e] = [];
                    b[e].push(f)
                }
                b[e].push(this.xmlToJson(d))
            }
        }
        return b
    }, isExist: function () {
        var a = !1;
        GeoGlobe.Request.GET({
            url: this.url, params: {
                REQUEST: "GetCapabilities",
                SERVICE: "WMTS"
            }, scope: this, async: !1, success: function () {
                a = !0
            }
        });
        return a
    }, getTile: function (a) {
        var b = {};
        if (a.layer) b.LAYER = a.layer;
        if (a.format) b.FORMAT = a.format;
        if (a.tileMatrixSet) b.TILEMATRIXSET = a.tileMatrixSet;
        if (a.TILEMATRIX) b.TILEMATRIX = a.TILEMATRIX;
        if (a.TILEROW) b.TILEROW = a.TILEROW;
        if (a.TILECOL) b.TILECOL = a.TILECOL;
        if (a.version) b.VERSION = a.version;
        if (a.style) b.STYLE = a.style;
        GeoGlobe.Util.applyDefaults(b, {service: "WMTS", request: "GetTile"});
        return this.urlAppend(this.url, this.getParameterString(b ||
            {}))
    }, getParameterString: function (a) {
        var b = [], c;
        for (c in a) {
            var d = a[c];
            if (d != null && typeof d != "function") {
                if (typeof d == "object" && d.constructor == Array) {
                    for (var e = [], f, g = 0, h = d.length; g < h; g++)f = d[g], e.push(encodeURIComponent(f === null || f === void 0 ? "" : f));
                    d = e.join(",")
                }
                b.push(encodeURIComponent(c) + "=" + d)
            }
        }
        return b.join("&")
    }, urlAppend: function (a, b) {
        var c = a;
        if (b) {
            var d = (a + " ").split(/[?&]/);
            c += d.pop() === " " ? b : d.length ? "&" + b : "?" + b
        }
        return c
    }, getCapabilitiesForRest: function (a, b) {
        var c = this.url;
        c.match(/\/$/) ||
        (c += "/");
        c += "1.0.0/WMTSCapabilities.xml";
        b || (b = function () {
            this.failFn("GetCapabilities")
        });
        GeoGlobe.loadURL(c, null, this, function (b) {
            a(b)
        }, b)
    }, getTileForRest: function (a) {
        var b = a.layer, c = a.style, d = a.tileMatrixSet, e = a.tileMatrix, f = a.tileRow, g = a.tileCol, h = null,
            a = a.format ? a.format : "image/png", j = {
                "image/png": "png",
                "image/png8": "png",
                "image/png24": "png",
                "image/png32": "png",
                png: "png",
                "image/jpeg": "jpg",
                "image/jpg": "jpg",
                jpeg: "jpg",
                jpg: "jpg"
            };
        h || (h = j[a] || a.split("/").pop());
        b = b + "/" + c + "/" + d + "/" + e + "/" + f + "/" +
            g + "." + h;
        c = this.url;
        c.match(/\/$/) || (c += "/");
        c += b;
        return c
    }, CLASS_NAME: "GeoGlobe.Service.WMTS"
});
GeoGlobe.Service.DTJ = GeoGlobe.Class4OL(GeoGlobe.Service, {
    initialize: function () {
        GeoGlobe.Service.prototype.initialize.apply(this, arguments)
    }, getCapabilities: function (a, b) {
        var c = this.url, d = {REQUEST: "GetCapabilities", SERVICE: "WMS"};
        b || (b = function () {
            this.failFn(d.REQUEST)
        });
        GeoGlobe.loadURL(c, d, this, function (b) {
            b = b.responseXML;
            GeoGlobe.Function.bind(this.xmlToJson, this);
            b = this.xmlToJson(b);
            a(b)
        }, b)
    }, getMap: function (a) {
        var b = {};
        if (a.layers) b.LAYERS = a.layers;
        if (a.format) b.FORMAT = a.format;
        if (a.bbox) b.BBOX =
            "{bbox-epsg-3857}";
        if (a.width) b.WIDTH = a.width;
        if (a.height) b.HEIGHT = a.height;
        if (a.interval) b.INTERVAL = a.interval;
        if (a.GRADSIZE) b.GRADSIZE = a.GRADSIZE;
        if (a.simplitymethod) b.SIMPLIFYMETHOD = a.simplitymethod;
        if (a.intervalcolor) b.INTERVALCOLOR = a.intervalcolor;
        if (a.SIMPLIFYSIZE) b.SIMPLIFYSIZE = a.SIMPLIFYSIZE;
        if (a.INTERPOLAION) b.INTERPOLATIONMETHOD = a.INTERPOLAION;
        if (a.RADIUS) b.RADIUS = a.RADIUS;
        GeoGlobe.Util.applyDefaults(b, {request: "GetMap", service: "WMS", version: "1.1.1"});
        return this.urlAppend(this.url, this.getParameterString(b ||
            {}))
    }, getStatisticInfo: function (a, b, c) {
        var d = {};
        if (a.layers) d.LAYERNAME = a.layers;
        if (a.lnglat) d.X = a.lnglat.lng, d.Y = a.lnglat.lat;
        if (a.simplitymethod) d.SIMPLIFYMETHOD = a.simplitymethod;
        if (a.INTERPOLATIONMETHOD) d.INTERPOLATIONMETHOD = a.INTERPOLATIONMETHOD;
        if (a.SIMPLIFYSIZE) d.SIMPLIFYSIZE = a.SIMPLIFYSIZE;
        if (a.INTERPOLAION) d.INTERPOLAION = a.INTERPOLAION;
        if (a.RADIUS) d.RADIUS = a.RADIUS;
        GeoGlobe.Util.applyDefaults(d, {request: "GetStatisticalValue", service: "WMS", version: "1.1.1"});
        a = this.urlAppend(this.url, this.getParameterString(d ||
            {}));
        GeoGlobe.loadURL(a, d, this, function (a) {
            a = a.responseXML;
            GeoGlobe.Function.bind(this.xmlToJson, this);
            a = this.xmlToJson(a);
            a.FeatureCollection.featureMember && b(a.FeatureCollection.featureMember)
        }, c)
    }, getParams: function (a) {
        var b = {request: "GetMap", service: "WMS", version: "1.1.1"};
        GeoGlobe.Util.extend(b, a);
        return b
    }, getParameterString: function (a) {
        var b = [], c;
        for (c in a) {
            var d = a[c];
            if (d != null && typeof d != "function") {
                if (typeof d == "object" && d.constructor == Array) {
                    for (var e = [], f, g = 0, h = d.length; g < h; g++)f = d[g],
                        e.push(encodeURIComponent(f === null || f === void 0 ? "" : f));
                    d = e.join(",")
                }
                b.push(encodeURIComponent(c) + "=" + d)
            }
        }
        return b.join("&")
    }, urlAppend: function (a, b) {
        var c = a;
        if (b) {
            var d = (a + " ").split(/[?&]/);
            c += d.pop() === " " ? b : d.length ? "&" + b : "?" + b
        }
        return c
    }, xmlToJson: function (a) {
        var b = {};
        if (a.nodeType == 1) {
            if (a.attributes.length > 0) {
                b.attributes = {};
                for (var c = 0; c < a.attributes.length; c++) {
                    var d = a.attributes.item(c);
                    b.attributes[d.nodeName] = d.nodeValue
                }
            }
        } else if (a.nodeType == 3) b = a.nodeValue;
        if (a.hasChildNodes())for (c = 0; c <
        a.childNodes.length; c++) {
            var d = a.childNodes.item(c), e = d.nodeName.replace("ows:", ""), e = e.replace("#", "");
            if (typeof b[e] == "undefined") b[e] = this.xmlToJson(d); else {
                if (typeof b[e].push == "undefined") {
                    var f = b[e];
                    b[e] = [];
                    b[e].push(f)
                }
                b[e].push(this.xmlToJson(d))
            }
        }
        return b
    }, CLASS_NAME: "GeoGlobe.Service.DTJ"
});
GeoGlobe.Service.Fonts = GeoGlobe.Class4OL(GeoGlobe.Service, {
    initialize: function () {
        GeoGlobe.Service.prototype.initialize.apply(this, arguments)
    }, getCapabilities: function (a, b) {
        var c = this.url, d = {REQUEST: "GetCapabilities", SERVICE: "FLS", VERSION: "1.0"};
        b || (b = function () {
            this.failFn(d.REQUEST)
        });
        GeoGlobe.loadURL(c, d, this, function (b) {
            var b = b.responseText, c = new GeoGlobe.Format.JSON, b = b ? c.read(b) : {};
            a(b)
        }, b)
    }, isExist: function () {
        var a = !1;
        GeoGlobe.Request.GET({
            url: this.url, params: {REQUEST: "GetCapabilities", SERVICE: "FLS"},
            scope: this, async: !1, success: function () {
                a = !0
            }
        });
        return a
    }, GetFont: function (a, b) {
        var c = {REQUEST: "GetFont", SERVICE: "FLS", VERSION: "1.0"};
        b || (b = function () {
            this.failFn(c.REQUEST)
        })
    }, getParameterString: function (a) {
        var b = [], c;
        for (c in a) {
            var d = a[c];
            if (d != null && typeof d != "function") {
                if (typeof d == "object" && d.constructor == Array) {
                    for (var e = [], f, g = 0, h = d.length; g < h; g++)f = d[g], e.push(encodeURIComponent(f === null || f === void 0 ? "" : f));
                    d = e.join(",")
                }
                b.push(encodeURIComponent(c) + "=" + d)
            }
        }
        return b.join("&")
    }, urlAppend: function (a,
                            b) {
        var c = a;
        if (b) {
            var d = (a + " ").split(/[?&]/);
            c += d.pop() === " " ? b : d.length ? "&" + b : "?" + b
        }
        return c
    }, CLASS_NAME: "GeoGlobe.Service.Fonts"
});
GeoGlobe.Statistic = GeoGlobe.Class({
    url: null, type: "intersection", initialize: function (a, b) {
        this.url = a;
        GeoGlobe.Util.extend(this, b)
    }, paramUrl: function (a) {
        var b = this.getParams({request: "GetMap"});
        if (a.layers) b.LAYERS = a.layers;
        if (a.format) b.FORMAT = a.format;
        if (a.bbox) b.BBOX = "{bbox-epsg-3857}";
        if (a.width) b.WIDTH = a.width;
        if (a.height) b.HEIGHT = a.height;
        if (a.interval) b.INTERVAL = a.interval;
        if (a.GRADSIZE) b.GRADSIZE = a.GRADSIZE;
        if (a.simplitymethod) b.SIMPLIFYMETHOD = a.simplitymethod;
        if (a.intervalcolor) b.INTERVALCOLOR =
            a.intervalcolor;
        if (a.SIMPLIFYSIZE) b.SIMPLIFYSIZE = a.SIMPLIFYSIZE;
        if (a.INTERPOLAION) b.INTERPOLATIONMETHOD = a.INTERPOLAION;
        if (a.RADIUS) b.RADIUS = a.RADIUS;
        a = {};
        a.url = this.url;
        a.param = b;
        return this.urlAppend(a.url, this.getParameterString(a.param || {}))
    }, getStatisticInfo: function (a) {
        var b = this.getParams({request: "GetStatisticalValue"});
        if (a.layers) b.LAYERNAME = a.layers;
        if (a.lnglat) b.X = a.lnglat.lng, b.Y = a.lnglat.lat;
        if (a.simplitymethod) b.SIMPLIFYMETHOD = a.simplitymethod;
        if (a.INTERPOLATIONMETHOD) b.INTERPOLATIONMETHOD =
            a.INTERPOLATIONMETHOD;
        if (a.SIMPLIFYSIZE) b.SIMPLIFYSIZE = a.SIMPLIFYSIZE;
        if (a.INTERPOLAION) b.INTERPOLAION = a.INTERPOLAION;
        if (a.RADIUS) b.RADIUS = a.RADIUS;
        a = {};
        a.url = this.url;
        a.param = b;
        return this.getStatisticValue(this.urlAppend(a.url, this.getParameterString(a.param || {})))
    }, getParams: function (a) {
        var b = {request: "GetMap", service: "WMS", version: "1.1.1"};
        GeoGlobe.Util.extend(b, a);
        return b
    }, getParameterString: function (a) {
        var b = [], c;
        for (c in a) {
            var d = a[c];
            if (d != null && typeof d != "function") {
                if (typeof d == "object" &&
                    d.constructor == Array) {
                    for (var e = [], f, g = 0, h = d.length; g < h; g++)f = d[g], e.push(encodeURIComponent(f === null || f === void 0 ? "" : f));
                    d = e.join(",")
                }
                b.push(encodeURIComponent(c) + "=" + d)
            }
        }
        return b.join("&")
    }, urlAppend: function (a, b) {
        var c = a;
        if (b) {
            var d = (a + " ").split(/[?&]/);
            c += d.pop() === " " ? b : d.length ? "&" + b : "?" + b
        }
        return c
    }, getStatisticValue: function (a) {
        var b = Cfg.proxyHostUrl + a;
        Cfg.url = a;
        var a = sendAjaxRequest(b, dataChange), b = a.responseXML, c = xmlToJson(b);
        if (!b || !b.documentElement) b = a.responseText;
        if (b)if (c.FeatureCollection.featureMember)return c.FeatureCollection.featureMember;
        else alert("\u670d\u52a1\u4e0d\u53ef\u7528!"); else alert("\u670d\u52a1\u4e0d\u53ef\u7528!")
    }, CLASS_NAME: "GeoGlobe.Statistic"
});
GeoGlobe.ElementContainer = GeoGlobe.Class4OL({
    map: null, initialize: function (a) {
        GeoGlobe.Util.extend(this, a)
    }, addTo: function (a) {
        this.map = a;
        var b = a.getCanvasContainer();
        if (!a.eleContainer) b = GeoGlobe.DOM.create("div", "geoglobe-element-container", b), b.style.width = a.getCanvas().style.width, b.style.height = a.getCanvas().style.height, b.style.position = "absolute", a.eleContainer = b;
        this.container = GeoGlobe.DOM.create("div", null, a.eleContainer);
        this.container.style.width = a.getCanvas().style.width;
        this.container.style.height =
            a.getCanvas().style.height;
        this.container.style.position = "absolute";
        a.isIntScrollZoom = !0
    }, getElMap: function () {
        return this.elmap
    }, remove: function () {
    }, CLASS_NAME: "GeoGlobe.ElementContainer"
});
GeoGlobe.MaptalksEle = GeoGlobe.Class4OL(GeoGlobe.ElementContainer, {
    map: null, container: null, elmap: null, elmapOptions: null, initialize: function () {
        GeoGlobe.ElementContainer.prototype.initialize.apply(this, arguments)
    }, addTo: function () {
        GeoGlobe.ElementContainer.prototype.addTo.apply(this, arguments);
        this.container.id = "GeoGlobe_MaptalksEle";
        this.container.className = "geoglobe-maptalks-container";
        if (window.maptalks && window.maptalks.Map) {
            GeoGlobe.MaptalksEle.overrideMapTalksFunc();
            var a = this.map.getCenter(),a = GeoGlobe.Util.extend({zoom: this.map.getZoom() + 1, center: [a.lng, a.lat]}, this.elmapOptions);
            this.elmap = new maptalks.Map(this.container.id, a);
            this._bindEvent()
        } else console.log("\u4f7f\u7528\u524d\u7f6emaptalks\u5bb9\u5668\uff0c\u9700\u5f15\u5165maptalks\u5730\u56fe\u5e93\u3002")
    }, _bindEvent: function () {
        var a = this.map;
        this._movestart = GeoGlobe.Function.bind(function () {
            if (this._zooming) this._zooming = !1, this._iszoomend = !0
        }, this);
        this._move = GeoGlobe.Function.bind(function () {
            if (!(this._zooming == !0 || this._rotating ==
                !0)) this.elmap._moving = !0, this.syncElmapCenter()
        }, this);
        this._moveend = GeoGlobe.Function.bind(function (a) {
            this.elmap._moving = !1;
            var point = {x:611,y:413};//
            this._rotating = this._zooming = this.elmap._dragRotating = !1;
            var c = this.map.getZoom();
            Math.ceil(c) !== c && this.map.setZoom(Math.ceil(c));
            this._iszoomend ? (this._iszoomend = !1, c = this.map.getZoom() + 1, a = a.target.scrollZoom._pos ? a.target.scrollZoom._pos : point, a = new maptalks.Point(a.x, a.y), this.elmap._zoomTo(c, a), this.elmap._zooming = !1, this.elmap._getRenderer().onZoomEnd(), this.elmap._fireEvent("zoomend",
                {
                    from: this.elmap._startZoomVal,
                    to: c
                }), this.syncElmapCenter()) : (c = this.map.getCenter(), this.elmap.setCenter([c.lng, c.lat]))
        }, this);
        this._rotatestart = GeoGlobe.Function.bind(function () {
            this._rotating = !0;
            this.elmap._dragRotating = !0
        }, this);
        this._rotate = GeoGlobe.Function.bind(function () {
            this.syncElmapRotate()
        }, this);
        this._zoomstart = GeoGlobe.Function.bind(function (a) {
            this._zooming = !0;
            this.elmap._moving = !1;
            //var v = event;
            //var point = {x:v.clientX,y:v.clientY};
            var point = {x:611,y:413};//
            var c = this.map.getZoom() + 1, a = a.target.scrollZoom._pos ? a.target.scrollZoom._pos : point,
                d = new maptalks.Point(a.x,
                    a.y);
            this.origin_lnglat = this.map.unproject(a);
            console.log(d);
            //console.log(point);
            this.elmap.onZoomStart(c, d)
        }, this);
        this._zoom = GeoGlobe.Function.bind(function (a) {
                var point = {x:611,y:413};//
                var c = this.map.getCenter(), d = this.map.getZoom() + 1;
                if (this.elmap._zoomLevel !== d) {
                    var a = a.target.scrollZoom._pos ? a.target.scrollZoom._pos : point,
                        e = this.map.project(this.origin_lnglat);
                    if (a.x !== Math.round(e.x) || a.y !== Math.round(e.y)) this.elmap._zooming = !1;
                    a = new maptalks.Point(a.x, a.y);
                    this.elmap.onZooming(d, a)
                }
                d = this.elmap.getCenter();
                (c.lng - d.x > 2 || c.lng - d.x < -2) && this.syncElmapCenter()
            },
            this);
        this._zoomend = GeoGlobe.Function.bind(function () {
            this._zooming = !1;
            this._iszoomend = !0
        }, this);
        a.on("movestart", this._movestart);
        a.on("move", this._move);
        a.on("moveend", this._moveend);
        a.on("rotatestart", this._rotatestart);
        a.on("rotate", this._rotate);
        a.on("zoomstart", this._zoomstart);
        a.on("zoom", this._zoom);
        a.on("zoomend", this._zoomend)
    }, syncElmapCenter: function () {
        var a = this.map.getCenter(), a = [a.lng, a.lat];
        if (!a)return !1;
        a = new maptalks.Coordinate(a);
        this.elmap._setPrjCenter(this.elmap.getProjection().project(a))
    },
    syncElmapRotate: function () {
        var a = this.map;
        this.elmap && (a.getBearing(), a.getPitch(), this.elmap.setView({bearing: a.getBearing(), pitch: a.getPitch()}))
    }, _syncElmap: function () {
        var a = this.map;
        if (this.elmap) {
            var b = a.getCenter();
            a.getZoom();
            a.getBearing();
            a.getPitch();
            this.elmap.setView({
                center: [b.lng, b.lat],
                zoom: a.getZoom() + 1,
                bearing: a.getBearing(),
                pitch: a.getPitch()
            })
        }
    }, remove: function () {
        var a = this.map;
        a.off("movestart", this._movestart);
        a.off("move", this._move);
        a.off("moveend", this._moveend);
        a.off("rotatestart",
            this._rotatestart);
        a.off("rotate", this._rotate);
        a.off("zoomstart", this._zoomstart);
        a.off("zoom", this._zoom);
        a.off("zoomend", this._zoomend);
        this.container.parentNode.removeChild(this.container);
        this.container = null;
        this.elmap.remove();
        this.map = this.elmap = null
    }, CLASS_NAME: "GeoGlobe.MaptalksEle"
});
GeoGlobe.MaptalksEle.overrideMapTalksFunc = function () {
    if (window.maptalks && window.maptalks.Map) maptalks.Map.prototype.addHandler = function (a, b) {
        if (a === "draggable" || a === "touchZoom" || a === "boxZoom" || a === "doubleClickZoom" || a === "scrollWheelZoom")return this;
        if (!b)return this;
        if (!this._handlers) this._handlers = [];
        if (this[a])return this[a].enable(), this;
        var c = this[a] = new b(this);
        this._handlers.push(c);
        this.options[a] && c.enable();
        return this
    }
};
GeoGlobe.Lang = {
    code: null, defaultCode: "zh-CN", getCode: function () {
        GeoGlobe.Lang.code || GeoGlobe.Lang.setCode();
        return GeoGlobe.Lang.code
    }, setCode: function (a) {
        var b;
        a || (a = GeoGlobe.BROWSER_NAME == "msie" ? navigator.userLanguage : navigator.language);
        a = a.split("-");
        a[0] = a[0].toLowerCase();
        typeof GeoGlobe.Lang[a[0]] == "object" && (b = a[0]);
        if (a[1]) {
            var c = a[0] + "-" + a[1].toUpperCase();
            typeof GeoGlobe.Lang[c] == "object" && (b = c)
        }
        if (!b) GeoGlobe.Console.warn("Failed to find GeoGlobe.Lang." + a.join("-") + " dictionary, falling back to default language"),
            b = GeoGlobe.Lang.defaultCode;
        GeoGlobe.Lang.code = b
    }, translate: function (a, b) {
        var c = GeoGlobe.Lang[GeoGlobe.Lang.getCode()];
        (c = c && c[a]) || (c = a);
        b && (c = GeoGlobe.String.format(c, b));
        return c
    }
};
GeoGlobe.i18n = GeoGlobe.Lang.translate;
GeoGlobe.Lang.en = {unhandledRequest: "Unhandled request return ${statusText}", end: ""};
GeoGlobe.Lang["zh-CN"] = {
    unhandledRequest: "\u672a\u5904\u7406\u7684\u8bf7\u6c42\uff0c\u8fd4\u56de\u503c\u4e3a ${statusText}",
    end: ""
};
